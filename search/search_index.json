{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Accueil","text":""},{"location":"#objectif","title":"Objectif","text":"<p>Attention</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan, mis en forme par Mehdi et propuls\u00e9 avec le soutien de Nolan. Nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible et esthetique pendant les p\u00e9riodes de r\u00e9vision que des diaporamas</p>"},{"location":"#credits","title":"Cr\u00e9dits","text":"<p>Le site de notre professeur d'informatique,  Site originel</p>"},{"location":"#legende","title":"L\u00e9gende","text":""},{"location":"#theoremes","title":"Th\u00e9or\u00e8mes","text":"<p>Pour mettre en valeur un th\u00e9or\u00e8me, on utilise la syntaxe suivante :</p> <p>Th\u00e9or\u00e8me</p> <p>Lorem impsum</p> <pre><code>!!!danger \"\"\n    **Th\u00e9or\u00e8me**\n\n    Lorem impsum\n</code></pre>"},{"location":"#propostions","title":"Propostions","text":"<p>Pour mettre en valeur une proposition, on utilise la syntaxe suivante :</p> <p>Proposition</p> <p>Lorem impsum</p> <pre><code>!!!warning \"\"\n    **Proposition**\n\n    Lorem impsum\n</code></pre>"},{"location":"#corollaires","title":"Corollaires","text":"<p>Pour mettre en valeur un corollaire, on utilise la syntaxe suivante :</p> <p>Corollaire</p> <p>Lorem impsum</p> <pre><code>!!!quote \"\"\n    **Corollaire**\n\n    Lorem impsum\n</code></pre>"},{"location":"#definitions","title":"D\u00e9finitions","text":"<p>Pour mettre en valeur une d\u00e9finition, on utilise la syntaxe suivante :</p> <p>D\u00e9finition: Lorem</p> <p>Lorem impsum</p> <pre><code>!!!quote \"\"\n    **D\u00e9finition**\n\n    Lorem impsum\n</code></pre>"},{"location":"#preuves-demonstrations","title":"Preuves / D\u00e9monstrations","text":"<p>Pour mettre en valeur un preuve, on utilise la syntaxe suivante :</p> <p>Preuve</p> <p>Lorem impsum</p> <pre><code>!!!note \"\"\n    **Preuve**\n\n    Lorem impsum \n</code></pre>"},{"location":"#remarques-credits","title":"Remarques / Cr\u00e9dits","text":"<p>Pour mettre en valeur une remarque ou les cr\u00e9dits, on utilise la syntaxe suivante :</p> <p>Remarque/Credit</p> <p>Lorem impsum</p> <pre><code>!!!tip \"\"\n    **Remarque/Credit**\n\n    Lorem impsum\n</code></pre>"},{"location":"#exemples-exercices","title":"Exemples / Exercices","text":"<p>Pour mettre en valeur un exemple, on utilise la syntaxe suivante :</p> <p>Exemple</p> <p>Lorem impsum</p> <pre><code>!!!example \"\"\n    **Exemple**\n\n    Lorem impsum\n</code></pre> <p>Ou si l'exemple est trop long ou qu'il n'est pas forc\u00e9ment primordiale :</p> Exemple / Exercice <p>Lorem impsum t</p> <pre><code>???example \"Exemple / Exercice\"\n    Lorem \n    impsum\n    t\n</code></pre> <p>Si c'est un exercice, sa potentielle correction se fait comme ceci :</p> <p>Correction</p> <p>Bla bla bla</p> <pre><code>!!!tip \"Correction\n    Bla\n    bla\n    bla\n</code></pre>"},{"location":"#attention","title":"Attention","text":"<p>Pour mettre en valeur une attention, on utilise la syntaxe suivante :</p> <p>Attention</p> <p>Lorem impsum t</p> <pre><code>!!!warning \"Attention\"\n    Lorem \n    impsum \n    t\n</code></pre>"},{"location":"#danger","title":"Danger","text":"<p>Pour mettre en valeur un danger, on utilise la syntaxe suivante :</p> <p>Danger</p> <p>Lorem impsum t</p> <pre><code>!!!danger \"Danger\"\n    Lorem \n    impsum\n    t\n</code></pre>"},{"location":"#supplement","title":"Suppl\u00e9ment","text":"<p>On utilisera en plus, ceci, pour mettre en valeur un bloc d'id\u00e9e :</p> <p>Mon id\u00e9e trop g\u00e9niale</p> <ul> <li>Premier point</li> <li>Deuxi\u00e8me point<ul> <li>Sous point</li> <li>Sous point </li> </ul> </li> </ul> <pre><code>!!!note inline \"\"\n    Mon id\u00e9e trop g\u00e9niale\n\n    - Premier point\n    - Deuxi\u00e8me point\n        - Sous point\n        - Sous point\n</code></pre>"},{"location":"Algorithmique/Glouton/","title":"Algorithmes gloutons","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"Algorithmique/Glouton/#generalites","title":"G\u00e9n\u00e9ralit\u00e9s","text":""},{"location":"Algorithmique/Glouton/#presentation","title":"Pr\u00e9sentation","text":"<p>Un algorithme glouton (greedy algorithm en anglais, parfois  appel\u00e9 aussi algorithme gourmand, ou goulu) est un  algorithme qui suit le principe de r\u00e9aliser, \u00e9tape par \u00e9tape, un  choix optimum local, afin d\u2019obtenir un r\u00e9sultat optimum  global (Wikipedia).  </p> <p>Exemples classiques</p> <ul> <li>Rendu de monnaie</li> <li>Coloration des sommets d\u2019un graphe</li> <li>Algorithme de Dijkstra pour la recherche de PCC ;  </li> </ul> <p>Un algorithme glouton fournit le plus souvent une solution au  probl\u00e8me. Dans les cas o\u00f9 il ne donne pas syst\u00e9matiquement  la solution optimale, il est appel\u00e9 une heuristique gloutonne.  </p> <p>Exemple d\u2019heuristique gloutonne</p> <p><p></p></p> <p>Un algorithme glouton peut retourner une solution sous-optimale.  </p> <p>En partant du point \\(A\\) et en cherchant \u00e0 monter selon la plus forte pente, un algorithme glouton trouvera le maximum local  \\(m\\), mais pas le maximum global \\(M\\).</p> <p>Il faut bien comprendre que m\u00eame si elle ne fournit pas toujours de solution optimale, une strat\u00e9gie gloutonne est souvent adopt\u00e9e en raison de la simplicit\u00e9 de sa mise en \u0153uvre.</p>"},{"location":"Algorithmique/Glouton/#exemple-du-rendu-de-monnaie","title":"Exemple du rendu de monnaie","text":""},{"location":"Algorithmique/Glouton/#presentation_1","title":"Pr\u00e9sentation","text":"<p>Soit un ensemble \\(C\\) (pour \"coins\") de \\(n\\) valeurs enti\u00e8res de billets et pi\u00e8ces de monnaies \\(v_1 &lt; v_2 &lt; \u00b7\u00b7\u00b7 &lt; v_n\\). Par exemple  \\(C =\\text{ {1\u20ac, 2\u20ac, 5\u20ac, 10\u20ac, 20\u20ac, 100\u20ac, 200\u20ac}}\\)</p> <p>Le probl\u00e8me du rendu de monnaie consiste \u00e0 d\u00e9terminer le  nombre minimal de billets et de pi\u00e8ces pour rendre une somme donn\u00e9e. Par exemple, la somme de \\(49\\)\u20ac peut \u00eatre rendue en utilisant \\(49\\) pi\u00e8ces de \\(1\\)\u20ac, ou \\(2\\) billets de \\(20\\)\u20ac, \\(1\\) billet de \\(5\\)\u20ac et \\(2\\) pi\u00e8ces de \\(2\\)\u20ac. Donc \\(5\\) billets/pi\u00e8ces rendues VS \\(49\\). Ce nombre \\(5\\) est  d\u2019ailleurs le plus petit qu\u2019on puisse trouver pour le syst\u00e8me de pi\u00e8ces \\(C\\).  </p>"},{"location":"Algorithmique/Glouton/#precisions","title":"Pr\u00e9cisions","text":"<p>Pour raison de concision, nous emploierons dans toute la suite  le terme \"pi\u00e8ce\" au lieu de \"pi\u00e8ce ou billet\". </p> <p>De plus nous supposons que le stock de chaque valeur de pi\u00e8ce est illimit\u00e9, ce qui ne re\ufb02\u00e8te que partiellement la r\u00e9alit\u00e9 (dans un \\(DAB\\), il y a un nombre fini de billets de \\(10\\),\\(20\\),\\(50\\) et \\(100\\)\u20ac). </p> <p>La solution calcul\u00e9e par l\u2019algorithme que nous pr\u00e9sentons et  donc une solution th\u00e9orique qui ne tient pas compte de la r\u00e9alit\u00e9 du stock.  </p>"},{"location":"Algorithmique/Glouton/#strategie","title":"Strat\u00e9gie","text":"<p>On choisit d\u2019abord les pi\u00e8ces qui permettent de rendre la plus  grande valeur possible sur la somme \u00e0 rendre. Dans l\u2019exemple des \\(49\\)\u20ac, il s\u2019agit de deux billets de \\(20\\)\u20ac.</p> <p>Il reste alors \u00e0 rendre \\(9\\)\u20ac. On choisit la plus grande valeur de  pi\u00e8ce plus petite que \\(9\\), soit \\(5\\)\u20ac. On rend donc un billet de 5 (et pas \\(2\\) car \\(2 \u00d7 5 &gt; 9\\)). Enfin la plus grande valeur de pi\u00e8ce plus petite que les \\(4\\)\u20ac \u00e0 rendre est \\(2\\)\u20ac. On peut en rendre deux, ce qui ram\u00e8ne la somme \u00e0 rendre \u00e0 \\(0\\)\u20ac. On s\u2019arr\u00eate donc l\u00e0.  </p>"},{"location":"Algorithmique/Glouton/#code","title":"Code","text":"<pre><code>let greedy_change (coins:int array) (v:int): int array =\n    let n = Array.length coins in\n    let change = Array.make n 0 in\n    let cur = ref v and i = ref (n-1) in\n    while !cur &gt; 0 do\n        let c = coins.(!i) in\n        if !cur &lt; c then decr i\n        else (\n            change.(!i) &lt;- change.(!i)+1;\n            cur := !cur - c\n        )\n    done ;\n    change ;;\n</code></pre> <p>Param\u00e8tres et variables</p> <p>Param\u00e8tres :  </p> <ul> <li><code>coins</code> : tableau des valeurs de pi\u00e8ces avec <code>t.(0)=1</code> </li> <li><code>v</code> : valeur \u00e0 rembouser  </li> </ul> <p>Variables locales :  </p> <ul> <li><code>!i</code> : num\u00e9ro de la valeur courante de pi\u00e8ce</li> <li><code>change.(!i)</code> : nb de pi\u00e8ces de la valeur courante  </li> <li><code>!cur</code> : somme restant \u00e0 rendre.  </li> </ul>"},{"location":"Algorithmique/Glouton/#correction-du-programme","title":"Correction du programme","text":"<p>Un variant de boucle est <code>!cur + !i</code>. Terminaison OK.  </p> <p>La condition \\(t_0 = 1\\) assure la correction (principe : apcr, on  peut rendre autant de pi\u00e8ces de \\(1\\)\u20ac que la somme restante). Le fait que \\(t_0 = 1\\), assure que <code>!i \u2265 0</code> et donc l\u2019acc\u00e8s valide  au tableau <code>coins</code>.  </p>"},{"location":"Algorithmique/Glouton/#optimalite","title":"Optimalit\u00e9","text":"<p>Proposition</p> <p>Si <code>coins</code> d\u00e9crit le syst\u00e8me mon\u00e9taire de la zone euro, alors le programme <code>greedy_change</code> cacule un rendu de monnaie avec le nombre minimal d\u2019\u00e9l\u00e9ments.  </p> <p>Remarque</p> <p>Un syst\u00e8me de pi\u00e8ces qui, tel celui de la zone euro, permet un rendu optimal est qualifi\u00e9 de canonique.  </p> <p>Preuve</p> <p>Certaines combinaison de pi\u00e8ces ne peuvent se trouver dans une solution optimale :</p> <ul> <li> <p>Une pi\u00e8ce de valeur val \\(= 1,5,10,50\\) ou \\(100\\) n\u2019est jamais utilis\u00e9 deux fois dans une solution optimale. En e\ufb00et, pour chacune de ces valeurs il est plus avantageux de rendre une pi\u00e8ce de valeur 2val plut\u00f4t que deux de valeur val.</p> </li> <li> <p>Une pi\u00e8ce de valeur \\(2\\) ou \\(20\\) n\u2019est jamais utilis\u00e9e \\(3\\) fois dans une solution optimale. En e\ufb00et \\(3\\) pi\u00e8ces de valeur \\(2\\) sont avantageusement remplac\u00e9e par par une pi\u00e8ce de valeur \\(1\\) et une de \\(5\\) ; \\(3\\) pi\u00e8ces de valeur \\(20\\) sont remplac\u00e9es par une \\(10\\) et une de \\(50\\).</p> </li> <li> <p>Une pi\u00e8ce de valeur \\(1\\) n\u2019accompagne jamais deux pi\u00e8ces de valeur \\(2\\) : on pourrait remplacer l\u2019ensemble par une pi\u00e8ce de \\(5\\). Une pi\u00e8ce de valeur \\(10\\) n\u2019accompagne jamais deux pi\u00e8ces de valeur \\(20\\) : on pourrait remplacer l\u2019ensemble par une pi\u00e8ce de \\(50\\).  </p> </li> </ul> <p>Exercice</p> <p>Ecrivons un petit programme qui prend en compte les  contraintes pr\u00e9c\u00e9dentes et faisons le tourner pour explorer  exhaustivement toutes les combinaisons possibles de pi\u00e8ces de  moins de \\(200\\)\u20ac. </p> <p>Correction</p> <p>La correction ci-dessous est longue, mais est int\u00e9ressante \u00e0 lire car c'est un alogrithme de backtracking assez simple \u00e0 comprendre.</p> Correction longue <pre><code>let greedy_change (coins:int array) (v:int) : int array =\n    let n = Array.length coins in\n    let change = Array.make n 0 in\n    let cur = ref v and i = ref (n-1) in\n    while !cur &gt; 0 do\n        let c = coins.(!i) in\n        if !cur &lt; c then decr i\n        else (\n            change.(!i) &lt;- change.(!i)+1;\n            cur:=!cur -c\n        )\n    done;\n    change;;\n\nlet coins  = [|1;2;5;10;20;50;100|];;\nlet nb_max =  [|1;2;1;1;2;1;1|];;\n\nlet contraint3 t =\nif t.(0)=1 &amp;&amp; t.(1) = 2\nthen false\nelse (if t.(3)=1 &amp;&amp; t.(4) = 2\nthen false else true);;\n\nlet value t =\nlet n= Array.length t in\nlet s = ref 0 in\nfor i = 0 to n-1 do\n    s :=\n    !s + t.(i) * coins.(i)\ndone; !s ;;\n\nvalue nb_max ;;\n\nlet maximum tab =\nlet j = ref 0 and n = Array.length tab in\nfor k= 1 to n-1 do\n    if snd tab.(k) &gt; snd tab.(!j) then j:=k;\ndone;\ntab.(!j);;\n\nlet check () =\nlet rec aux i acc =\n    match i with\n    | x  when x&lt;7 -&gt; explore i acc\n    |  _ -&gt; (*i=7*) let newacc = List.rev acc in\n                    let t = Array.of_list newacc in\n                    let v = value t in\n                    if contraint3 t then t,v\n                    else (Array.make 0 7), 0\nand explore i acc = \n    let nb = nb_max.(i) in\n    let tab = Array.make (nb+1) ([||],0) in\n    for j = 0 to nb do\n    tab.(j) &lt;- aux (i+1) (j::acc);\n    done; maximum tab\nin aux 0 [];;\n\ncheck();;\n\nlet coins  = [|1;2;5;10;20;50;100|];;\n(*contraintes 1 et 2*)\nlet nb_max =  [|1;2;1;1;2;1;1|];;\n\n(*3 tableaux de choix de pi\u00e8ces et 3 valeurs associ\u00e9es On renvoie le\ntuple t,v dont v est le plus grand\n*)\nlet maxi t1 v1 t2 v2 t3 v3 =\nlet v = max v1 (max v2 v3) in\nif v = v1 then t1,v1 else\n    (if v = v2 then t2,v2 else t3, v3);;\n\nlet check () =\nlet contraint3 t =\n    if t.(0)=1 &amp;&amp; t.(1) = 2\n    then false\n    else (if t.(3)=1 &amp;&amp; t.(4) = 2\n        then false else true)\nin let rec aux i acc = match i with\n        | x  when x&lt;7 &amp;&amp; nb_max.(i) = 1 -&gt;\n        let t1,v1 = aux (i+1) (0::acc)\n        in let  t2,v2 = aux (i+1) (1::acc) in\n        if v1&lt;v2 then t2,v2 else t1,v1\n        |  x when x&lt;7 &amp;&amp; nb_max.(i) = 2 -&gt;\n        let t1,v1 = aux (i+1) (0::acc)\n        in let t2,v2 = aux (i+1) (1::acc) in\n        let t3,v3 = aux (i+1) (2::acc) in\n        let v =  max v1 (max v2 v3) in\n        if v = v1 then t1,v1 else\n            (if v = v2 then t2,v2 else t3, v3)\n        |  _ -&gt; (*i=7*)\n        let newacc = List.rev acc in\n        let t = Array.of_list newacc in\n        let v = value t in\n        if contraint3 t then t,v\n        else (Array.make 7 0), 0\nin aux 0 [];;\n\ncheck();;\n</code></pre> <p>Explication On constate que la plus grande somme possible remboursable  avec ces pi\u00e8ces est  </p> \\[2 \u00d7 2 + 5 + 2 \u00d7 20 + 50 + 100 = 199\\] <p>Ainsi, la solution optimale ne pourra JAMAIS rembourser plus  de \\(199\\)\u20ac avec des pi\u00e8ces de moins de \\(200\\)\u20ac. Dit autrement,  la solution optimale doit rembourser toute somme \\(S &gt; 200\\)\u20ac avec le maximum possible de pi\u00e8ces de \\(200\\)\u20ac (qui est en fait  \\(k = S/200\\)). Or, notre algorithme calcule exactement \\(k\\).  </p> <p>Pour une somme inf\u00e9rieure \u00e0 \\(199\\)\u20ac reprenons notre petit  programme et faison le tourner pour trouver le nombre  maximum de pi\u00e8ces de moins de \\(100\\) euros.  </p> <p>On trouve alors que la solution optimale ne peut rembourser  qu\u2019une somme de \\(99\\)\u20ac avec ces pi\u00e8ces. Pour rembourser  une somme entre entre \\(100\\)\u20ac et \\(199\\)\u20ac, il faut un billet de \\(100\\)\u20ac.</p> <p>C\u2019est exactement la quantit\u00e9 que trouve notre programme dans ce cas l\u00e0!</p> <p>etc.</p>"},{"location":"Algorithmique/prodgyn/","title":"Programmation dynamique","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"Algorithmique/prodgyn/#presentation","title":"Pr\u00e9sentation","text":""},{"location":"Algorithmique/prodgyn/#introduction","title":"Introduction","text":"<p>La r\u00e9solution d\u2019un probl\u00e8me peut parfois se faire en le d\u00e9composant en  sous-probl\u00e8mes. Dans cette approche, les solutions aux sous-probl\u00e8mes sont ensuite combin\u00e9es pour construire la solution au probl\u00e8me initial.  </p> <ul> <li>si les sous-probl\u00e8mes sont ind\u00e9pendants les uns des autres (exemple :  d\u00e9composition en sous-ensembles disjoints comme pour le tri fusion),  on parle de m\u00e9thode diviser pour r\u00e9gner</li> <li>si les sous-probl\u00e8mes sont d\u00e9pendants (exemple : si un m\u00eame calcul -avec les m\u00eames param\u00e8tres- est fait par chaque sous-probl\u00e8me), on parle de programmation dynamique.  </li> </ul>"},{"location":"Algorithmique/prodgyn/#historique","title":"Historique","text":"<p>D\u00e9finition : Programmation dynamique</p> <p>Processus de r\u00e9solution de probl\u00e8mes o\u00f9 on trouve les meilleures d\u00e9cisions les unes apr\u00e8s les autres.  </p> <p>Le terme \u00e9tait utilis\u00e9 par le math\u00e9maticien Richard Bellman d\u00e8s les ann\u00e9es 40.  </p> <p>En 1953, Bellman en donne la d\u00e9finition moderne, o\u00f9 les d\u00e9cisions \u00e0  prendre sont ordonn\u00e9es par sous-probl\u00e8mes. Le domaine a alors \u00e9t\u00e9 reconnu par l\u2019Institute of Electrical and  Electronics Engineers (IEEE) comme un sujet d\u2019analyse de syst\u00e8mes et  d\u2019ing\u00e9nierie.  </p>"},{"location":"Algorithmique/prodgyn/#diviser-pour-regner","title":"Diviser pour r\u00e9gner","text":"<p>La m\u00e9thode Diviser pour r\u00e9gner est un cas particulier de  programmation dynamique. On d\u00e9compose encore un probl\u00e8me principal en sous-probl\u00e8mes.  Cependant, les sous-probl\u00e8mes sont ici ind\u00e9pendants les uns des autres  ce qui facilite la t\u00e2che du programmeur.  </p> <p>Principe</p> <p>On divise en r\u00e9duisant un probl\u00e8me en sous-probl\u00e8mes du m\u00eame type et  qui ne se chevauchent pas. Puis on r\u00e8gne en r\u00e9solvant ces sous-probl\u00e8mes.  Il reste \u00e0 rassembler les solutions des sous-probl\u00e8mes pour obtenir une  soution au probl\u00e8me initial.  </p>"},{"location":"Algorithmique/prodgyn/#cadre-dapplication","title":"Cadre d\u2019application","text":"<p>La programmation dynamique est envisag\u00e9e si le probl\u00e8me pr\u00e9sente la propri\u00e9t\u00e9 de sous-structure optimale et si les chevauchements de sous-probl\u00e8mes doivent \u00eatre g\u00e9r\u00e9s.</p>"},{"location":"Algorithmique/prodgyn/#vocabulaire","title":"Vocabulaire","text":"<p>D\u00e9finition: Sous-structure optimale</p> <p>Se dit d\u2019un probl\u00e8me qu\u2019on peut r\u00e9soudre en le d\u00e9composant en sous-probl\u00e8mes du m\u00eame type,  eux-m\u00eames r\u00e9solubles r\u00e9cursivement.</p> <p>D\u00e9finition: Chevauchement de sous-probl\u00e8mes</p> <p>Se dit si des sous-probl\u00e8mes ne sont pas ind\u00e9pendants et doivent \u00eatre r\u00e9solus plusieurs  fois.</p> <p>En g\u00e9n\u00e9ral on envisage tous les sous-probl\u00e8mes comme dans une  recherche exhaustive mais on prend ses pr\u00e9cautions pour ne pas avoir \u00e0  les r\u00e9soudre tous :  </p> <ul> <li>soit parce que certains sont inutiles (ex : recherche dichotomique)  </li> <li>soit parce qu\u2019ils ont d\u00e9j\u00e0 \u00e9t\u00e9 rencontr\u00e9s et r\u00e9solus (ex : m\u00e9mo\u00efsation  dans le calcul des suites de Fibonacci)  </li> </ul>"},{"location":"Algorithmique/prodgyn/#principe-doptimalite","title":"Principe d\u2019optimalit\u00e9","text":"<p>La programmation dynamique s\u2019applique \u00e0 des probl\u00e8mes  d\u2019optimisations : il s\u2019agit souvent d\u2019optimiser le co\u00fbt d\u2019une suite de  d\u00e9cisions.</p> <p>Cette suite de d\u00e9cisions correspond \u00e0 un d\u00e9coupage du probl\u00e8me en  sous-probl\u00e8mes :  </p> <ul> <li>On calcule les solutions optimales successives comme pour un algorithme glouton \u00e0 des sous probl\u00e8mes li\u00e9s par une relation de r\u00e9currence.  </li> <li>Puis, c\u2019est la combinaison de ces solutions qui produit la solution au  probl\u00e8me initial.  </li> </ul> <p>Principe d\u2019optimalit\u00e9 de Bellman : une solution optimale pour un probl\u00e8me pr\u00e9sentant la propri\u00e9t\u00e9 de sous-structure optimale est la combinaison de solutions optimales locales pour les sous-probl\u00e8mes.  </p>"},{"location":"Algorithmique/prodgyn/#programmation-dynamique-et-graphes","title":"Programmation dynamique et graphes","text":"<ul> <li>Un th\u00e9or\u00e8me g\u00e9n\u00e9ral \u00e9nonce que tout algorithme de programmation dynamique peut se ramener \u00e0 la recherche du plus court chemin dans un graphe.  </li> <li>Or, les techniques de recherche heuristique bas\u00e9es sur l\u2019algorithme \\(A^*\\) permettent d\u2019exploiter les propri\u00e9t\u00e9s sp\u00e9cifiques d\u2019un probl\u00e8me pour gagner en temps de calcul.  </li> <li>Autrement dit, il est souvent plus avantageux d\u2019exploiter un algorithme \\(A^*\\) que d\u2019utiliser la programmation dynamique.  </li> </ul>"},{"location":"Algorithmique/prodgyn/#exemples","title":"Exemples","text":""},{"location":"Algorithmique/prodgyn/#suites-de-fibonacci","title":"Suites de Fibonacci","text":"<p>Voir TD d\u00e9di\u00e9.  </p>"},{"location":"Algorithmique/prodgyn/#definition","title":"D\u00e9finition","text":"<p>On appelle suite de Fibonacci toute suite r\u00e9elle ou complexe \\((f_n)_{n\u2208N}\\) r\u00e9currente d\u2019ordre 2 d\u00e9finie par \\(f_{n+2} = f_{n+1} + f_n\\) pour tout \\(n \u2208 N\\). Souvent \\(f_0 = 0, f_1 = 1\\), c\u2019est ce que nous prendrons par la suite.</p>"},{"location":"Algorithmique/prodgyn/#premiere-implementation","title":"Premi\u00e8re impl\u00e9mentation","text":""},{"location":"Algorithmique/prodgyn/#code","title":"Code","text":"<p>On peut proposer le code suivant :</p> <pre><code>let rec fib n = \n    match n with \n    | 0 | 1 -&gt; n \n    | _ -&gt; (fib (n-1)) + (fib (n-2));;\n</code></pre>"},{"location":"Algorithmique/prodgyn/#calcul-de-f_5","title":"Calcul de \\(f_5\\)","text":"<p>On constate que \\(f_2\\) est calcul\u00e9 3 fois.</p>"},{"location":"Algorithmique/prodgyn/#complexite","title":"Complexit\u00e9","text":"<p>Si \\(C (n)\\) est la complexit\u00e9 pour calculer \\(f_n\\) , alors     \\(C (n) = C (n \u2212 1) + C (n \u2212 2) \u2265 2C (n \u2212 2)\\) en admettant que la complexit\u00e9 soit croissante On obtient que \\(C (n) \u2265 2^{\\frac{n}{2}} \\times max(C (0), C (1)) \u2265 2^{\\frac{n}{2} -1} \u2265 \\frac{1}{2}(\\sqrt{2})^n\\) Complexit\u00e9 au moins exponentielle. De la m\u00eame fa\u00e7on, on peut majorer \\(C (n)\\) par \\(2^n\\). La complexit\u00e9 n\u2019est pas \\(\"\\)plus\\(\"\\) qu\u2019exponentielle.</p>"},{"location":"Algorithmique/prodgyn/#fibonnaci-memoisation","title":"Fibonnaci : m\u00e9mo\u00efsation","text":""},{"location":"Algorithmique/prodgyn/#approche-descendante","title":"Approche descendante","text":"<p>M\u00e9mo\u0131\u0308sation :</p> <ul> <li>On m\u00e9morise une valeur de la suite si c\u2019est la premi\u00e8re fois qu\u2019on la rencontre.</li> <li>Si on a d\u00e9j\u00e0 rencontr\u00e9 le calcul courant, on r\u00e9cup\u00e8re sa valeur par un acc\u00e8s \u00e0 la structure de stockage en O(1)</li> <li>On ne lance le calcul que si la valeur voulue n\u2019a pas d\u00e9j\u00e0 \u00e9t\u00e9 calcul\u00e9e.</li> </ul> <p>Approche descendante : On commence par lancer les calculs pour les valeurs de param\u00e8tres les plus grands. Ces calculs induisent des appels avec des param\u00e8tres plus petits.</p> <p>Dans le cas qui nous occupe, le calcul de f (n) am\u00e8ne \u00e0 g\u00e9rer un tableau de \\(n + 1\\) cases dont la case \\(i\\) contient \u22121 (pas encore calcul\u00e9) ou \\(f (i)\\) (calcul d\u00e9j\u00e0 rencontr\u00e9).</p> <p>Mais ici, un tableau n\u2019est pas n\u00e9cessaire : il suffit de m\u00e9moriser les 2 derni\u00e8res valeurs.</p>"},{"location":"Algorithmique/prodgyn/#partition-equilibree-dun-tableau-dentiers-positifs","title":"Partition \u00e9quilibr\u00e9e d'un tableau d'entiers positifs","text":""},{"location":"Algorithmique/prodgyn/#presentation-du-probleme","title":"Pr\u00e9sentation du probl\u00e8me","text":"<p>On dispose d\u2019un (multi) ensemble d\u2019entiers positifs \\(E\\).</p> <p>On souhaite d\u00e9terminer une partition de \\(E\\) en deux sous-ensembles \\(E_1, E_2\\) tels que  </p> <ul> <li> <p>\\(E_1 \\cup E_2 = E\\); \\(E_1 \\cap E_2 = \\emptyset\\) (partition)</p> </li> <li> <p>La somme des \u00e9l\u00e9ments de \\(E_1\\) et celle de \\(E_2\\) sont les plus proches possibles. Cela signifie que</p> </li> </ul> \\[ |\\sum_{x \\in E_1} x - \\sum_{y \\in E_2} y| = \\newline min(\\ \\{ |\\sum_{x \\in E'} x - \\sum_{y \\in E''} y| \\text{ avec (E', E'') une partition de E} \\ \\}) \\] <p>On note \\(S\\) la somme des \u00e9l\u00e9ments de \\(E\\) et \\(S(A)\\) la somme des \u00e9l\u00e9ments d\u2019un sous-ensemble \\(A\\). \\(S/2\\) d\u00e9signe la division euclidienne de \\(S\\) par \\(2\\).  </p>"},{"location":"Algorithmique/prodgyn/#approche-gloutonne","title":"Approche gloutonne","text":"<p>Pour  \\(E = \\{e, . . . , e_n\\}\\) : On g\u00e8re deux sous-ensembles \\(E_1\\), \\(E_2\\) initialis\u00e9s resp. en {\\(e_1\\)}, \\(\u2205\\).  </p> <p>On place les \u00e9l\u00e9ments suivants dans \\(E\\) un \u00e0 un jusqu\u2019\u00e0 ce que \\(S(E_2) &gt; S(E_1)\\). Les \u00e9l\u00e9ments suivants sont alors plac\u00e9s dans \\(E_1\\) etc.  </p> <p>Malheureusement, m\u00eame en triant les \u00e9l\u00e9ments de E , la solution  fournie n\u2019est pas toujours optimale.</p> <p>Exercice</p> <p>Implanter cet algorithme. Donner sa complexit\u00e9. Exhiber un exemple o\u00f9 la solution n\u2019est pas optimale.</p> <p>Correction</p> <p><pre><code>let greedy_partition e =\n    let rec aux l l1 l2 s1 s2 =\n        match l with\n        | [] -&gt; l1, l2\n        |x::q -&gt; if x + s1 &lt; s2 then\n                aux q (x::l1) l2 (s1+x) s2\n            else aux q (x::l2) l1 (s2+x) s1\n    in match e with\n        | [] -&gt; [], []\n        | x::q -&gt; aux q [x] [] x 0\n;;\n</code></pre> \\(C(n) = 2\\times C(n-1) + ... \\text{ donc }  C(n)\\text{ est en }O(2^n)\\)</p>"},{"location":"Algorithmique/prodgyn/#algorithme-base-sur-la-demi-somme","title":"Algorithme bas\u00e9 sur la demi-somme","text":"<p>On dispose d\u2019un ensemble d\u2019entiers positifs \\(E\\) . Si \\(E_1\\) et \\(E_2\\) r\u00e9alisent une partition \u00e9quilibr\u00e9e de \\(E\\) , quitte \u00e0 les \u00e9changer, on peut supposer \\(S(E_1) \u2264 S(E_2)\\)</p> <p>Comme \\(S(E_1) + S(E_2) = S\\), on a \\(S(E_1) \u2264 \\frac{S}{2} \\leq S(E_2)\\) les \u00e9l\u00e9ments sont entiers, on obtient \\(S(E_1) \u2264 (S/2) \u2264 S(E_2)\\).  </p>"},{"location":"Algorithmique/prodgyn/#distance-a-la-demi-somme","title":"Distance \u00e0 la demi-somme","text":"<p>Soit \\(A \u2282 E\\) tel que :  </p> \\[|S/2 - \\sum_{a\\in A} a| = min(\\{|S/2 - \\sum_{x \\in X} x| \\text{ avec } X \\subset E\\})\\] <p>Si \\(S(A) \u2264 S/2\\), soit \\((F, G)\\) partition de \\(E\\) telle que \\(S(F) \u2264 S(G)\\). Alors \\(S(F) \u2264 S/2\\).  </p> <p>Puisque \\(A\\) r\u00e9alise la meilleure distance \u00e0 \\(S/2\\) : $$S(F ) \u2264 S(A) \\text{ et } S(E \\setminus A) \u2264 S(G) $$ Et donc \\(|S(E \\backslash A) \u2212 S(A)| \u2264 |S(G ) \u2212 S(F )|\\)</p> <p>De m\u00eame si \\(S(A) \u2265 S/2\\). On en d\u00e9duit que \\(\\color{red}(A, E \\backslash A) \\text{ r\u00e9alise une  partition \u00e9quilibr\u00e9e de } E.\\) </p>"},{"location":"Algorithmique/prodgyn/#solution-par-programmation-dynamique","title":"Solution par programmation dynamique","text":""},{"location":"Algorithmique/prodgyn/#methode-descendante","title":"M\u00e9thode descendante","text":"<p>On cherche (\\(E_1\\), \\(E_2\\)), partition \u00e9quilibr\u00e9e de \\(E\\) La remarque \\(2\\) du slide pr\u00e9c\u00e9dent sugg\u00e8re de travailler avec</p> <ul> <li>la demi-somme des \u00e9l\u00e9ments de \\(E\\) et</li> <li>l\u2019ensemble \\(E_1\\) (puisqu\u2019on trouve  alors \\(E_2\\) facilement).</li> </ul> <p>Agorithme r\u00e9cursif : On g\u00e8re un ensemble \\(E\\) et la demi-somme \\(S/2\\) des \u00e9l\u00e9ments de \\(E\\). On cherche \u00e0 construire \\(E_1\\). Prendre \\(e \u2208 E\\) et calculer la distance \\(|S(E_1) \u2212 S|\\) dans \\(2\\) cas :  </p> <ul> <li>\\(\\color{red}{\\text{En mettant }e\\text{ dans }E_1}\\). Cela revient \u00e0 ajouter \\(e\\) \u00e0 la solution au probl\u00e8me  lorsque \\(E = E \\backslash \\{e\\}\\) et \\(S' = S/2 \u2212 e\\)</li> <li>\\(\\color{red}{\\text{En ne mettant pas }e\\text{ dans }E_1}\\). On calcule la solution au probl\u00e8me lorsque \\(E \\backslash \\{e\\}\\) et \\(S/2\\) est inchang\u00e9.  </li> </ul> <p>Choisir la meilleure des \\(2\\) options : celle qui am\u00e9liore la distance de la  somme des \u00e9l\u00e9ments de \\(E_1\\) \u00e0 la demi-somme \\(S/2\\).</p> <p>Exercice</p> <p>Les multi-ensemble de nombres sont impl\u00e9ment\u00e9s par des listes. 1. Ecrire une fonction <code>partition : int list -&gt; int list</code> qui  renvoie un ensemble \\(A \u2282 E\\) telle que \\(|S(A) \u2212 S/2|\\) soit minimal. On ne cherche pas \u00e0 m\u00e9moriser les r\u00e9sultats interm\u00e9diaires. 2. Estimer la complexit\u00e9 (on peut se contenter de la minorer) en fonction de \\(|E|\\).  </p> <p>Correction</p> <p><pre><code>let sum = List.fold_left (+) 0;;\nlet rec _part e s =\n    match e with\n    | [] | [_] -&gt; e\n    | x::q -&gt; \n        let p1, p2 = _part q (s-x), _part q s in\n        let s1 = x + sum p1 and s2 = sum p2 in\n        if abs (s1 -s) &lt; abs (s2 -s) then x::p1\n        else p2;;\nlet partition_brut e =\n    let s = sum e in\n    _part e (s/2);;\n</code></pre> \\(C(n) &gt;= 2\\times C(n-1) + n-1 &gt;= 2\\times(n-1)\\newline \\text{ Donc la complexit\u00e9 est exponentielle !}\\)</p>"},{"location":"Algorithmique/prodgyn/#methode-ascendante-avec-tableau-de-bouleen","title":"M\u00e9thode ascendante avec tableau de boul\u00e9en","text":"<p>\\(E = \\{e_0, . . . , e_{n\u22121}\\}\\), multi-ensemble de nombres entiers positifs, \\(S = \\sum_{e \\in E} e\\) et \\(|E| = n\\).  </p> <ul> <li>On construit une matrice de boul\u00e9ens \\(T\\) de taille \\((n + 1) \u00d7 (S + 1)\\) </li> <li>On fait en sorte que le coefficient \\(T_{i,j}, (i \u2265 0, j \u2265 0)\\) soit vrai si et seulement si il existe un sous-ensemble de \\(\\{e_k | k \u2264 i \u2212 1\\}\\) dont la somme des \u00e9l\u00e9ments vaut \\(j\\).  </li> <li>On cherche une relation de r\u00e9currence qui construit \\(T_{i,j}\\) connaissant les \\(T_{i',j'}\\) pour \\((i', j') &lt; (i, j)\\) au sens lexicographique.  </li> </ul> <p>\\(E = \\{e_0 , . . . , e_{n\u22121} \\}\\), multi-ensemble de nombres entiers positifs \\((|E | = n)\\). - Ligne \\(0\\) : Pour \\(k \u2265 0\\), \\(T_{0,k}\\) d\u00e9signe la possibilit\u00e9 pour que la somme  des \u00e9l\u00e9ments de l\u2019ensemble \\(\\{e_k | k \u2264 0 \u2212 1\\} = \u2205\\) vale \\(k\\). Ainsi \\(T_{0,k}\\) est faux sauf si \\(k = 0\\). - Pour \\(i \u2265 0\\), \\(T_{i+1, j}\\) est vrai si et seulement si il existe un sous-ensemble  de \\(\\{e, . . . , e_i \\}\\) dont la somme des \u00e9l\u00e9ments vaut \\(j\\). Ceci se d\u00e9compose en :     - Ou bien il existe un sous-ensemble de \\(\\{e, . . . , e_{i-1} \\}\\) dont la somme des  \u00e9l\u00e9ments vaut j. Ceci est \u00e9quivalent \u00e0 \"\\(T_{i,j}\\text{ est vrai }\\)\".     - Ou bien, il existe un sous-ensemble de\\(\\{e, . . . , e_{i-1} \\}\\) dont la somme des  \u00e9l\u00e9ments vaut j \u2212 \\(e_i\\) (chose impossible si \\(j &lt; e_i\\) ).      Ceci est \u00e9quivalent \u00e0  \"\\(T_{i,j\u2212e_i}\\text{ est vrai }\\)\" lorsque \\(j \u2265 e_i\\) . - Relation de r\u00e9currence : pour \\(i \u2265 1, j \u2265 0\\), \\(T_{i+1,j}\\) est \u00e9quivalent \u00e0 :  \\(\\color{red}{T_{i,j}\\text{ ou } (j \u2265 e_i\\text{ et }T_{i,j\u2212e_i})}\\)</p>"},{"location":"Algorithmique/prodgyn/#code-construction-du-tableau-de-bouleens","title":"Code : construction du tableau de boul\u00e9ens","text":"<p>Exercice</p> <p>Ecrire la fonction <code>tableau : int array -&gt; bool array array * int</code> telle que <code>tableau e</code> renvoie le tuple \\((T, m)\\) o\u00f9 \\(T\\) est d\u00e9crit au transparent pr\u00e9c\u00e9dent et \\(m\\) est la plus grande somme d\u2019\u00e9l\u00e9ments de \\(E\\) plus petite que \\(S/2\\). \u00c9valuer la complexit\u00e9 de votre fonction.  </p> <p>Correction (\u00e0 priori \u00e7a fonctionnne)</p> <pre><code>let sum = Array.fold_left (+) 0;;\nlet tableau e =\nlet n = Array.length e in\nlet s = sum e in\nlet t = Array.make_matrix (n+1) (s/2+1) false in\nt.(0).(0) &lt;- true;\nfor i = 1 to n do\n    for j =0 to s/2 do\n    t.(i).(j) &lt;-\n        t.(i-1).(j) ||\n        (j &gt;= e.(i-1) &amp;&amp; t.(i-1).(j-e.(i-1)));  \n    done;\ndone;\nlet m = ref (s/2) in\nwhile not t.(n).(!m) do\n    decr m;\ndone;\nt, !m;;\n</code></pre>"},{"location":"Algorithmique/prodgyn/#construction-de-la-partition-equilibree","title":"Construction de la partition \u00e9quilibr\u00e9e","text":"<p>Une fois trouv\u00e9s le tableau de boul\u00e9ens \\(T\\) et la somme \\(m\\), on construit \\(E_1\\)  r\u00e9cursivement en lui ajoutant ou pas l\u2019\u00e9l\u00e9ment courant. On part de \\(T_{n,m}\\) (qui est Vrai) et \\(E_1 = \u2205\\). On parcourt une suite \\((T_{i,m_i})_{i=n,n-1,...1}\\) de coe\ufb03cients avec \\(m_i\\) \\(\u2193\\) et \\(m_n = m\\). C\u2019est donc une suite dont les indices sont positifs et d\u00e9croissants  strictement au sens lexicographique, ce qui assure la terminaison de la r\u00e9cursion. </p> <p>Invariant \"\\(T_{i,m_i} \\text{ est vrai}\\)\". Crit\u00e8re de d\u00e9placement dans la matrice :  </p> <ul> <li>Si \\(T_{i\u22121,m_i}\\) est vrai, alors on peut trouver un sous-ensemble de  \\(\\{e, . . . , e_{i\u22122}\\}\\) qui a pour somme \\(m_i\\) . Donc \\(E_1\\) peut ne pas contenir  \\(e_{i\u22121}\\) : il reste inchang\u00e9.  </li> <li>Sinon c\u2019est que \\(T_{i\u22121,m_i\u2212e_i\u22121}\\) est vrai. On peut trouver un sous-ensemble  de \\(\\{e, . . . , e_{i\u22122}\\}\\) qui a pour somme \\(m \u2212 e_{i\u22121}\\). On ajoute donc \\(e_{i\u22121}\\) \u00e0 \\(E_1\\).  </li> </ul> <p>Exercice</p> <p>Ecrire la fonction <code>partitition : int array -&gt; int array</code> telle que <code>partitition e</code> renvoie sous forme de tableau l\u2019ensemble \\(E_1\\). Donner sa complexit\u00e9.</p> <p>Correction donn\u00e9 par Mat\u00e9o</p> <pre><code>let partitition e =\nlet n = Array.length e in\nlet t,m = tableau e in\nlet rec _part i s acc=\n    match i with\n    0 -&gt; acc\n    | _ -&gt; if t.(i-1).(s) then _part (i-1) s acc\n    else\n        (*c'est que t.(i-1).(s - e.(i-1)) = true *)\n        _part (i-1) (s - e.(i-1)) (e.(i-1) :: acc)\nin _part n m [];;\n;;\n</code></pre>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/","title":"Complexit\u00e9 moyenne et amortie","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li> <p>Wikipedia (Analyse amortie)</p> </li> <li> <p>\"Option informatique MPSI - MP/MP*\" Roger MANSUY (Vuibert)</p> </li> <li> <p>\"Algorithmique - 3\u00e8me \u00e9dition Cours avec 957 exercices et 158 probl\u00e8mes\" Thomas H. Cormen, Charles Leiserson, Ronald Rivest, Cli\ufb00ord Stein (Dunod)</p> </li> <li> <p>\"Informatique - MP2I/MPI - CPGE 1re et 2e ann\u00e9es\" Balabonski Thibaut, Conchon Sylvain, Filli\u00e2tre Jean-Christophe, Nguyen Kim, Sartre Laurent (ellipse)</p> </li> </ul>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#tri-rapide","title":"Tri rapide","text":"<p>Dans le tri rapide, on s\u00e9pare l'entr\u00e9e en deux listes en comparant \u00e0 un \u00e9l\u00e9ment pivot, on les trie s\u00e9par\u00e9ment et on les fusionne par concat\u00e9nation.</p> <ul> <li> <p>Dans le tri rapide, la fonction de division est d\u00e9licate et celle de fusion triviale. C'est le contraire pour le tri fusion.</p> </li> <li> <p>On donne une version pour les listes. On peut en donner une version en place pour des tableaux.</p> </li> <li> <p>Mis au point en 1960 par Tony Hoare, alors \u00e9tudiant en visite \u00e0 l'universit\u00e9 d'Etat de Moscou.</p> </li> <li> <p>Poss\u00e8de une variante Quick select pour le calcul du k-i\u00e8me \u00e9l\u00e9ment d'une liste sans proc\u00e9der au tri pr\u00e9alable (application : calcul de la m\u00e9diane).</p> </li> </ul>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#partition","title":"Partition","text":"<pre><code>let rec partition l p = match l with\n| []   -&gt; [] ,[]\n| t::q -&gt; let (l1,l2) = partition q p in\n    if t &lt;= p then (t::l1,l2) else (l1,t::l2);;\n</code></pre>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#terminaison","title":"Terminaison","text":"<p>Les cas de bases terminent, l'appel interne se fait avec une liste strictement plus courte que la liste initiale et il n'y a pas de boucle ou d'appel \u00e0 une fonction qui ne termine pas.</p> <p>C'est tout bon !</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#complexite-temporelle","title":"Complexit\u00e9 temporelle","text":"<p>dans tous les cas de la forme \\(C_{n} = C_{n} - 1 + 1\\) pour une liste de taille n. Lin\u00e9aire.</p> <p>Montrons que la fonction retourne deux listes dont la 1ere contient tous les \u00e9l\u00e9ments de l plus petits que le pivot, les \u00e9l\u00e9ments strictement plus grands \u00e9tant dans la seconde.</p> <p>Cas de base : OK de fa\u00e7on \u00e9vidente</p> <p>Supposons que partition q p partitionne correctement q en l1, l2. Supposons aussi t \u2264 p. Alors dans le tuple retourn\u00e9 :</p> <ul> <li> <p>On ajoute t \u00e0 la liste l1 des \u00e9l\u00e9ments de q plus petits que p. On obtient exactement tous les \u00e9l\u00e9ments de l plus petits que le pivot.</p> </li> <li> <p>La liste l2 est constitu\u00e9e exactement des \u00e9l\u00e9ments de q strictement plus grands que p ; donc (puisque t \u2264 p) exactement ceux ceux de l.</p> </li> <li> <p>Correction OK. Le cas t &gt; p cas est laiss\u00e9 au lecteur.</p> </li> </ul>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#tri-rapide_1","title":"Tri rapide","text":"<pre><code>let rec tri_rapide l = match l with\n    | [] -&gt; []\n    | t::q -&gt; let (l1,l2) = partition q t in\n        (tri_rapide l1)@(t::(tri_rapide l2));;\n</code></pre>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#terminaison_1","title":"Terminaison","text":"<p>Variant |l|.</p> <ul> <li> <p>Le cas de base termine (envoie de la liste vide).</p> </li> <li> <p>L'appel \u00e0 partition termine (d\u00e9j\u00e0 vu).</p> </li> <li> <p>Seulement deux appels internes, tous deux e\ufb00ectu\u00e9s avec des listes de taille strictement inf\u00e9rieure \u00e0 |l| (puisque |l1| + |l2| = |l| \u2212 1).</p> </li> <li> <p>Terminaison OK.</p> </li> </ul>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#correction","title":"Correction","text":"<p>Cas de base : OK.</p> <p>Supposons que les deux appels internes retournent une version tri\u00e9e de l1 et de l2 .</p> <ul> <li> <p>Par correction de partition : l1 contient les \u00e9l\u00e9ments de q plus petits ou \u00e9gaux au pivot et l2 les \u00e9l\u00e9ments strictement plus grands.</p> </li> <li> <p>La concat\u00e9nation retourn\u00e9e</p> </li> <li>est tri\u00e9e : d'abords les \u00e9l\u00e9ments plus petits que le pivot     rang\u00e9s dans l'ordre, puis le pivot, puis les \u00e9l\u00e9ments plus     grands que le pivot rang\u00e9s dans l'ordre.</li> <li>contient exactement tous les \u00e9l\u00e9ments de q (puisque la r\u00e9union     de l1 et l2 les contient) plus l'\u00e9l\u00e9ment manquant t .</li> <li>La concat\u00e9nation est la version tri\u00e9e de l .</li> </ul> <p>H\u00e9r\u00e9dit\u00e9 OK</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#tri-rapide-complexite-en-nombre-de-comparaisons","title":"Tri rapide : complexit\u00e9 en nombre de comparaisons","text":""},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#cas-ou-lune-des-listes-est-toujours-vide","title":"Cas o\u00f9 l'une des listes est toujours vide","text":"<p>Supposons que l'une des listes retourn\u00e9e par partition soit vide \u00e0 chaque fois (cela se produit par exemple si la liste est d\u00e9j\u00e0 tri\u00e9e).</p> <p>On d\u00e9signe par Tn la complexit\u00e9 temporelle en nombre de compraisons pour une liste tri\u00e9e de taille n.</p> <ul> <li> <p>Alors Tn v\u00e9ri\ufb01e une relation de la forme Tn = Tn\u22121 + n \u2212 1. (n \u2212 1 : nombre de comparaisons dans partition ).</p> </li> <li> <p>Complexit\u00e9 en somme des premiers entiers soit O(n2).</p> </li> </ul> <p>On montre dans la suite que ce cas est bien le pire, c'est \u00e0 dire que la complexit\u00e9 Cn en nombre de comparaisons est la pire si le pivot est \u00e0 une extr\u00e9mit\u00e9 et donc que Cn = Tn.</p> <p>Hypoth\u00e8se de r\u00e9currence selon n\u00a0(= HR(n) ):\\(\\forall q \\leq n\\)\u00a0:\\ \u2192 \\(T_{q}\\) est la pire complexit\u00e9\\ \u2192 \\(\\forall k \\in \\{ 1,\\ldots,n\\},T_{k - 1} + T_{n - k} + n\u20131 \\leq T_{n}\\) (avec \u00e9galit\u00e9 si k=1)</p> <ul> <li> <p>Cas de base n = 1\u00a0: \\(T\u2080 = 0 = T\u2081,k \\in \\{ 1\\} \\text{ alors }T_{1 - 1} + T_{1 - 1} + 1\u20131 = 0 \\leq T\u2081\\) et T\u2081 est la pire complexit\u00e9.</p> </li> <li> <p>Si HR(n) est v\u00e9rifi\u00e9e. Soit \\(k \\in \\{ 1,\\ldots,n + 1\\}\\)</p> \\[\\begin{align} T_{k - 1} + \\textcolor{red}{T_{n + 1\u2013k}} + n &amp;\\underset{\\text{def. de T}}{=}T_{k - 1} + \\textcolor{red}{T_{n - k} + (n - k)} + n\u20131 + 1\\\\ &amp;\\underset{\\text{HR(n)}}{\\leq}T_{n} + (n\u2013k + 1) \\leq T_{n} + n \\\\ &amp; = T_{n + 1}  \\end{align} \\] <p>ce qu'on veut.</p> </li> <li> <p>Si \\(C_{n + 1}\\) d\u00e9signe la pire complexit\u00e9 (la PIIIIIIIRE), soit k la position r\u00e9alisant le pire. On a </p> </li> </ul> \\[C_{n + 1} = C_{k - 1} + C_{n + 1 - k} + n\\underset{HR(n)}{\\leq}T_{k - 1} + T_{n + 1 - k} + n \\leq T_{n + 1}\\] <p>Donc \\(T_{n + 1}\\) est pire que le PIIIIIIIREEEEEE</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#complexite-moyenne-du-tri-rapide","title":"Complexit\u00e9 moyenne du tri rapide","text":"<p>La complexit\u00e9 moyenne C (n) du tri rapide pour une liste de taille n est la moyenne des complexit\u00e9s pour les di\ufb00\u00e9rentes positions du pivot.</p> <p>Elle v\u00e9ri\ufb01e (si la position \ufb01nale du pivot est \u00e9quiprobable) :</p> \\[\\begin{align}C(n) &amp;= \\frac{1}{n} \\sum_{k=0}^{n-1}(C(k)+C(n-k-1)+n-1)\\\\     &amp;=n-1+\\frac{1}{n}\\sum_{k=0}^{n-1}(C(k) + C(n-k-1)) \\end{align}     \\] <p>On constate que chaque terme appara\u00eet deux fois.</p> <p>Alors \\(C(n) = n - 1 + \\frac{2}{n}\\sum_{k = 0}^{n - 1}C(k)\\) d'o\u00f9 \\(nC(n) = 2\\sum_{k = 0}^{n - 1}C(k) + n(n - 1)\\) et donc ainsi\u00a0:</p> \\[ \\begin{align} nC(n) - (n-1)C(n-1) &amp;\\underbrace =_\\text{def} \\textcolor{red}{2\\sum_{k=0}^{n-1}C(k)}+n(n-1)-(n-1)C(n-1) \\nonumber\\\\     &amp;= \\textcolor{red}{2C(n-1)+2\\sum_{k=0}^{n-2}C(k) + (n-1)(n-2)}- (n-1)(n-2) +n(n-1) - (n-1)C(n-1) \\nonumber\\\\     &amp;= 2C(n-1) +\\textcolor{red}{(n-1)C(n-1)}-(n-1)(n-2) + n(n-1)-(n-1)C(n-1) \\nonumber\\\\     &amp;= 2C(n-1)+n(n-1)-(n-1)(n-2) \\nonumber\\\\     &amp;\\Rightarrow nC(n)-(n-1)C(n-1) = 2(n-1) \\nonumber \\end{align} \\] <p>Il vient ainsi</p> <p>\\(\\frac{C(n)}{n + 1}\u2013\\frac{C(n - 1)}{n} = \\frac{2(n - 1)}{n(n + 1)} = \\frac{4}{n + 1}\u2013\\frac{2}{n}\\) (d\u00e9composition en \u00e9l\u00e9ments simples)</p> <p>Par t\u00e9lescopage, et puisque C(0) = 0\u00a0:</p> <p>\\(\\begin{matrix} \\frac{C(n)}{n + 1}\u2013\\frac{C(0)}{1} = \\frac{C(n)}{n + 1} \\\\  = 4\\sum_{k = 1}^{n}\\frac{1}{k + 1}\u20132\\sum_{k = 1}^{n}\\frac{1}{k} \\\\  = 4\\sum_{k = 2}^{n + 1}\\frac{1}{k} - 2\\sum_{k = 1}^{n}\\frac{1}{k} \\\\  = 2\\sum_{k = 2}^{n}\\frac{1}{k} + \\frac{4}{n + 1} - 2 \\\\  = 2\\sum_{k = 1}^{n}\\frac{1}{k} + \\frac{4}{n + 1}\u20134 \\leq 2\\underset{\\sim \\ln(n)}{\\overset{\\sum_{k = 1}^{n}\\frac{1}{k}}{\\underbrace{}}} + \\underset{O\\left( \\frac{1}{n} \\right)}{\\overset{\\frac{4}{n + 1}}{\\underbrace{}}} \\\\ \\end{matrix}\\)</p> <p>Sachant que \\(\\sum_{k = 1}^{n}\\frac{1}{k} = \\ln n + \\gamma + O\\left( \\frac{1}{n} \\right)\\) o\u00f9 \u03b3 est la constante d'Euler (\\(\\gamma \\simeq 0,577\\)) alors\u00a0:</p> \\[\\frac{C(n)}{n+1} = (2 \\ln n + 2\\gamma + O(\\frac{1}{n}))+\\frac{4}{n+1}-4=2\\ln n +2\\gamma + O(\\frac{1}{n}) -4\\] <p>Donc \\(C(n) = O\\left( n\\log n \\right)\\).</p> <p>On peut minorer de la m\u00eame fa\u00e7on, donc \\(C_{n} = \\Theta\\left( n\\log n \\right)\\)</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#complexite-amortie","title":"Complexit\u00e9 amortie","text":""},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#presentation","title":"Pr\u00e9sentation","text":"<p>L'analyse amortie est une m\u00e9thode d'\u00e9valuation de la complexit\u00e9 temporelle des op\u00e9rations sur une structure de donn\u00e9es (tableaux, piles, \ufb01les, arbres...).</p> <p>Elle consiste principalement \u00e0 majorer le co\u00fbt cumul\u00e9 d'une suite d'op\u00e9rations pour attribuer \u00e0 chaque op\u00e9ration la moyenne de cette majoration, en prenant en compte le fait que les cas chers surviennent rarement et isol\u00e9ment et compensent les cas bon march\u00e9.</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#exemple-du-compteur-binaire","title":"Exemple du compteur binaire","text":"<p>On veut repr\u00e9senter, pour un entier n, tous les tableaux possibles de boul\u00e9ens de longueur n.</p> <p>Un tel tableau t peut \u00eatre vu comme la repr\u00e9sentation binaire d'en entier positif sur n bits. Il y en a 2n \u2212 1. On choisit la version little endian (bit de poids faible en t[0]), donc 1 s'\u00e9crit</p> 1 0 0 0 <p>Pour avoir tous les tableaux, on part du tableau enti\u00e8rement nul et on lui applique it\u00e9rativement un incr\u00e9ment de 1 (donc 2n fois) :</p> <pre><code>void incr(bool c[], int n){\n    int i = 0;\n    while(i&lt;n &amp;&amp; c[i]==1){ //propagation de la retenue\n        c [i] = 0 ;\n        i++;\n    }\n    if (i&lt;n) c[i] = 1 ;\n}\n</code></pre> <p>Nous voulons mesurer la complexit\u00e9 de cette fonction.</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#analyse-grossiere","title":"Analyse grossi\u00e8re","text":"<p>Pour un tableau de taille n.</p> <p>La complexit\u00e9 d\u00e9pend du nombre de tour dans la boucle while.</p> <p>Meileur cas : si t[0]==0 , alors pas de passage dans la boucle, deux acc\u00e8s seulement (en lecture puis \u00e9criture).</p> <p>Pire cas : tous les bits \u00e0 1. Pour chacun des n passages, un acc\u00e8s en lecture puis un en \u00e9criture. 2n acc\u00e8s .</p> <p>Dans le pire cas, la complexit\u00e9 est en O(n) pour un tableau.</p> <p>Majorer le co\u00fbt des 2n appels \u00e0 incr : n2n.</p> <p>C'est trop impr\u00e9cis car passer n fois dans la boucle arrive exceptionnellement.</p> <p>Exemple</p> Num\u00e9ro Param\u00e8tre Nombre de tours 0 0000 . . . 0 0 1 1000 . . . 0 1 2 0100 . . . 0 0 3 1100 . . . 0 2 4 0010 . . . 0 0 5 1010 . . . 0 1 6 0110 . . . 0 0 7 1110 . . . 0 3 8 0001 . . . 0 0 9 1001 . . . 0 1 10 0101 . . . 0 0 11 1101 . . . 0 2 12 0011 . . . 0 0 13 1011 . . . 0 1 14 0111 . . . 0 0 15 1111 . . . 0 4 <p>Total : 14 passages dans while</p> <p>Sur 16 appels cons\u00e9cutifs \u00e0 incr :</p> <ul> <li> <p>Un appel sur 2 : 0 tour de boucle ;</p> </li> <li> <p>Un appel sur 4 : 1 tours de boucle ;</p> </li> <li> <p>Un appel sur 8 : 2 tours de boucle ;</p> </li> <li> <p>Un appel sur 16 : 3 tours de boucle ;</p> </li> </ul>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#cadre-detude-de-complexite-amortie","title":"Cadre d'\u00e9tude de complexit\u00e9 amortie","text":"<p>On e\ufb00ectue une \u00e9tude de complexit\u00e9 amortie pour des algorithmes qui</p> <ul> <li> <p>ont une faible complexit\u00e9 pour de nombreuses entr\u00e9es ;</p> </li> <li> <p>sont co\u00fbteux pour certaines entr\u00e9es (peu nombreuses en proportion) ;</p> </li> <li> <p>v\u00e9ri\ufb01ent que dans toute s\u00e9quence d'appel \u00e0 l'algorithme, les entr\u00e9es co\u00fbteuses interviennent assez rarement pour que le co\u00fbt moyen reste faible.</p> </li> </ul>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#differentes-methodes","title":"Di\ufb00\u00e9rentes m\u00e9thodes","text":"<p>Il y a 3 m\u00e9thodes usuelles d'analyse amortie : la m\u00e9thode de l'agr\u00e9gat, la m\u00e9thode comptable et la m\u00e9thode du potentiel (seule \u00e9tudi\u00e9e ici).</p> <p>M\u00e9thode du potentiel : A chaque entr\u00e9e possible x, on associe un nombre positif ou nul \u03c6(x) dit potentiel. Il repr\u00e9sente un co\u00fbt latent dans l'entr\u00e9e mais pas encore r\u00e9alis\u00e9.</p> <p>Une s\u00e9quence d'un algorithme ayant de bonnes propri\u00e9t\u00e9s de complexit\u00e9 amortie alterne entre :</p> <ul> <li> <p>de (nombreuses) op\u00e9rations de faible co\u00fbt faisant monter progressivement le potentiel,</p> </li> <li> <p>et de (peu nombreuses) op\u00e9rations de co\u00fbt \u00e9lev\u00e9 faisant diminuer</p> </li> <li> <p>brusquement le potentiel.</p> </li> </ul> <p>Dans l'exemple du compteur binaire, le potentiel est le nombre de 1 dans le tableau.</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#cout-amorti-dune-operation","title":"Co\u00fbt amorti d'une op\u00e9ration","text":"<p>D\u00e9finition : Co\u00fbt amorti</p> <p>Soit une op\u00e9ration op dont l'ex\u00e9cution produit une sortie \\(x_{s}\\) \u00e0 partir d'une entr\u00e9e \\(x_{e}\\). Le co\u00fbt r\u00e9el C de op est la complexit\u00e9 temporelle de son ex\u00e9cution. Son co\u00fbt amorti A et la somme du co\u00fbt r\u00e9el et de la variation de potentiel : \\(A = C + \\varphi(x_s) - \\varphi(x_e)\\).</p> <p>Dans cette d\u00e9\ufb01nition, les entr\u00e9es et sorties repr\u00e9sentent au sens large ce qui est donn\u00e9 \u00e0 l'algorithme (param\u00e8tres, \u00e9tat de la m\u00e9moire au d\u00e9but de l'appel) et ce qu'il produit (r\u00e9sultats renvoy\u00e9s, \u00e9tat de la m\u00e9moire en sortie).</p> <p>Une s\u00e9quence d'op\u00e9rations cons\u00e9cutives est une suite d'appels \u00e0 un algorithme de sorte que chaque sortie d'un appel soit l'entr\u00e9e du suivant.</p> <p>On montre que le co\u00fbt r\u00e9el est toujours inf\u00e9rieur au co\u00fbt amorti.</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#theoreme-damortissement","title":"Th\u00e9or\u00e8me d'amortissement","text":"<p>Th\u00e9or\u00e8me</p> <p>Soit une suite de n op\u00e9rations x0\u2212\u2192x1\u2212\u2192x2 . . .\u2212\u2192xn \u00e0 partir d'une entr\u00e9e x0 telle que \u03c6(x0) = 0. En notant Ci le co\u00fbt r\u00e9el de l'op\u00e9ration xi et Ai son co\u00fbt amorti, on a la relation d'amortissement suivante :</p> \\[\\sum_{i=1}^{n}C_i \\leq \\sum_{i=1}^{n}A_i\\] <p>Preuve</p> \\[ \\sum_{i=1}^{n}A_i = \\sum_{i=1}^{n}C_i + \\sum_{i=1}^{n}(\\varphi(x_i) - \\varphi(x_{i-1})) = \\sum_{i=1}^{n}C_i + \\varphi(x_n) - \\varphi(x_0) \\geq \\sum_{i=1}^{n}C_i\\]"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#corollaire-au-th-damortissement","title":"Corollaire au th. d'amortissement","text":"<p>Corollaire</p> <p>Avec les notations du th. d'amortissement, si le co\u00fbt amorti est born\u00e9 par une constante k, alors la complexit\u00e9 moyenne au sein d'une s\u00e9quence arbitraire de n op\u00e9rations est born\u00e9e par k.</p> <p>D\u00e9monstration</p> \\[\\sum_{i=1}^n C_i \\leq \\sum_{i=1}^n A_i \\leq \\sum_{i=1}^n k = kn\\]"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#retour-au-compteur-binaire","title":"Retour au compteur binaire","text":"<p>Complexit\u00e9 en nombre d'acc\u00e8s aux cases du tableau :</p> <p>Soit k le nombre de 1 cons\u00e9cutifs depuis la position 0. L'appel incr(c,n) r\u00e9alise :</p> <ul> <li> <p>2(k + 1) acc\u00e8s m\u00e9moire si k \\&lt; n.</p> </li> <li> <p>2n acc\u00e8s si k = n.</p> </li> </ul> <p>On d\u00e9\ufb01nit le potentiel \u03c6(c) du tableau c par</p> \\[\\Phi(c) = 2 \\times \\underset{|c|_{1}}{\\overset{(\\text{nombre de 1 dans c})}{\\underbrace{}}}\\] <p>Si \\(c_{i}\\) poss\u00e8de k bits 1 cons\u00e9cutifs depuis la position 0, alors soit k' tel que \\(|c|_{1} = k + k\u2019\\). Une application de incr, transforme \\(c_{i}\\) en \\(c_{i + 1}\\).</p> <p>Le delta de potentiel est</p> \\[ \\phi(c_{i+1}) - \\phi(c_i) = \\] <ul> <li>\\(2(k\u2019 + 1) - 2(k + k\u2019) = 2 - 2k \\text{ si k diff\u00e9rent de n}\\)</li> <li>\\(-2k \\text{ si k = n}\\)</li> </ul> <p>Complexit\u00e9 en nombre d'acc\u00e8s aux cases du tableau :</p> \\[ A_{i+1} = C_{i+1} + \\phi(c_{i+1}) - \\phi(c_i) =\\] <ul> <li>2(k + 1) + 2 - 2k = 4 si k &lt; n.</li> <li>2k - 2k = si k = n.</li> </ul> <p>On en d\u00e9duit que la complexit\u00e9 amortie est born\u00e9e par 4. D'apr\u00e8s le corollaire du th. d'amortissement, toute s\u00e9quence d'incr\u00e9mentation commen\u00e7ant en 00 . . . 0 r\u00e9alise moins de 4 op\u00e9rations d'acc\u00e8s au tableau par appel \u00e0 incr .</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9%20moyenne%20et%20amortie/#complexite-moyen-vs-complexite-amortie","title":"Complexit\u00e9 moyen vs complexit\u00e9 amortie","text":"<p>La complexit\u00e9 moyenne est une moyenne (donc calcul\u00e9e avec des probabilit\u00e9s)</p> <p>Elle donne :</p> <ul> <li>Une complexit\u00e9 suppos\u00e9e repr\u00e9sentative du plus grand nombre     d'entr\u00e9e ;</li> <li>Sans apporter aucune garantie sur la complexit\u00e9 d'une op\u00e9ration     particuli\u00e8re ni m\u00eame sur une s\u00e9quence particuli\u00e8re d'op\u00e9rations.</li> </ul> <p>La complexit\u00e9 amortie apporte une borne garantie \u00e0 toute s\u00e9quence d'op\u00e9ration.</p> <ul> <li>Son calcul n'utilise pas de probabilit\u00e9 ;</li> <li>Elle ne dit rien de la complexit\u00e9 d'une op\u00e9ration particuli\u00e8re     mais assure un \u00e9quilibre \u00e0 toute s\u00e9quence d'op\u00e9rations.</li> </ul>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9/","title":"Complexit\u00e9","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9/#definitions","title":"D\u00e9finitions","text":"<p>D\u00e9finition : Analyse de la complexit\u00e9</p> <p>\u00c9tude formelle de la quantit\u00e9 de ressources (de temps, d'espace m\u00e9moire, ...) n\u00e9cessaire \u00e0 l'ex\u00e9cution de cet algorithme</p> <ul> <li>En temps il s'agit de savoir si une fonction termine dans un temps raisonnable</li> <li>En m\u00e9moire il s'agit de d\u00e9terminer si la fonction dispose bien toutes les ressources physiques pour s'ex\u00e9cuter.</li> </ul> <p>D\u00e9finition utiles</p> <p>On note \\(D_{n}\\) l'ensemble des donn\u00e9es de taille n et C(d) la complexit\u00e9 d'un certain programme pour une donn\u00e9e d.</p> <ul> <li>\\(C_{\\max}(n) = \\max_{d \\in D_{n}}C(d)\\) Est la complexit\u00e9 dans le pire cas</li> <li>\\(C_{\\min}(n) = \\min_{d \\in D_{n}}C(d)\\) Est la complexit\u00e9 dans le meilleur des cas</li> <li>\\(C_{moy}(n) = \\sum_{d \\in D_{n}}^{}P(d)C(d)\\) Est la complexit\u00e9 en moyenne avec P la loi de proba associ\u00e9e \u00e0 l'apparition des donn\u00e9es de taille n</li> </ul> <p>D\u00e9finition: Domination / Ordre de grandeur</p> <p>U est domin\u00e9e par V s'il existe \\(\\lambda \\in {\\mathbb{R}} + etN \\in {\\mathbb{N}}\\) tels que pour tout \\(n \\in {\\mathbb{N}}\\), si n \u2265 N alors \\(u_{n} \\leq \\lambda v_{n}\\). On le note \\(u_{n} = O\\left( v_{n} \\right)\\).  On dit aussi que V domine U.</p> <p>U et V sont de m\u00eame ordre de grandeur si U domine V et V domine U (i.e. \\(u_{n} = O\\left( v_{n} \\right)etv_{n} = O\\left( u_{n} \\right)\\)). On le note \\(u_{n} = \\Theta\\left( v_{n} \\right)\\) (\u00ab\u00a0\\(u_{n}\\) est en grand th\u00eata de \\(v_{n}\\)\u00bb)</p> <p>D\u00e9finition : \u00c9quivalence / Grand Om\u00e9ga</p> <p>On \u00e9crit \\(u_{n} = \\Omega\\left( v_{n} \\right)\\) (\u00ab\u00a0\\(u_{n}\\)est en grand Om\u00e9ga de \\(v_{n}\\)\u00a0\u00bb) s'il existe\\(\\lambda \\in {\\mathbb{R}} +\\) et \\(N \\in {\\mathbb{N}}\\) tels que pour tout \\(n \\in {\\mathbb{N}}\\), si n \u2265 N alors \\(u_{n} \\geq \\lambda v_{n}\\).</p> <p>Observons que dans ce cas \\(\\frac{1}{\\lambda}u_{n} \\geq v_{n}\\) et donc \\(u_{n} = \\Omega\\left( v_{n} \\right) \\Leftrightarrow v_{n} = O\\left( u_{n} \\right)\\).</p> <p>U et V sont dites \u00e9quivalentes si et seulement si \\(v_{n} \\neq 0\\) \u00e0 partir d'un certain rang et \\(\\frac{u_{n}}{v_{n}}\\) tend vers 1 en \\(n \\rightarrow + \\infty\\). Cette d\u00e9finition (qui nous suffit) est plus restrictive que celle du cours du maths.</p> <p>Remarque</p> <p>Si \\(u_{n} \\sim v_{n}\\) alors \\(u_{n} = \\Theta\\left( v_{n} \\right)\\).</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9/#ordres-de-grandeur","title":"Ordres de grandeur","text":"<p>Pour une donn\u00e9e de taille n</p> D\u00e9nomination D\u00e9finition Exemple Logarithmique \\(O(\\log n)\\) Recherche dans une liste tri\u00e9e (pire cas) Lin\u00e9aire \\(O(n)\\) Inversion d'une liste Quasi-lin\u00e9aire \\(O(n\\log n)\\) Tri fusion Polynomiale \\(O(n\u00b2)\\) Tri par insertion (pire cas) Polynomiale \\(O(n^k)\\) pour k&gt;1 Produit matriciel na\u00eff en \\(O\\left( n^{3} \\right)\\) Exponentielle \\(O(\\alpha^n)\\) pour \\(\\alpha &gt;1\\) Satisfiabilit\u00e9 d'une formule (pire cas)"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9/#quoi-compter","title":"Quoi compter\u00a0?","text":"<p>La plupart du temps, on se contente de donner une majoration \u00ab \u00e0 constante multiplicative pr\u00e8s \u00bb du temps de calcul. On ne compte pas pr\u00e9cis\u00e9ment le nombre d'op\u00e9rations \u00e9l\u00e9mentaires (est-ce bien malin de mettre dans le m\u00eame sac un acc\u00e8s \u00e0 un \u00e9l\u00e9ment de tableau et une addition binaire ?).</p> <p>Dans ce cas, la notation en O(f(n)) (si n est l'entr\u00e9e) nous suffit. Parfois, on s'int\u00e9resse \u00e0 une op\u00e9ration sp\u00e9cifique, et dans ce cas un d\u00e9compte pr\u00e9cis est favoris\u00e9.</p> <p>Exemple</p> <ul> <li>Le nombre d'\u00e9changes d'\u00e9l\u00e9ments dans un tri de tableau</li> <li>Le nombre de produits de flottants dans un produit matriciel \u00ab\u00a0optimis\u00e9\u00a0\u00bb</li> </ul>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9/#operations-elementaires","title":"Op\u00e9rations \u00e9l\u00e9mentaires","text":"<p>Pour mesurer le temps d'ex\u00e9cution d'un programme, on utilise le nombre d'op\u00e9rations \u00e9l\u00e9mentaires \u00e0 effectuer plut\u00f4t qu'une dur\u00e9e en seconde. En g\u00e9n\u00e9ral on en cherche une majoration, plus rarement une minoration.</p> <p>La raison est que le m\u00eame programme s'ex\u00e9cutera plus ou moins vite selon la machine mais que le nombre d'op\u00e9rations ne changera pas.</p> <p>D\u00e9finitions: Op\u00e9rations \u00e9l\u00e9mentaires</p> <p>Les op\u00e9rations suivantes sont dites \u00e9l\u00e9mentaires (non exhaustif)</p> <ul> <li>Op\u00e9rations sur les nombres\u00a0: + - * /\u00a0%</li> <li>Affectation, Afficher, Retourner\u00a0: a = ...\u00a0; return ...</li> <li>Acc\u00e8s\u00a0: t[i]</li> <li>Lib\u00e9ration\u00a0: free(t)</li> <li>Comparaisons de nombres\u00a0: ... &lt; ...\u00a0; ... == ...</li> </ul> <p>La complexit\u00e9 temporelle d'un programme au pire : nombre max. d'op. elem. \u00e0 effectuer (en fonction de la taille du ou des arguments).</p> <p>Exemple introductif</p> <pre><code>void diviseurs1(int n){\n    for(int i=2; i&lt;n; i++){\n        if(n%i == 0){\n            printf(\"%d;\", i);\n        }\n    }\n}\n</code></pre> <p>Ce programme effectue exactement n - 2 calculs de restes de divisions euclidiennes, n - 2 comparaisons et un nombre d'affichages inf\u00e9rieur ou \u00e9gal \u00e0 n - 2. Au maximum, il y a donc 5(n - 2) + 1 op\u00e9rations \u00e9l\u00e9mentaires plus les n - 2 incr\u00e9mentations de i + comparaisons. L'ordre de grandeur est donc donn\u00e9 par une application affine : On dit que \u00ab la complexit\u00e9 temporelle est en O(n)</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9/#taille-du-probleme","title":"Taille du probl\u00e8me","text":"<p>D\u00e9terminer le temps d'ex\u00e9cution en fonction de la taille du probl\u00e8me</p> <p>Exemples</p> <ul> <li>Recherche de diviseur de n. La taille est n, le temps d'ex\u00e9cution est proportionnel \u00e0 n</li> <li>Manipulation d'une liste. Taille du probl\u00e8me : nombre d'\u00e9l\u00e9ments.</li> <li>Traitement d'un fichier texte. Taille du probl\u00e8me : nombre de caract\u00e8res.</li> <li>Addition de matrices \\(n\\times m\\). Taille du probl\u00e8me le couple (n, m) ou nm</li> </ul> <p>Souvent la taille du probl\u00e8me est indiqu\u00e9e dans l'\u00e9nonc\u00e9.</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9/#conditions","title":"Conditions","text":"<p>Si on a une condition if ... else ... on prend le nombre d'op\u00e9rations \u00e9l\u00e9mentaires maximum entre les deux + celui du test effectu\u00e9 dans la condition</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9/#boucles-for","title":"Boucles For","text":"<p>Pour la boucle <code>for(i = 0\u00a0; i &lt; m\u00a0; i++) p();</code> son co\u00fbt est m fois le co\u00fbt de l'instruction p si ce co\u00fbt ne d\u00e9pend pas de i (condition sur la parit\u00e9 de i par exemple)\u00a0:</p> \\[1 + m \\times \\left( C(p) + 2 \\right) = O\\left( m \\times C(p) \\right)\\] <p>avec +2 pour l'incr\u00e9mentation et la comparaison \u00e0 chaque tour de boucle.</p> <p>Si le co\u00fbt d\u00e9pend de i, on a comme co\u00fbt total de la boucle une somme des co\u00fbts du corps de la boucle pour chaque valeur de i + l'incr\u00e9mentation\u00a0:</p> \\[\\sum_{i = 0}^{m - 1}\\left( C\\left( p_{i} \\right) + 2 \\right) = O\\left( \\sum_{i = 0}^{m - 1}C\\left( p_{i} \\right) \\right)\\] <p>Ainsi le co\u00fbt d'une boucle for ne peut pas \u00eatre inf\u00e9rieur \u00e0 \\(O(m)\\) car il y a toujours l'incr\u00e9mentation du compteur sauf si dans le corps de la boucle se trouver une instruction d'arr\u00eat ou de retour.</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9/#boucles-while","title":"Boucles While","text":"<p>Le nombre d'it\u00e9ration n'est pas connu \u00e0 l'avance \u00e0 priori. On \u00e9value donc le nombre d'it\u00e9ration et on proc\u00e8de comme pour la boucle for en y ajoutant la complexit\u00e9 du test.</p> <p>Exemple de complexit\u00e9 temporelle (Ocaml)</p> <p>On essaye d'\u00e9tablir une relation de r\u00e9currence entre C(n) (la complexit\u00e9 pour une donn\u00e9e de taille n) et la complexit\u00e9 des appels internes plus la complexit\u00e9 hors appel r\u00e9cursif. Complexit\u00e9 C (n) en nombre de multiplications pour\u00a0:</p> <pre><code>let rec fact n =\n    if n&lt;2 then 1 else n * fact (n-1);;\n</code></pre> <ul> <li>C(0) = C(1) = 0</li> <li>C(n) = C(n - 1) + 3 : une multiplication seulement dans le cas n\u22652 avec la comparaison n&lt;2 et le n-1.</li> </ul> <p>Alors on a\u00a0:</p> \\[C(n) = C(n - 1) + 3 = \\left( C(n - 2) + 3 \\right) + 3 = \\ldots = C(1) + 3(n\u20131) = O(n)\\] <p>En g\u00e9n\u00e9ral, on ne s'encombre pas avec une trop grande pr\u00e9cision. On fixe C(0) = C(1) = 1 et, si les op\u00e9rations hors appels r\u00e9cursifs sont en O(f(n)), on prend le repr\u00e9sentant le plus simple (ex : n pour O(n))</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9/#meilleur-des-cas","title":"Meilleur des cas","text":"<p>La complexit\u00e9 au pire est la plus significative, mais il peut \u00eatre utile de conna\u00eetre aussi la complexit\u00e9 dans le meilleur des cas, pour avoir une borne inf\u00e9rieure du temps d'ex\u00e9cution d'un algorithme. En particulier, si la complexit\u00e9 dans le meilleur et dans le pire des cas sont du m\u00eame ordre, cela signifie que le temps d'ex\u00e9cution de l'algorithme est relativement ind\u00e9pendant des donn\u00e9es et ne d\u00e9pend que de la taille du probl\u00e8me.</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9/#complexite-en-moyenne","title":"Complexit\u00e9 en moyenne","text":"<p>Parler de moyenne des temps d'ex\u00e9cution n'a de sens que si l'on a une id\u00e9e de la fr\u00e9quence des diff\u00e9rentes donn\u00e9es possibles pour un m\u00eame probl\u00e8me de taille n. Les calculs de complexit\u00e9 moyenne recourent aux notions d\u00e9finies en math\u00e9matiques dans le cadre de la th\u00e9orie des probabilit\u00e9s et des statistiques. La complexit\u00e9 en moyenne n'est, en g\u00e9n\u00e9ral, pas attendue dans les sujets mais on en verra quelques exemples.</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9/#complexite-en-espace","title":"Complexit\u00e9 en espace","text":"<p>On appelle complexit\u00e9 en espace d'un algorithme la place n\u00e9cessaire en m\u00e9moire pour faire fonctionner cet algorithme en dehors des param\u00e8tres du programme. Elle s'exprime \u00e9galement sous la forme d'un \\(O(f(n))\\) o\u00f9 n est la taille du probl\u00e8me.</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9/#complexite-en-memoire","title":"Complexit\u00e9 en m\u00e9moire","text":"<p>En g\u00e9n\u00e9ral, il suffit de faire le total des tailles en m\u00e9moire des diff\u00e9rentes variables utilis\u00e9es. La seule vraie exception \u00e0 la r\u00e8gle est le cas des fonctions r\u00e9cursives, qui cachent souvent une complexit\u00e9 en espace \u00e9lev\u00e9e du fait de l'empilement des stack frames. La r\u00e9cursion terminale est une bonne solution \u00e0 ce probl\u00e8me. La complexit\u00e9 spatiale est n\u00e9cessairement toujours inf\u00e9rieure (ou \u00e9gale) \u00e0 la complexit\u00e9 temporelle d'un algorithme : on suppose qu'une op\u00e9ration d'\u00e9criture en m\u00e9moire prend un temps \\(O(1)\\), donc \u00e9crire une m\u00e9moire de taille M prend un temps \\(O(M)\\).</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9/#diviser-pour-regner","title":"Diviser pour r\u00e9gner","text":"<p>M\u00e9thode</p> <p>On d\u00e9coupe la donn\u00e9e que l'on doit traiter en deux parties de tailles proches (ou + que 2 parts). On r\u00e9sout le probl\u00e8me sur les parties plus petites On combine les r\u00e9sultats obtenus pour construire le r\u00e9sultat correspondant \u00e0 la donn\u00e9e initiale</p> <p>Une donn\u00e9e de taille n est d\u00e9coup\u00e9e en deux autres donn\u00e9es de tailles \\(\\left\\lfloor \\frac{n}{2} \\right\\rfloor et\\left\\lceil \\frac{n}{2} \\right\\rceil\\). La complexit\u00e9 ob\u00e9it alors \u00e0 une relation de la forme\u00a0:</p> \\[C_{n} = {aC}_{\\left\\lfloor \\frac{n}{2} \\right\\rfloor} + {bC}_{\\left\\lceil \\frac{n}{2} \\right\\rceil} + f(n)\\] <p>Avec \\((a,b) \\neq (0,0)\\) sont des constantes associ\u00e9es au probl\u00e8me et f(n) correspond au co\u00fbt total du partage et de la recombinaison. Cette r\u00e9currence est dite de type \u00ab\u00a0diviser pour r\u00e9gner\u00a0\u00bb</p> <p>Proposition</p> <p>Soient a,b deux entiers tels que \\(ab \\neq 0\\) et f, g deux fonctions croissantes de m\u00eame ordre de grandeur. Alors les suites (\\(u_{n}\\)) et (\\(v_{n}\\)) telles que \\(u_{0} = v_{0}\\) et pour tout \\(n \\in {\\mathbb{N}} \\ast\\)\u00a0:</p> <p>\\(\\begin{matrix} u_{n} = {au}_{\\left\\lfloor \\frac{n}{2} \\right\\rfloor} + {bu}_{\\left\\lceil \\frac{n}{2} \\right\\rceil} + f(n) \\\\ v_{n} = {av}_{\\left\\lfloor \\frac{n}{2} \\right\\rfloor} + {bv}_{\\left\\lceil \\frac{n}{1} \\right\\rceil} + g(n) \\\\ \\end{matrix}\\)sont du m\u00eame ordre de grandeur.</p> <p>Cette proposition (admise) justifie qu'on remplace le dernier terme par un terme plus simple de m\u00eame ordre de grandeur (donc 1 pour O(1), n\u00b2 pour O(n\u00b2) etc.)</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9/#croissance-de-la-complexite","title":"Croissance de la complexit\u00e9","text":"<p>On consid\u00e8re \\(u_{n} = f(n) + u_{\\left\\lfloor \\frac{n}{2} \\right\\rfloor} + u_{\\left\\lceil \\frac{n}{2} \\right\\rceil}\\) avec f croissante. On pose aussi u\u2080 = u\u2081 = 1 parce que \u00e7a nous arrange et qu'on \u00e9tudie un comportement asymptotique.</p> <p>Preuve</p> <p>On montre que \\(u_{n - 1} \\leq u_{n}\\) pour n \u2265 1</p> <ul> <li> <p>Initialisation     1 = u\u2080 \u2264 u\u2081 = 1</p> </li> <li> <p>H\u00e9r\u00e9dit\u00e9     Si \\(u_{k} \\geq u_{q}\\) pour tout n &gt; k \u2265 q.     \\(u_{n} = f(n) + u_{\\left\\lfloor \\frac{n}{2} \\right\\rfloor} + u_{\\left\\lceil \\frac{n}{2} \\right\\rceil}\\text{ et }u_{n - 1} = f(n - 1) + u_{\\left\\lfloor \\frac{n - 1}{2} \\right\\rfloor} + u_{\\left\\lceil \\frac{n - 1}{2} \\right\\rceil}\\)</p> <p>Or les fonctions parties enti\u00e8res sont croissantes donc \\(u_{\\left\\lfloor \\frac{n - 1}{2} \\right\\rfloor} \\leq u_{\\left\\lfloor \\frac{n}{2} \\right\\rfloor}etu_{\\left\\lceil \\frac{n - 1}{2} \\right\\rceil} \\leq u_{\\left\\lceil \\frac{n}{2} \\right\\rceil}\\) par HR et f(n-1) \u2264 f(n) par hypoth\u00e8se. Donc \\(u_{n} \\geq u_{n - 1}\\)</p> </li> <li> <p>Conclusion \\(\\forall n \\in {\\mathbb{N}},\\left( u_{n} \\right)\\).</p> </li> </ul> <p>En pratique, on refait pas cette preuve, et on admet que la complexit\u00e9 est croissante avec la taille des donn\u00e9es.</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9/#dichotomie-3","title":"Dichotomie &lt;3","text":"<pre><code>let dicho v x = (*Chercher x dans le tableau tri\u00e9 v*)\n    let rec cherche_entre a b =\n        if a = b then (x=v.(a))\n        else\n            let m = (a+b)/2 in\n            if v.(m) = x then true\n            else if v.(m) &gt; x then cherche_entre a (m-1)\n            else cherche_entre (m+1) b\n    in\n    cherche_entre 0 (Array.length v - 1);;\n</code></pre> <p>A chaque \u00e9tape, la zone de recherche est divis\u00e9e par 2 (au moins) (on note n//2 la division euclidienne par 2)</p> <p>[x\u00a0; x\u00a0; x\u00a0; x\u00a0; x]\u00a0: Tableau de taille impaire n</p> <p>Les deux sous-tableaux sont donc de taille n//2 (du d\u00e9but jusque l'\u00e9l\u00e9ment m exclus et de l'\u00e9l\u00e9ment m exclus jusque la fin du tableau)</p> <p>[x\u00a0; x\u00a0; x\u00a0; x]\u00a0: Tableau de taille paire n</p> <p>Au moins un sous tableau est de taille n//2</p> <p>Hors les appels r\u00e9cursifs, il y a un nombre born\u00e9 d'autres op\u00e9rations, toutes en O(1). Le co\u00fbt total \u00e0 chaque tour hors appels r\u00e9cursifs est donc O(1). Pour un tableau de taille n, la complexit\u00e9 au pire est du type \\(C_{n} = C_{\\left\\lfloor \\frac{n}{2} \\right\\rfloor} + O(1);\\) simplifi\u00e9 en \\(C_{n} = C_{\\left\\lfloor \\frac{n}{2} \\right\\rfloor} + 1\\) (On cherche dans le plus grand sous tableau pour que \u00e7a soit dans le pire cas)</p> <p>Si \\(n = 2^{p}\\)alors \\(C_{2^{p}} = C_{2^{p - 1}} + 1 = C_{2^{p - 2}} + 1 + 1 = \\ldots = C_{2\u2070} + p = \\Theta\\left( \\log \u2082n \\right)\\)</p> <p>Sinon pour un n quelconque, \\(2^{\\left\\lfloor \\log \u2082n \\right\\rfloor} \\leq n &lt; 2^{\\left\\lfloor \\log \u2082n \\right\\rfloor + 1}\\) et comme la complexit\u00e9 est croissante avec la taille du tableau, il vient \\(C_{n} \\leq C_{2^{\\left\\lfloor \\log \u2082n \\right\\rfloor + 1}} = O\\left( \\left\\lfloor \\log \u2082n \\right\\rfloor + 1 \\right)\\)ainsi on a \\(C_{n} = O\\left( \\log \u2082n \\right)\\). Idem pour la minoration\u00a0: \\(C_{n} \\geq C_{2^{\\left\\lfloor \\log \u2082n \\right\\rfloor}} = \\Omega\\left( \\left\\lfloor \\log \u2082n \\right\\rfloor + 1 \\right)\\)</p> <p>Conclusion, \\(C_{n} = \\Theta\\left( \\log \u2082n \\right)\\)</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9/#tri-fusion-3","title":"Tri fusion &lt;3","text":"<p>Pour raison de commodit\u00e9, on \u00e9tudie la complexit\u00e9 d'une version non r\u00e9cursive terminale du tri fusion. On donne n\u00e9anmoins une version r\u00e9cursive terminale apr\u00e8s cette \u00e9tude.</p> <p>On veut trier une liste. On s\u00e9pare l'entr\u00e9e en deux listes/deux tableaux (approximativement) de m\u00eame longueur, qu'on trie s\u00e9par\u00e9ment, puis on fusionne les deux r\u00e9sultats en comparant \u00e0 chaque fois les plus petits \u00e9l\u00e9ments.</p> <pre><code>let rec divise l = (*S\u00e9pare l en deux listes de m\u00eame taille*)\n    match l with\n    | [] -&gt; ([], [])\n    | [x] -&gt; ([x], [])\n    | x::y::q -&gt; let (l1, l2) = divise q in (x::l1, y::l2);;\n</code></pre> <p>Complexit\u00e9 temporelle est de la forme \\(C_{n} = C_{n - 2} + 1\\). Ainsi pour n = 2k\u00a0:</p> <p>On trouve de m\u00eame avec \\(C_{2k + 1} = C\u2081 + k\\) pour n = 2k+1.</p> <p>Comme dans les 2 hypoth\u00e8ses de parit\u00e9, \\(k = \\left\\lfloor \\frac{n}{2} \\right\\rfloor\\), on obtient \\(C_{n} = \\Theta(n)\\)</p> <p>On fusionne maintenant deux listes tri\u00e9es (par ordre croissant) en ajoutant prioritairement le plus petit \u00e9l\u00e9ment des deux listes.</p> <pre><code>let rec fusion l1 l2 = (*Fusionne deux listes tri\u00e9es*)\n    match (l1, l2) with\n    | ([], l) -&gt; l\n    | (l, []) -&gt; l\n    | (x::q, y::r) -&gt;\n        if x &lt; y then x::(fusion q l1)\n        else y::(fusion (l2) r);;\n</code></pre> <p>En dehors des appels r\u00e9cursifs, les op\u00e9rations sont en O(1) et en nombre born\u00e9. La complexit\u00e9 d\u00e9pend donc de la fa\u00e7on dont sont r\u00e9parties les donn\u00e9es dans les listes. Meilleur cas en \\(O\\left( \\text{min(|l1|,\\ |l2|)} \\right)\\)\u00a0: lorsque tous les \u00e9l\u00e9ments de la liste la plus courte sont plus petits que ceux de la plus longue.</p> <p>Pour \u00e9viter un raisonnement qui tiendrait compte de la r\u00e9partition des donn\u00e9es, on peut \u00e9tudier la complexit\u00e9 d'une fonction manifestement plus co\u00fbteuse\u00a0mais plus simple \u00e0 \u00e9tudier :</p> <pre><code>let rec fusion_couteuse l1 l2 = (*Fusionne deux listes tri\u00e9es*)\n    match (l1, l2) with\n    | ([], []) -&gt; []\n    | (x::q, []) | ([], x::q) -&gt; x::(fusion_couteuse q [])\n    | (x::q, y::r) -&gt;\n        if x &lt; y then x::(fusion_couteuse q l2)\n        else y::(fusion_couteuse l1 r);;\n</code></pre> <p>La complexit\u00e9 d\u00e9pend seulement de la somme des tailles des listes. En notant n, m les tailles de l1, l2 on obtient la relation suivante\u00a0: C(n+m) = C(n+m-1) + O(1) et C(0 + 0) = 1</p> <p>On \u00e9tudie donc C(n+m) = C(n+m-1)+1. Il s'agit d'une suite arithm\u00e9tique. On a donc C(n+m) = O(n+m) Ainsi la complexit\u00e9 de fusion est aussi en O(n+m)</p> <p>Et donc pour finir le tri fusion\u00a0:</p> <pre><code>let rec tri_fusion l =\n    match l with\n    | [] -&gt; [] \n    | [e] -&gt; [e]\n    | _ -&gt;\n        let (l1, l2) = divise l in\n        fusion (tri_fusion l1) (tri_fusion l2);;\n</code></pre> <p>On note n la longueur de l, La division est en \u0398(n). La fusion s'applique aux deux moiti\u00e9s tri\u00e9es\u00a0; elle a ici un co\u00fbt en \u0398(n) (m\u00eame au meilleur cas). La complexit\u00e9 ob\u00e9it \u00e0 une relation diviser-pour-r\u00e9gner de la forme</p> \\[C_n = C_{\\lfloor\\frac{n}{2}\\rfloor} + C_{\\lceil\\frac{n}{2}\\rceil} + \\Theta(n) \\text{ simplifi\u00e9 en } C_n = C_{\\lfloor\\frac{n}{2}\\rfloor} + C_{\\lceil\\frac{n}{2}\\rceil} + n\\] <p>Si \\(n = 2^{k}\\) alors \\(\\left\\lfloor \\frac{n}{2} \\right\\rfloor = \\left\\lceil \\frac{n}{2} \\right\\rceil\\)(et k = log\u2082 n)\u00a0:</p> \\[C_{2^k} = 2^k + C_{2^{k-1}} = 2\\times 2^k + 2\\times 2C_{2^{k-2}} = \\ldots = k2^k + 2^kC_1 = \\Theta(n\\log_2 n)\\] <p>En g\u00e9n\u00e9ral, \\(2^{\\left\\lfloor \\log \u2082n \\right\\rfloor} \\leq n &lt; 2^{\\left\\lfloor \\log \u2082n \\right\\rfloor + 1}\\) comme la complexit\u00e9 est croissante\u00a0:</p> \\[C_n \\leq C_{2^{\\left\\lfloor \\log_2 n \\right\\rfloor + 1}} = O((\\lfloor \\log_2 n \\rfloor + 1)2^{\\lfloor \\log_2 n \\rfloor + 1}) = O(n\\log_2 n)\\] <p>Idem pour une minoration\u00a0: \\(C_n = \u0398(n \\log_2 n)\\)</p>"},{"location":"Analyse%20d%27algorithmes/Complexit%C3%A9/#supplements-a-graille","title":"Suppl\u00e9ments \u00e0 graille","text":"<p>Le tri d'un tableau est dit en place si l'algorithme travaille directement sur le tableau en entr\u00e9e et n'utilise pas de tableau auxiliaire. Un tri est stable s'il conserve les positions relatives des \u00e9l\u00e9ments de m\u00eame valeur.</p> <p>Il existe une version du tri fusion pour les tableaux. Une version d\u00e9licate (mais possible) existe pour un maintien en place mais non stable.</p> <p>Le tri fusion est en O(n log n) au pire, au meilleur et en moyenne. On ne peut pas faire mieux en moyenne (voir cours sur les arbres) pour un tri par comparaison (algorithmes de tri proc\u00e9dant par comparaisons successives entre \u00e9l\u00e9ments).</p>"},{"location":"Arbres/ABR/","title":"Arbre Binaire de Recherche","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>\"Option informatique MPSI, MP/MP*\", Roger Mansuy, paru chez Vuibert.</li> <li>Wikip\u00e9dia : Tas, Tas binaires, Tri par tas</li> <li>OpenClassRoom Arbres binaires de recherche</li> </ul> <p>D\u00e9finition: Arbre binaire de recherche</p> <p>Binary search trees (BST)</p> <p>Un arbre binaire de recherche (ABR) sur un type totalement ordonn\u00e9 est un arbre binaire tel que pour tout n\u0153ud interne, les \u00e9tiquettes apparaissant dans le sous-arbre gauche (resp.droit) sont strictement\u00b9 inf\u00e9rieures (resp. sup\u00e9rieures) \u00e0 celle la racine. 1. Selon la mise en \u0153uvre de l\u2019ABR, on pourra interdire ou non des cl\u00e9s de valeur \u00e9gale.</p> <p>Figure \u2013 Un ABR</p> <pre><code>graph TB; \n    A((8))--&gt;B((3))\n    A--&gt;C((10))\n    B--&gt;D((1))\n    B--&gt;E((6))\n    C--&gt;H(( ))\n    C--&gt;G((14))\n    E--&gt;J((4))\n    E--&gt;K((7))\n    G--&gt;O((13))\n    G--&gt;F(( ))\n    style H display:none\n    style F display:none</code></pre> <p>Les \u00e9tiquettes de gauche ont des valeurs plus petites que celle de la racine, celle de droite sont plus grandes</p>"},{"location":"Arbres/ABR/#arbre-binaire-de-recherche_1","title":"Arbre binaire de recherche","text":""},{"location":"Arbres/ABR/#dsf","title":"DSF","text":"<p>On peut facilement r\u00e9cup\u00e9rer les cl\u00e9s d\u2019un arbre binaire de recherche dans l\u2019ordre croissant en r\u00e9alisant un parcours en profondeur infixe. Contre exemple:</p> <p>Figure \u2013 Un arbre binaire qui n\u2019est pas un ABR <pre><code>graph TB; \n    A((6))--&gt;B((4))\n    A--&gt;C((5))</code></pre></p> <p>Figure \u2013 Un ABR pour repr\u00e9senter <code>[4,5,6]</code> <pre><code>graph TB; \n    A((6))--&gt;B((5))\n    A --&gt;Z(( ))\n    B--&gt;C((4))\n    B--&gt;W(( ))\n    style Z display:none\n    style W display:none</code></pre> Figure \u2013 Un ABR \u00e9quilibr\u00e9 pour repr\u00e9senter <code>[4,5,6]</code> <pre><code>graph TB; \n    A((5))--&gt;B((6))\n    A--&gt;C((4))</code></pre> Figure \u2013 Un ABR pour repr\u00e9senter <code>[4,5,6]</code></p> <pre><code>graph TB; \n    A --&gt;Z(( ))\n    A((4))--&gt;B((5))\n    B--&gt;W(( ))\n    B--&gt;C((6))\n    style Z display:none\n    style W display:none</code></pre> <p>Passage liste ordonn\u00e9e/ABR A une liste ordonn\u00e9e correspondent plusieurs ABR.</p>"},{"location":"Arbres/ABR/#type-de-donnees","title":"Type de donn\u00e9es","text":"<p>Nous utiliserons le type suivant:</p> Type Arbre<pre><code>type 'a tree =\n    |Nil\n    |N of 'a * 'a tree * 'a tree;;\n</code></pre> <ul> <li>Une feuille est impl\u00e9ment\u00e9e par <code>N(x, Nil, Nil)</code>,</li> <li>une n\u0153ud d\u2019arit\u00e9 1 par <code>N(x, t, Nil)</code> ou <code>N(x, Nil, t)</code> avec x et t de type convenable.</li> <li>Une telle structure mod\u00e9lise les arbres binaires, pas seulement les ABR. C\u2019est lors de la cr\u00e9ation d\u2019un arbre que nous ferons attention \u00e0 ce qu\u2019il respecte la contrainte d\u2019ordre.</li> </ul>"},{"location":"Arbres/ABR/#primitives","title":"Primitives","text":"<ul> <li>Une fonction de cr\u00e9ation d\u2019un ABR \u00e0 partir d\u2019une liste.</li> <li>Une fonction d\u2019insertion d\u2019une valeur dans un ABR.</li> <li>Une fonction de recherche d\u2019une valeur dans un arbre.</li> <li>Une fonction de suppression d\u2019une valeur dans un arbre.</li> </ul> Ins\u00e9rer sous une feuille<pre><code>let rec insert x t = match t with\n    | Nil -&gt; N (x , Nil , Nil )\n    | N (y ,g , d ) when x &lt; y -&gt; N (y , insert x g , d )\n    | N (y , g , d ) when x &gt;y -&gt; N (y ,g , insert x d )\n    | _ -&gt; t (* pas de doublon *) ;; (* le laisser sinon Warning 8. *)\n</code></pre> <ul> <li>Le choix qui est fait ici est celui d\u2019un ABR sans \u00e9tiquettes de m\u00eames valeurs (pas de doublon).</li> <li>On ins\u00e8re la nouvelle valeur sous une feuille.</li> <li>On pourrait aussi ins\u00e9rer x \u00e0 la racine:<ul> <li>\"Couper\" l\u2019arbre en deux sous-ABR g , d contenant respectivement les \u00e9l\u00e9ments plus petits et plus grands que x.</li> <li>construire l\u2019arbre <code>N(x, g, d)</code></li> </ul> </li> </ul>"},{"location":"Arbres/ABR/#complexite-de-linsertion-sous-une-feuille","title":"Complexit\u00e9 de l\u2019insertion sous une feuille","text":"<p>Description informelle pour un arbre de hauteur \\(h\\) \u00e0 \\(n\\) n\u0153uds.</p> <ul> <li>On descend le long d\u2019une branche jusqu\u2019\u00e0 la feuille.</li> <li>Il y a \\(O(h)\\) pour cette descente. Pour chaque n\u0153ud interne, les op\u00e9rations hors appel r\u00e9cursif sont \u00e0 co\u00fbt constant.</li> <li>Dans le cas d\u2019arr\u00eat, le co\u00fbt est \u00e9galement constant.</li> <li>Donc complexit\u00e9 en \\(O(h)\\).</li> <li>On comprend l\u2019int\u00e9r\u00eat de \"contr\u00f4ler\" \\(h\\). En pratique, on essaye de conserver \\(h \\leq C \\log(n)\\) pour une certaine constante. Si on arrive \u00e0 maintenir cette contrainte au fil des insertions, on obtient un arbre \u00e9quilibr\u00e9.</li> </ul>"},{"location":"Arbres/ABR/#creation","title":"Cr\u00e9ation","text":"Cr\u00e9er un ABR \u00e0 partir d\u2019une liste<pre><code>let rec create l = match l with\n    | [] -&gt; Nil\n    | e :: q -&gt; insert e ( create q ) ;;\n\n(*test*)\ncreate ([1;4;2;3]) ;;\n</code></pre> <p>Figure \u2013 ABR obtenu par <code>create([1;4;2;3]);;</code></p> <pre><code>graph TB; \n    A((3))--&gt;B((2))\n    A--&gt;C((4))\n    B--&gt;D((1))\n    B--&gt;E(( ))\n    style E display:none</code></pre>"},{"location":"Arbres/ABR/#liste-triee","title":"Liste tri\u00e9e","text":"<p>Si la liste est d\u00e9j\u00e0 tri\u00e9e, on obtient une liste cha\u00een\u00e9e.</p> <p>Figure \u2013 ABR obtenu par <code>create([1;4;2;3]);;</code></p> <pre><code>graph TB; \n    A((4))--&gt;B((3))\n    A --&gt;Z(( ))\n    B--&gt;C((2))\n    B--&gt;W(( ))\n    C--&gt;D((1))\n    C--&gt;R(( ))\n    style Z display:none\n    style W display:none\n    style R display:none</code></pre>"},{"location":"Arbres/ABR/#complexite-de-la-creation","title":"Complexit\u00e9 de la cr\u00e9ation","text":"<ul> <li>Si la liste est d\u00e9j\u00e0 tri\u00e9e, l\u2019ABR n\u2019a qu\u2019une branche.</li> <li>Pour une liste tri\u00e9e de longueur \\(n\\), la complexit\u00e9 v\u00e9rifie une relation de la forme</li> </ul> \\[ \\begin{align} c_n &amp;= c_{n\u22121} + \\underbrace{n}_{\\text{cpx insertion}} + \\underbrace{c}_{\\text{autres op\u00e9ration}}  \\\\ &amp;= c_{n\u22122} + 2c + n +  \\underbrace{n-1}_{\\text{cpx insertion}} \\\\  &amp;= \\text{ ...} \\\\ &amp;= c_0 + nc + \\sum\\limits_{k=1}^{n}k \\\\ &amp;= \\theta(n\u00b2) \\end{align}\\] <ul> <li>On voit l\u2019int\u00e9r\u00eat de maintenir un certain \u00e9quilibre dans l\u2019arbre au moment des insertions.</li> </ul>"},{"location":"Arbres/ABR/#utilite-de-lequilibrage-des-arbres","title":"Utilit\u00e9 de l\u2019\u00e9quilibrage des arbres","text":"<ul> <li>A priori, cela ne semble pas si grave d\u2019avoir une liste cha\u00een\u00e9e et non un bel arbre binaire \"\u00e9quilibr\u00e9\".</li> <li>Mais les op\u00e9rations sur les ABR (insertion, suppression, recherche) ont une complexit\u00e9 au pire qui d\u00e9pend de la hauteur...</li> <li>... d\u2019o\u00f9 l\u2019id\u00e9e qu\u2019il faut limiter la hauteur des arbres lors de l\u2019insertion.</li> <li>C\u2019est le principe du r\u00e9\u00e9quilibrage des ABR.</li> </ul>"},{"location":"Arbres/ABR/#creation-dun-arbre-equilibre-a-partir-dune-liste","title":"Cr\u00e9ation d\u2019un arbre \u00e9quilibr\u00e9 \u00e0 partir d\u2019une liste","text":"<ul> <li>Un arbre A est dit \u00e9quilibr\u00e9 lorsque \\(h(A) = O(\\log_{}(|A|))\\)</li> <li>Exemple arbres AVL: pour chaque n\u0153ud, la diff\u00e9rence entre les hauteurs de ses fils (l\u2019un \u00e9ventuellement vide) est \\(0\\), \\(1\\) ou \\(\u22121\\).</li> <li>On peut \u00e9tablir que, dans un AVL de taille \\({|A| = n} \\implies {\\frac{3}{2}\\log_{2}(n+ 1) \\geq h(A)}\\) (cf TD).</li> <li>Autre exemple : arbres Rouge-Noir (cf TD).</li> <li>Dans un arbre \u00e9quilibr\u00e9, ins\u00e9rer x se fait en \\(O(\\log_{2}(n))\\) appels internes au pire plus un nombre born\u00e9 d\u2019autres op\u00e9rations en \\(\\Theta(1)\\) .</li> <li>Si on maintient le caract\u00e8re \u00e9quilibr\u00e9 (le r\u00e9\u00e9quilibrage a un co\u00fbt logarithmique -admis-), le co\u00fbt de la cr\u00e9ation \u00e0 partir d\u2019une liste est donc de l\u2019ordre de \\(\\Theta(\\sum\\limits_{k=1}^{n}\\log_{2}(k)) = \\Theta(\\log_{2}(n!)) = \\Theta(n\\log_{2}(n))\\)</li> </ul>"},{"location":"Arbres/ABR/#rechercher","title":"Rechercher","text":"<pre><code>let rec search x t = match t with\n(* cherche x dans t *)\n| Nil -&gt; false\n| N (y ,_ , _ ) when y = x - &gt; true\n| N (y ,g , _ ) when x &lt; y -&gt; search x g\n| N (y ,_ , d ) when x &gt; y -&gt; search x d\n| _ -&gt; false ;; (* le laisser sinon \u2019 this pattern - matching is not\nexhaustive . \u2019 *)\n</code></pre> <ul> <li>Si x est \u00e9gal \u00e0 la racine de t, c\u2019est bon. Sinon on cherche r\u00e9cursivementdans le sous arbre gauche lorsque x es plus petit que la racine, et \u00e0 droite sinon.</li> <li>Si x est \u00e0 la profondeur k, il y a k appels internes pour le trouver.</li> <li>Si x n\u2019est pas dans l\u2019arbre, il y a au pire \\(h(t)\\) appels internes.</li> </ul>"},{"location":"Arbres/ABR/#suppression","title":"Suppression","text":""},{"location":"Arbres/ABR/#operation-de-fusion","title":"Op\u00e9ration de fusion","text":"<p>On veut \"fusionner\" deux ABR G et D tels que les \u00e9tiquettes de G sont toutes plus petites que celles de D. Ceci afin d\u2019obtenir un ABR unique construit \u00e0 partir des n\u0153uds des deux arbres.</p> <p><pre><code>let rec merge a b = match a , b with\n(* fusion qui privil\u00e9gie l \u2019arbre gauche *)\n| Nil , t | t , Nil -&gt; t\n| N (x , ga , da ) , N (y , gb , db ) -&gt; (* on a max a &lt;= min b *)\n    N (x , ga , N (y , merge da gb , db ) ) ;; \n</code></pre> Dans cette fusion, la racine de l\u2019arbre gauche devient syst\u00e9matiquement la racine de l\u2019arbre retourn\u00e9. On aurait pu privil\u00e9gier l\u2019arbre droit. <pre><code>let a1 = N (3 , N (2 , Nil , Nil ) ,N (4 , Nil , Nil ) ) in \nlet a2 = N (30 , N(20 , Nil , Nil ) ,N (40 , Nil , Nil ) ) in\nmerge a1 a2 ;;\n\n(* Et on obtient : *)\nN (3, N (2, Nil, Nil),\n    N (30, N (4 , Nil, N (20, Nil, Nil)),\n        N (40, Nil, Nil)))\n</code></pre></p> <p></p> <p>Figure \u2013 En rouge, la fusion des deux arbres bleus</p>"},{"location":"Arbres/ABR/#correction-de-la-fusion","title":"Correction de la fusion","text":"<p>Preuve par induction</p> <p>On montre que si on fusionne deux ABR a, b tels que max a \u2264 min b, alors le nouvel arbre form\u00e9 est un ABR contenant toutes les \u00e9tiquettes de a, b.</p> <ul> <li>Cas de base : si un des deux arbres est vide, on renvoie l\u2019autre. C\u2019est un ABR par hyp. et il contient bien toutes les \u00e9tiquettes des deux arbres.</li> <li>H\u00e9r\u00e9dit\u00e9. Soient <code>a = N(x, ga, da)</code> et <code>b = N(y , gb, db)</code> non vides avec \\(\\max a \\leq \\min b\\).<ul> <li>Notre hypoth\u00e8se d\u2019induction (HI) est que la fusion d\u2019un sous-terme imm\u00e9diats de a avec un sous-terme imm\u00e9diat de b est un ABR contenant toutes les \u00e9tiquettes de ses deux sous-termes.</li> <li>La racine du nouvel arbre est x et elle est plus grande que toutes les \u00e9tiquettes de son fils gauche ga (puisque a est un ABR).</li> <li>Le fils droit est <code>d = N(y , merge(da, gb), db)</code>. Par (HI) la fusion <code>merge(da, gb)</code> est un ABR avec toutes les \u00e9tiquettes de da, gb.</li> <li>Comme y est sup\u00e9rieur aux \u00e9tiquettes de gb, elles-m\u00eames plus grandes que celles de da, il vient que y est sup\u00e9rieur aux \u00e9tiquettes de l\u2019ABR r\u00e9sultant de la fusion.</li> <li>Or y est inf\u00e9rieur aux \u00e9tiquettes de db puisque b est un ABR. Donc <code>d = N(y , merge(da, gb), db)</code> est un ABR dont toutes les \u00e9tiquettes sont aumoins plus grandes que celles de la plus petite de da. De plus il contient y et toutes les \u00e9tiquettes de da, gb, db.</li> </ul> </li> <li>Donc x est plus petit que les \u00e9tiquettes de d (qui est un ABR) et plus grand que celles de ga (qui est un ABR) donc <code>N(x, ga, d)</code> est un ABR avec toutes les \u00e9tiquettes de a, b.</li> </ul>"},{"location":"Arbres/ABR/#complexite-de-la-fusion","title":"Complexit\u00e9 de la fusion","text":"<ul> <li>Soient deux ABR g , d : Il y a au plus autant d\u2019appels internes que le minimum de hauteur des sous arbres.</li> <li>La complexit\u00e9 est en \\(\\Theta(\\min(h(g), h(d)))\\) </li> </ul> <pre><code>let rec remove x t = match t with (* on commence par chercher x dans t *) \n    | Nil -&gt; failwith \" x not found \" (* on n\u2019a pas trouv\u00e9 x *) \n    | N (y,g, d) when x &lt; y -&gt; N (y, remove x g, d) \n    | N (y,g, d) when x &gt; y -&gt; N (y, g, remove x d) (* A partir d'ici, on a trouv\u00e9x *) \n    | N (y,g, d) when y = x -&gt; merge g d (* fusion des deux sous - arbres *) \n    | _ -&gt; failwith \" ne devrait pas arriver \";;\n</code></pre> <p>Remarques</p> <p>Lorsque le n\u0153ud A d\u2019\u00e9tiquette x n\u2019a qu\u2019un fils, celui-ci prend la place de son p\u00e8re (on le \"remonte\"). Si A est une feuille, on se contente de la supprimer (la fusion met Empty \u00e0 la place de A).</p>"},{"location":"Arbres/ABR/#dictionnaire","title":"Dictionnaire","text":"<p>D\u00e9finition: Tableau associatif</p> <p>Tableau associatif (aussi appel\u00e9 dictionnaire ou table d\u2019association) : type de donn\u00e9es associant \u00e0 un ensemble de clefs un ensemble correspondant de valeurs. Chaque clef est associ\u00e9e \u00e0 une valeur unique : un dictionnaire correspond donc \u00e0 une application en math\u00e9matiques. Il peut \u00eatre vu comme une g\u00e9n\u00e9ralisation du tableau dont les indices ne serait pas n\u00e9cessairement des entiers.</p> <p>Op\u00e9rations usuellement fournies:</p> <ul> <li>ajout : association d\u2019une nouvelle valeur \u00e0 une nouvelle clef ;</li> <li>modification : association d\u2019une nouvelle valeur \u00e0 une ancienne clef ;</li> <li>suppression : suppression d\u2019une clef ;</li> <li>recherche : d\u00e9termination de la valeur associ\u00e9e \u00e0 une clef, si elle existe.</li> </ul> <p>Les dictionnaires peuvent \u00eatre impl\u00e9ment\u00e9s concr\u00e8tement par des ABR. Ce sont alors des donn\u00e9es persistantes. L\u2019ensemble des cl\u00e9s doit \u00eatre totalement ordonn\u00e9. Les \u00e9tiquettes des n\u0153uds de l\u2019ABR sont des couples (cl\u00e9s, valeurs) et le placement d\u2019un n\u0153ud dans l\u2019arbre est fait selon sa cl\u00e9 et non sur sa valeur. En OCAML, explorons 3 fa\u00e7ons de d\u00e9finir les dictionnaires.</p>"},{"location":"Arbres/ABR/#dictionnaires-par-liste-de-paires","title":"Dictionnaires par liste de paires","text":"<p>M\u00e9thode la plus simple. Persistante.</p> <pre><code>(* dictionnaires par liste de paires *)\nlet m = [ \" Sally Smart \", \" 555 -9999 \" ;\n     \" John Doe \", \" 555 -1212 \" ;\n     \" J.Random Hacker \", \" 553 -1337 \" ];;\nList.assoc \" John Doe \" m;;\n(* # - : string = \" 555 -1212 \" *)\n</code></pre>"},{"location":"Arbres/ABR/#dictionnaires-par-avl","title":"Dictionnaires par AVL","text":"<ul> <li>Les arbres AVL ont \u00e9t\u00e9 historiquement les premiers arbres binaires de recherche automatiquement \u00e9quilibr\u00e9s.</li> <li>Dans un arbre AVL, les hauteurs des deux sous-arbres d\u2019un m\u00eame n\u0153ud diff\u00e8rent au plus de un.</li> <li>La recherche, l\u2019insertion et la suppression sont toutes en \\(O(\\log_{2}(n))\\) dans le pire des cas.</li> <li>L\u2019insertion et la suppression n\u00e9cessitent d\u2019effectuer des rotations (op\u00e9rations de r\u00e9\u00e9quilibrage).</li> </ul> <p>Le nom AVL vient des deux inventeurs Georgii Adelson-Velsky et Evguenii Landis (1962).</p> <p><pre><code>(* dictionnaire applicatif r\u00e9alis\u00e9 par arbres \u00e9quilibr\u00e9s *)\n (* dictionnaire applicatif r\u00e9alis\u00e9 par arbres \u00e9quilibr\u00e9s *) \ninclude (Map.Make (String));; \nlet m = empty \n    |&gt; add \" Sally Smart \" \" 555 -9999 \" \n    |&gt; add \" John Doe \" \" 555 -1212 \" \n    |&gt; add \" J.Random Hacker \" \" 553 -1337 \";; \nfind \" John Doe \" m;; \n(* # - : string = \"555 -1212\" *) \n</code></pre> Structure persistante bas\u00e9e sur les arbres \u00e9quilibr\u00e9s. Ajout/Suppression/Recherche en temps logarithmique.</p>"},{"location":"Arbres/ABR/#dictionnaires-par-table-de-hachage","title":"Dictionnaires par table de hachage","text":"<pre><code>(* dictionnaires par table de hachage polymorphe *)\nlet m = Hashtbl.create 3;; (* taille attendue 3 , \u00e7 a peut changer *)\nHashtbl.add m \" Sally Smart \" \" 555 -9999 \" ;\nHashtbl.add m \" John Doe \" \" 555 -1212 \" ;\nHashtbl.add m \" J . Random Hacker \" \" 553 -1337 \" ;;\nHashtbl.find m \" John Doe \" ;;\n(* # - : string = \"555 -1212\" *)\n</code></pre> <p>Structure imp\u00e9rative. Modifications en place. Ajout/Suppression/Recherche en temps constant (en moyenne pour ajout, et pour la recherche, \u00e7a d\u00e9pend en fait de la fonction de hash).</p>"},{"location":"Arbres/ABR/#tas","title":"Tas","text":"<p>D\u00e9finition: Tas</p> <p>Un tas de hauteur h est un arbre binaire v\u00e9rifiant :</p> <ul> <li>Condition d\u2019ordre : les fils d\u2019un n\u0153ud ont une \u00e9tiquette inf\u00e9rieure ou \u00e9gale \u00e0 celle du p\u00e8re.</li> <li>Condition de structure: Un tas est complet gauche :<ul> <li>Tous les niveaux sont remplis sauf \u00e9ventuellement le dernier.</li> <li>Le dernier niveau (\u00e9ventuellement incomplet) est rempli sans trou enpartant de la gauche.</li> </ul> </li> </ul>"},{"location":"Arbres/ABR/#precisions-et-consequences","title":"Pr\u00e9cisions et cons\u00e9quences","text":"<ul> <li>Un arbre du type pr\u00e9c\u00e9dent est dit de type tas-max (racine=max).</li> <li>tas-min : l\u2019\u00e9tiquette du p\u00e8re est plus petite que celle des fils.</li> </ul> <p>Les branches sont toutes de longueur h ou h \u2212 1, enlever les feuilles de profondeur h donne un arbre parfait, les n\u0153uds internes de profondeur h \u2212 1 d\u2019arit\u00e9 \u2265 1 sont \u00e0 gauche des feuilles de profondeur h \u2212 1, si il y a un n\u0153ud interne de profondeur h \u2212 1 avec un seul fils, son fils est une feuille et c\u2019est le dernier n\u0153ud dans le parcours en largeur.</p> <p>Exemple</p> <p><p></p> Figure \u2013 Un tas. Si on enl\u00e8ve les feuilles de profondeur 2, l\u2019arbre est parfait</p> <p>Tous les niveaux sont remplies, sauf le dernier, lequel est partiellement rempli en commen\u00e7ant par la gauche. </p> <p>Contre-exemples</p> <p>Les arbres suivants ne sont pas des tas : <p></p> Figure \u2013 Un n\u0153ud de hauteur h \u2212 1 et d\u2019arit\u00e9 1 est \u00e0 gauche d\u2019un n\u0153ud de hauteur h \u2212 1 d\u2019arit\u00e9 2  <p></p> Figure \u2013 Un p\u00e8re a un fils d\u2019\u00e9tiquette plus grande que la sienne </p>"},{"location":"Arbres/ABR/#hauteur-dun-arbre-complet-gauche","title":"Hauteur d\u2019un arbre complet gauche","text":"<p>Soit A un arbre complet gauche \u00e0 n n\u0153uds et de hauteur p </p> <ul> <li>L\u2019avant dernier niveau (qui correspond \u00e0 un arbre parfait) est rempli. Et le dernier niveau contient au moins une feuille. </li> </ul> \\[\\begin{align} &amp;2p \u2212 1 &lt; n \u2264 \\underbrace {2^{p+1} \u2212 1}_\\text{taille min. d\u2019un arbre parfait plus gros que A} \\\\ &amp;\\Rightarrow 2p \u2264 n &lt; 2^{p+1} &amp;\\\\ &amp;\\Rightarrow p \u2264 log_2(n) &lt; p + 1 &amp;\\\\ &amp;\\lfloor \\log_2(n) \\rfloor  = p\\\\ \\end{align}\\] <p>Exemple</p> <p><p></p> Figure \u2013 Un tableau repr\u00e9sentant un tas </p> <p>Contrexemples</p> <p>Les arbres suivants ne sont pas des tas :  <p></p> Figure \u2013 Un n\u0153ud de hauteur h \u2212 1 et d\u2019arit\u00e9 1 est \u00e0 gauche d\u2019un n\u0153ud de hauteur h \u2212 1 d\u2019arit\u00e9 2  <p></p> Figure \u2013 Un p\u00e8re a un fils d\u2019\u00e9tiquette plus grande que la sienne </p>"},{"location":"Arbres/ABR/#tas-et-tableaux","title":"Tas et tableaux","text":"<p>On peut stocker un tas dans un tableau dont on n\u2019utilise pas (pour le moment) le premier \u00e9l\u00e9ment.</p> <ul> <li>La racine occupe l\u2019\u00e9l\u00e9ment d\u2019indice 1, </li> <li>Les fils du n\u0153ud d\u2019indice k (avec k &gt; 0) sont aux indices 2k et 2k + 1 (si ceux-ci ne d\u00e9passent pas la longueur du tableau).</li> <li>Le p\u00e8re du n\u0153ud d\u2019indice k est \u00e0 l\u2019indice \\(\\lfloor k/2 \\rfloor\\).</li> </ul> <p></p> <p>Figure \u2013 Relations p\u00e8re/fils dans un tableau repr\u00e9sentant un tas</p>"},{"location":"Arbres/ABR/#en-caml","title":"En CAML","text":"<pre><code>(* correspond au sch\u00e9ma pr\u00e9c\u00e9dent en OCAML *) \nlet t = [|6; 12; 9; 6; 2; 7; 5; 0; 67; 33|];;\n</code></pre> <p>Lorsqu\u2019on cr\u00e9e un tableau repr\u00e9sentant un tas :</p> <ul> <li>Il faut pr\u00e9voir la taille du tableau \u00e0 l\u2019instant initial (6 ici) et les \u00e9ventuels ajouts \u00e0 e\ufb00ectuer (en clair pr\u00e9voir plus de place que la simple taille du tableau \u00e0 l\u2019instant 0). </li> <li>Le premier \u00e9l\u00e9ment du tableau d\u00e9signe la taille du tas (qui est di\ufb00\u00e9rente de celle du tableau).</li> <li>Les \u00e9l\u00e9ments 0, 67, 33 en fin de tableau ne sont pas consid\u00e9r\u00e9s comme appartenant au tas. Ils seront remplac\u00e9s par les valeurs \u00e9ventuellement ajout\u00e9es au tas.</li> </ul>"},{"location":"Arbres/ABR/#un-probleme","title":"Un probl\u00e8me","text":"<p>Le type de la taille du tas (int) fige le type du tableau avec l\u2019impl\u00e9mentation pr\u00e9c\u00e9dente. Toutes les valeurs du tas doivent \u00eatre des entiers... </p> <pre><code>(* pour dissocier le type de la taille du tas de celui de ses \u00e9l\u00e9ments,  on peut utiliser un type enregistrement *) \ntype \u2019a myHeap =\n    { mutable length : int ; heap : \u2019a array };;\n</code></pre>"},{"location":"Arbres/ABR/#operations-sur-les-tas","title":"Op\u00e9rations sur les tas","text":"<ul> <li>Ajouter : ajout d\u2019un \u00e9l\u00e9ment dans le tas binaire en pr\u00e9servant la structure de tas. </li> <li>Retirer : retirer un \u00e9l\u00e9ment d\u2019indice donn\u00e9 et rectifier le tableau pour qu\u2019il corresponde de nouveau \u00e0 un tas. </li> <li>Construire : construction du tas binaire \u00e0 partir d\u2019un ensemble d\u2019\u00e9l\u00e9ments. </li> </ul> <p>Consid\u00e9rons que l\u2019on veuille ajouter le n\u0153ud x \u00e0 notre tas binaire : On ins\u00e8re x \u00e0 la prochaine position libre (la position libre la plus \u00e0 gauche possible sur le dernier niveau), puis on e\ufb00ectue l\u2019op\u00e9ration suivante (que l\u2019on appelle percolation vers le haut ou percolate-up) pour r\u00e9tablir si n\u00e9cessaire la propri\u00e9t\u00e9 d\u2019ordre du tas binaire : </p> <ul> <li>Tant que x n\u2019est pas la racine de l\u2019arbre et que l\u2019\u00e9tiquette de x est strictement sup\u00e9rieure \u00e0 celle du p\u00e8re, \u00e9changer les positions entre x et son p\u00e8re. </li> </ul> Exemple <p>On veut ajouter 50 dans un tas-max : <p></p> Figure \u2013 On cherche le seul emplacement possible pour pr\u00e9server la structure d\u2019arbre complet gauche</p> <p><p></p> Figure \u2013 le n\u0153ud d\u2019\u00e9tiquette 50 est plac\u00e9 provisoirement. On le compare \u00e0 son p\u00e8re (28) </p> <p><p></p> Figure \u2013 Comme 50 &gt; 28, on \u00e9change les positions de 50 et 28. Et on compare 50 avec son nouveau p\u00e8re (41)... </p> <p><p></p> Figure \u2013 Comme 50 &gt; 41, on \u00e9change les positions de 50 et 41. Et on compare 50 avec son nouveau p\u00e8re (53)... </p> <p><p></p> Figure \u2013 Comme 50 \u2264 53, il n\u2019y a rien \u00e0 faire : 50 a trouv\u00e9 sa bonne place </p>"},{"location":"Arbres/ABR/#la-fonction-auxiliaire-dechange","title":"La fonction auxiliaire d\u2019\u00e9change","text":"<pre><code>let swap i j t = (*\u00e9change deux \u00e9l\u00e9ments d\u2019un tableau*) \n    let c = t.(i) in t.(i) &lt;-t.(j) ; t.(j) &lt;-c;; \n</code></pre> <p>Complexit\u00e9 en \\(\\Theta(1)\\).</p>"},{"location":"Arbres/ABR/#la-fonction-auxiliaire-de-percolation","title":"La fonction auxiliaire de percolation","text":"<pre><code>let rec percolate_up n t = \n    (* n est l\u2019indice de l\u2019\u00e9l\u00e9ment \u00e0 percoler *)\n    if n &gt; 1 then \n        begin (* t .(n) n'est pas la racine *) \n        let m = n /2 (* indice du p\u00e8re *) \n        in if t.(m) &lt; t.(n) then \n            begin \n                swap m n t ; (*\u00e9change p\u00e8re / fils *) \n                percolate_up m t ; (* percolate_up avec m *) \n            end ;\n    end;; \n</code></pre>"},{"location":"Arbres/ABR/#complexite-de-la-percolation","title":"Complexit\u00e9 de la percolation","text":"<p>On applique cette fonction \u00e0 un tas d\u2019entiers de n n\u0153uds (repr\u00e9sent\u00e9 par un tableau) : Dans le pire des cas, l\u2019\u00e9l\u00e9ment remonte la branche la plus longue du tas : \\(\\log_2(n)\\) \u00e9tapes puisque le tas est un arbre binaire presque parfait. A chaque \u00e9tape, il y a un nombre born\u00e9 c d\u2019op\u00e9rations \u00e9l\u00e9mentaires. Au total, entre \\(\\log_2(n)\\) op\u00e9rations et \\(c\\log_2(n)\\). Complexit\u00e9 en \\(\\Theta(\\log_2(n))\\).</p>"},{"location":"Arbres/ABR/#la-fonction-dinsertion","title":"La fonction d\u2019insertion","text":""},{"location":"Arbres/ABR/#principe","title":"Principe","text":"<p>On ins\u00e8re l\u2019\u00e9l\u00e9ment apr\u00e8s le dernier \u00e9l\u00e9ment du tableau (\\(\\Theta(1)\\)) et on percole (au pire \\(\\Theta(\\log_2(n))\\)) si n est le nombre de n\u0153ud). Donc complexit\u00e9 au pire \\(\\Theta(\\log_2(n))\\):</p> <pre><code>let insert v t = \n    t.(0) &lt;- t.(0) +1; (* maj lg du tas *) \n    t.(t.(0)) &lt;- v ; (* placer v \u00e0 la derni \u00e8 re place *) \n    percolate_up (t.(0)) t;;\n</code></pre> <p></p> <p>Figure \u2013 Le tas-max de r\u00e9f\u00e9rence</p>"},{"location":"Arbres/ABR/#supprimer-un-element","title":"Supprimer un \u00e9l\u00e9ment","text":"Schema <p>On souhaite supprimer la racine du tas-max suivant :  <p></p> Figure \u2013 On remplace la racine par le dernier n\u0153ud  <p></p> Figure \u2013 On compare 20 et son fils max (41). Comme 41 &gt; 20, on \u00e9change 41 et 20 </p> <p><p></p> Figure \u2013 On compare 20 et son fils max (36). Comme 36 &gt; 20, on \u00e9change 36 et 20  <p></p> Figure \u2013 On compare 20 et son fils max (31). Comme 31 &gt; 20, on \u00e9change 31 et 20. On est alors dans un des deux cas d\u2019arr\u00eat : plus de fils ou pas de fils plus grand. Ici, 20 n\u2019a plus de fils. On a fini. </p>"},{"location":"Arbres/ABR/#principe_1","title":"Principe","text":"<p>On veut supprimer la racine. Lorsqu\u2019on supprime le dernier n\u0153ud d\u2019un tas, celui-ci reste un tas. On supprime le dernier n\u0153ud et on le met \u00e0 la place du n\u0153ud racine (la propri\u00e9t\u00e9 d\u2019ordre est perdue). On percole vers le bas (percolate-down) pour retrouver la propri\u00e9t\u00e9 d\u2019ordre. </p>"},{"location":"Arbres/ABR/#recherche-du-plus-grand-fils","title":"Recherche du plus grand fils","text":"<pre><code>let aux_max n t = (* cette fonction retourne l\u2019indice du fils le plus grand de t .(n) ; -1 si pas de fils *) \n    if 2 * n &lt; t.(0) then \n        begin (* t .(n) a deux fils *) \n            if t.(2* n) &lt; t.(2* n +1) then 2* n +1 \n            else 2* n \n        end \n    else (* moins de deux fils *) \n        begin \n            if 2 * n = t.(0) then 2 * n (* un seul fils *) \n            else -1 (* pas de fils *) \n        end;; \n</code></pre> <p>Complexit\u00e9 en \\(O(1)\\).</p>"},{"location":"Arbres/ABR/#percolate-down","title":"Percolate-down","text":"<pre><code>let rec percolate_down k t = \n    let m = aux_max k t (* m vaut -1,2 k ou 2 k +1 *) in \n        if m &gt; -1 &amp;&amp; t.(m) &gt; t.(k) then\n            (* rqe : si m = -1 ou t .(m) &lt;= t .(k) on ne fait rien *) \n            begin \n                swap k m t ; \n                percolate_down m t ; 10 \n            end;; \n</code></pre>"},{"location":"Arbres/ABR/#complexite-de-la-percolation_1","title":"Complexit\u00e9 de la percolation","text":"<p>A chaque appel interne on descend d\u2019un \u00e9tage dans l\u2019arbre. Le nombre d\u2019appel est major\u00e9 par la hauteur ( \\(\\log_2(n)\\) pour n n\u0153uds dans cet arbre complet gauche). A chaque appel interne, il y a moins de c op\u00e9rations \u00e9l\u00e9mentaires. Co\u00fbt total entre \\(\\log_2(n)\\) et \\(c\\log_2(n)\\). ODG \\(\\Theta(\\log_2(n))\\)</p>"},{"location":"Arbres/ABR/#supprimer-la-racine","title":"Supprimer la racine","text":"<pre><code>let remove t = \n    (* mettre dernier elt dans t .(1) : *) \n    t.(1) &lt;- t.(t.(0)) ;\n     (* chger taille du tas : *) \n    t.(0) &lt;- t.(0) - 1; \n    percolate_down 1 t;; \n</code></pre> <p>Complexit\u00e9 : la m\u00eame que la percolation. </p>"},{"location":"Arbres/ABR/#creation_1","title":"Cr\u00e9ation","text":""},{"location":"Arbres/ABR/#par-remontee-percolation-haute-du-nud-courant","title":"Par remont\u00e9e : percolation haute du n\u0153ud courant","text":"<ul> <li> <p>Pour t, tableau de taille n, on fait une copie de taille assez grande, disons n+1\u00a0: $$ \\begin{array}{|c|c|c|} 6 &amp; 12 &amp; 8 &amp; 7 &amp; 15 &amp; \u2192 &amp; \\color{red}{5} &amp; 6 &amp; 12 &amp; 8 &amp; 7 &amp; 15 \\ \\end{array} $$ Et on maintient \"t[1:k+1] est un tas\" (notation slicing Python). </p> </li> <li> <p>k = 1 : $$ \\begin{array}{|c|c|c|} 5 &amp; \\color{red}6 &amp; 12 &amp; 8 &amp; 7 &amp; 15 \\end{array} $$ t[1:2] est un tas</p> </li> <li> <p>k = 2\u00a0: \\begin{array}{|c|c|c|} 5 &amp; \\color{red}6 &amp; \\color{red}12 &amp; 8 &amp; 7 &amp; 15 \\end{array} On percole up 12. \\begin{array}{|c|c|c|} 5 &amp; \\color{red}12 &amp; 6 &amp; \\color{red}8 &amp; 7 &amp; 15 \\end{array} t[1:3] est un tas. </p> </li> <li> <p>k = 3 : 8 est \u00e0 sa place. t[1:4] est un tas.</p> </li> <li> <p>k = 4 : \\begin{array}{|c|c|c|} 5 &amp; 12 &amp; \\color{red}6 &amp; 8 &amp; \\color{red}7 &amp; 15 \\end{array} On percole up 7\u00a0: \\begin{array}{|c|c|c|} 5 &amp; 12 &amp; \\color{red}7 &amp; 8 &amp; \\color{red}6 &amp; 15 \\end{array} t[1:5] est un tas.</p> </li> <li> <p>k = 5 : \\begin{array}{|c|c|c|} 5 &amp; 12 &amp; \\color{red}7 &amp; 8 &amp; 6 &amp; \\color{red}15 \\end{array} On percole up 15 deux fois \\begin{array}{|c|c|c|} 5 &amp;12 &amp;\\color{red}15 &amp;8 &amp;6 &amp;\\color{red}7 \\end{array} \\begin{array}{|c|c|c|} 5 &amp;\\color{red}12 &amp;\\color{red}15 &amp;8 &amp;6 &amp;7 \\end{array} \\begin{array}{|c|c|c|} 5 &amp; \\color{red}15 &amp; \\color{red}12 &amp; 8 &amp; 6 &amp; 7 \\end{array} t[1:6] est un tas.</p> </li> </ul>"},{"location":"Arbres/ABR/#complexite","title":"Complexit\u00e9","text":"<p>Il y a n n\u0153ud, donc une hauteur de \\(p=\\lfloor \\log_2(n) \\rfloor\\).</p> <p>Pire des cas : chaque remont\u00e9e aboutit \u00e0 la racine.</p> <p>Niveau k : 2k n\u0153uds remontent \u00e0 la racine en k \u00e9tapes.</p> \\[ \\begin{align} C(n) &amp;\u2264 \\sum_{k = 1}^{p} k2^k = 2 \\sum_{k = 1}^p k2^{k-1}&amp; \\\\  &amp;= 2 \\frac{d}{dx}( \\frac{x^{p+1} -1 }{x-1})&amp; \\\\ &amp;\\leq (x \\rightarrow \\frac{\u2212px^p + px^{p+1} \u2212 x^p + 1}{ x^2 \u2212 2x + 1} ) \\\\ &amp;\\leq p2^p - 2^p +1 \\leq p2^p = \\underbrace{2^{\\lfloor \\log_2(n) \\rfloor}\\lfloor \\log_2(n) \\rfloor}_{ O(n \\log_2(n))}  \\end{align} \\]"},{"location":"Arbres/ABR/#par-descente-percolation-basse-du-nud-courant","title":"Par descente : percolation basse du n\u0153ud courant","text":"<p>A partir d\u2019un tableau de nombre </p> <p>On le consid\u00e8re comme un arbre complet gauche en d\u00e9calant ses \u00e9l\u00e9ments d\u2019un cran \u00e0 droite et en ins\u00e9rant sa longueur.  On parcourt les sommets niveau par niveau en partant de l\u2019avant dernier niveau (profondeur h \u2212 1) et dans chaque niveau on parcourt les sommets de la droite vers la gauche. Lors de ce parcours on e\ufb00ectue un percolate-down \u00e0 partir de chaque sommet.</p> <p>Parcours du tableau : on maintient l\u2019invariant Tous les sous-arbres dont la racine est \u00e0 droite du sommet courant sont des tas binaires.</p> <p>Donc apr\u00e8s avoir trait\u00e9 la racine, comme elle v\u00e9rifie l\u2019invariant, notre arbre est un tas binaire.</p> <ul> <li>Pour t, tableau de taille n, on fait une copie de taille disons n+1 \\begin{array}{|c|c|c|} 6 &amp; 12 &amp; 8 &amp; 7 &amp; 15 &amp; 9 &amp; \u2192 &amp; \\color{red}6 &amp; 6 &amp; 12 &amp; 8 &amp; 7 &amp; 15 &amp; 9 \\end{array}</li> </ul> <p>7,15, 9 aux indices &gt; \\(\\lfloor \\frac{n}{2}\\rfloor\\) sont des feuilles donc des tas.  * \\(k=\\lfloor \\frac{n}{2}\\rfloor = 3\\) (Profondeur 1). 8 est le p\u00e8re de 9. \\begin{array}{|c|c|c|} 6 &amp; 6 &amp; 12 &amp; \\color{red}8 &amp; 7 &amp; 15 &amp; \\color{red}9 &amp; \u2192 &amp; 6 &amp; 6 &amp; 12 &amp; \\color{red}9 &amp; 7 &amp; 15 &amp; \\color{red}8 \\end{array} * k = 2 (Profondeur 1). 12 est p\u00e8re de 7 et 15 \\begin{array}{|c|c|c|} 6 &amp; 6 &amp; \\color{red}12 &amp; 9 &amp; 7 &amp; \\color{red}15 &amp; 8 &amp; \u2192 &amp; 6 &amp; 6 &amp; \\color{red}15 &amp; 9 &amp; 7 &amp; \\color{red}12 &amp; 8 \\end{array}</p> <ul> <li>k = 1 (Profondeur 0). 6 est p\u00e8re de 15 et 9. 2 percos.  \\begin{array}{|c|c|c|} 6 &amp; \\color{red}6 &amp; \\color{red}15 &amp; 9 &amp; 7 &amp; \\color{red}12 &amp; 8 &amp; \u2192 &amp; 6 &amp; \\color{red}15 &amp; \\color{red}6 &amp; 9 &amp; 7 &amp; \\color{red}12 &amp; 8  \\end{array} \\begin{array}{c|c|c|} \u2192 6 &amp; \\color{red}15 &amp; \\color{red}12 &amp; 9 &amp; 7 &amp; \\color{red}6 &amp; 8 \\end{array}</li> </ul>"},{"location":"Arbres/ABR/#complexite_1","title":"Complexit\u00e9","text":"<p>Hauteur \\(p=\\lfloor \\log_2(n) \\rfloor\\) pour n n\u0153uds. </p> <p>Dans le pire des cas, chaque descente d\u2019un n\u0153ud de hauteur k aboutit aux feuilles : p \u2212 k \u00e9changes. </p> <p>Il y a au plus \\(\\lceil \\frac{n}{2^{p-k}} \\rceil\\) n\u0153uds de profondeur k (cf. TD). </p> <p>Complexit\u00e9 C (n) au pire :</p> \\[ \\begin{align} C(n) &amp;\u2264 \\underbrace{\\sum_{k = 0}^p {\\lfloor \\frac{n}{2^{p-k}} \\rfloor}}_\\text{nb node de hauteur k} {\\underbrace{\\overbrace{(p \u2013 k)}}^\\text{nb \u00e9changes au pire...}_\\text{...pour chaque node}}&amp;\\\\ &amp;\u2264 \\sum_{k=0}^p (\\frac{n}{2^{p-k}} + 1)(p-k)\\overbrace{\\leq}^\\text{ cgt. var. k = p-k } \\sum_{k=0}^p ( \\frac{n}{2^k} + 1 )k&amp;\\\\ &amp;&lt;= \\overbrace{ \\frac{p(p+1)}{2} }^{O(log_2(n)^2) } \\underbrace{\\sum_{k=0}^p {\\frac{k}{2^k}}}_\\text{s\u00e9rie CV donc major\u00e9e} = O( n )&amp; \\end{align} \\] <p>Donc cr\u00e9ation par descente moins co\u00fbteuse (\\(O(n)\\)) que par remont\u00e9e (\\(O(n \\log_2(n))\\)).</p>"},{"location":"Arbres/ABR/#tri-croissant-par-tas","title":"Tri (croissant) par tas","text":"<p>A partir d\u2019un tableau de n nombres t, on cr\u00e9e un tas-max. </p> <ul> <li>\u00c9tape 1 : la racine t[1] est le maximum du tas, on l\u2019\u00e9change avec t[n] (notation Python).  Le max se retrouve \u00e0 la fin du tas en position t[n]. \\(\\color{red}\\text{t[n:] est tri\u00e9 et contient le max.}\\)</li> <li>On met \u00e0 jour la longueur du tas (qui repr\u00e9sente le nombre d\u2019\u00e9l\u00e9ments qu\u2019il reste \u00e0 trier) en la d\u00e9cr\u00e9mentant (puisque l\u2019ancienne racine a trouv\u00e9 sa place). t[:n] est un tas.</li> <li>On percole bas la nouvelle racine. \\(\\color{red}\\text{Alors t[1:n] est de nouveau un tas}\\). Et on it\u00e8re(swap puis percolation)...</li> <li>L\u2019invariant qui assure la correction est \"A la fin de l\u2019\u00e9tape k, \\(\\color{red}\\text{t[:n-k+1] est un tas et t[n-k+1 :] est un tableau tri\u00e9}\\) par ordre croissant dont les \u00e9l\u00e9ments sont plus grands que ceux de t[:n-k+1]\". Il y a n \u00e9tapes. </li> </ul>"},{"location":"Arbres/ABR/#tri-par-tas","title":"Tri par tas","text":"<pre><code>let tri_tas l = \n    let t = create_down l in (* O (n) *)  \n    while t .(0) &gt; 1 do \n        (* mettre le max \u00e0 la fin du tab : *) \n        swap 1 t.(0) t ; \n        t.(0) &lt; -(t.(0)-1) ; (* le tas \u00e0\u00e9tudier a un elt de moins *) \n        percolate_down 1 t (* O (log (n)) *) \n    done ; t;; \n</code></pre>"},{"location":"Arbres/ABR/#complexite_2","title":"Complexit\u00e9","text":"<p>O(n) pour la cr\u00e9ation d\u2019un tas (rappel : hauteur \\(O(\\log_2(n))\\)). Chaque \u00e9change d\u2019\u00e9l\u00e9ments et chaque d\u00e9cr\u00e9mentation de t.(0) en O(1) Chaque appel \u00e0 percolate down en \\(O(\\log_2(n))\\) (au max car la longueur du tas d\u00e9cro\u00eet). n passages dans la boucle. Complexit\u00e9 au pire en \\(O(n\\log_2(n))\\) \u00e0 la louche. On ne peut pas faire mieux.</p>"},{"location":"Arbres/ABR/#files-de-priorites-une-application-des-tas","title":"Files de priorit\u00e9s (une application des tas)","text":"<p>D\u00e9finition : Une file de priorit\u00e9</p> <p>Une file de priorit\u00e9 est une structure de donn\u00e9es permettant de stocker des \u00e9l\u00e9ments et de retrouver e\ufb03cacement celui qui a la plus haute priorit\u00e9.</p> <p>Il y a trois primitives : ins\u00e9rer un \u00e9l\u00e9ment ; extraire l\u2019\u00e9l\u00e9ment ayant la plus grande cl\u00e9 ; tester si la file de priorit\u00e9 est vide ou pas. On ajoute parfois \u00e0 cette liste l\u2019op\u00e9ration \"augmenter/diminuer\" la cl\u00e9 d\u2019un \u00e9l\u00e9ment\", utilis\u00e9e par exemple dans l\u2019algorithme de Dijkstra.</p> <p>Les priorit\u00e9s sont d\u2019un type totalement ordonn\u00e9. Une file de priorit\u00e9 permet d\u2019impl\u00e9menter efficacement des planificateurs de t\u00e2ches, o\u00f9 un acc\u00e8s rapide aux t\u00e2ches d\u2019importance maximale est souhait\u00e9. On trouve une file de priorit\u00e9, par exemple, dans les ordonnanceurs des syst\u00e8mes d\u2019exploitation, notamment le noyau Linux.</p> <p>Exemple</p> <p>Les urgences d\u2019un h\u00f4pital : chaque nouveau patient est ajout\u00e9 \u00e0 la file, chaque fois qu\u2019un m\u00e9decin est libre, il s\u2019occupe du patient avec l\u2019\u00e9tat le plus critique. Le tri des patients se fait sur des crit\u00e8res quantifiables et ordonn\u00e9s comme l\u2019\u00e9tat de conscience :</p> <ul> <li>\u00c9chelle de Glasgow \\([\\![1,4]\\!]\\times[\\![1,5]\\!]\\times[\\![1,6]\\!]\\) (priorit\u00e9 aux scores bas, ce qui entra\u00eene d\u2019utiliser un tas-min) </li> <li>s\u2019ils respirent (1 ou 0), ou s\u2019ils saignent (volume de la perte de sang)... on peut aussi vouloir mettre en avant les personnes plus jeunes, les femmes enceintes (combien de f\u0153tus ?), etc... </li> </ul>"},{"location":"Arbres/ABR/#type-de-donnees_1","title":"Type de donn\u00e9es","text":"<p>Comme le tas est un tableau de donn\u00e9es (type data), on ne peut plus r\u00e9server le premier \u00e9l\u00e9ment \u00e0 l\u2019indication de sa longueur(type int). </p> <p>Toutefois, on a pris l\u2019habitude de stocker les donn\u00e9es \u00e0 partir de l\u2019\u00e9l\u00e9ment 1 et non 0. Donc nos tableaux auront une premi\u00e8re case qui ne servira \u00e0 rien.  La longueur du tas est toujours susceptible d\u2019\u00e9voluer. Il faut la d\u00e9finir comme mutable.</p> <p>f.n+1 d\u00e9signe la premi\u00e8re case libre du tas f.tbl. <pre><code>type (\u2019a, \u2019b) data = { priority : \u2019a ; value : \u2019b };; \ntype (\u2019a, \u2019b) priority_file = { mutable n : int ; tbl : (\u2019 a, \u2019b) data array };; \n</code></pre></p>"},{"location":"Arbres/ABR/#primitives_1","title":"Primitives","text":""},{"location":"Arbres/ABR/#creation_2","title":"Cr\u00e9ation","text":"<pre><code>let creer_file n (p, v) = { n = 0; tbl = Array.make (n +1) { priority = p ; value = v }};; \nlet empty_queue = creer_file 5 (1, 2);; \n</code></pre>"},{"location":"Arbres/ABR/#exceptions","title":"Exceptions","text":"<p>On peut ajouter des \u00e9l\u00e9ments dans la file tant qu\u2019elle n\u2019est pas pleine. Si elle est pleine, on soul\u00e8ve une exception Full. On peut retirer des \u00e9l\u00e9ments de la file tant qu\u2019elle n\u2019est pas vide. Si elle est vide, on soul\u00e8ve une exception Empty. Cr\u00e9ation des exceptions : </p> <pre><code>exception Empty;; \nexception Full;; \n</code></pre>"},{"location":"Arbres/ABR/#ajouter","title":"Ajouter","text":"<p>Il faut adapter la fonction de percolation haute \u00e0 nos priorit\u00e9s. En exo.</p> <pre><code>let ajouter d f = \n    if f.n+1 = Array.length f.tbl then raise Full ; \n    f.n &lt;- f.n +1; \n    f.tbl.(f.n) &lt;- d ; \n    percolate_up (f.n) f;; \n</code></pre>"},{"location":"Arbres/ABR/#retirer","title":"Retirer","text":"<p>Il faut adapter la fonction de percolation basse \u00e0 nos priorit\u00e9s. En exo.</p> <pre><code>let retirer f = \n    if f.n = 0 then raise Empty ; \n    f.tbl.(1) &lt;- f.tbl.(f.n); \n    f.n &lt;-(f.n) -1; \n    percolate_down 1 f;; \n</code></pre>"},{"location":"Arbres/ABR/#augmenter-la-priorite","title":"Augmenter la priorit\u00e9","text":"<p>Quand on augmente l\u2019urgence, donc qu\u2019on diminue la valeur de priorit\u00e9 d\u2019un \u00e9l\u00e9ment, on le fait remonter par percolation haute.</p> <p><pre><code>let plus_prioritaire k p f = \n    (* augmente la priorit\u00e9de l'\u00e9l\u00e9 ment k *) \n    if f.tbl.(k).priority &lt;= p then failwith \" la nouvelle priorit\u00e9 doit \u00eatre plus petite\" ; \n    f.tbl.(k) &lt;- {priority = p ; value = f.tbl.(k).value }; \n    percolate_up k f;; \n</code></pre> Et quand on diminue l\u2019urgence, on fait descendre l\u2019\u00e9l\u00e9ment par percolation basse </p>"},{"location":"Arbres/induction_structurelle/","title":"Induction structurelle","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"Arbres/induction_structurelle/#presentation","title":"Pr\u00e9sentation","text":""},{"location":"Arbres/induction_structurelle/#objets-inductifs","title":"Objets inductifs","text":"<p>Pr\u00e9sentation informelle</p> <p>Les objets inductifs sont des objets construits progressivement \u00e0 partir d'objets de m\u00eame nature.</p> <p>Les objets inductifs sont d\u00e9crits par deux choses :</p> <ol> <li>un ou plusieurs objets de base (qui forment le point de d\u00e9part de toute construction) ;</li> <li>une ou plusieurs r\u00e8gles de combinaisons (qui permettent de former des objets plus grands)</li> </ol> <p>Exemple</p> <p>Les constructions en Lego :</p> <ul> <li>les briques et les plaques sont des constructions de base</li> <li>A partir de deux constructions en Lego, on obtient une troisi\u00e8me en les embo\u00eetant.</li> </ul> <p>Exemple des listes en OCaml</p> <p>Cas de base : la liste vide <code>[]</code></p> <p>R\u00e8gle de combinaison : si <code>l</code> est une liste et <code>e</code> un \u00e9l\u00e9ment, alors <code>e::l</code> est une nouvelle liste qui contient un \u00e9l\u00e9ment de plus que la queue <code>l</code> .</p> <p>Exemple : les entiers de Peano</p> <p>Cas de base : L'entier z\u00e9ro, not\u00e9 \\(Z\\) est un nombre entier naturel.</p> <p>R\u00e8gle de construction : si \\(n\\) est un entier naturel, alors son successeur, not\u00e9 \\(S(n)\\) est encore un entier naturel.</p> <p>3 se note \\(S(S(S(Z)))\\).</p>"},{"location":"Arbres/induction_structurelle/#fonction-sur-les-termes","title":"Fonction sur les termes","text":"<p>Pour d\u00e9finir une fonction sur les termes, on se donne autant d'\u00e9quations que de constructeurs. On d\u00e9finit l'addition \\(+ : \\mathbb{N} \u00d7 \\mathbb{N} \u2192 \\mathbb{N}\\) par : \\(\\left\\{\\begin{matrix} Z + m = m  \\\\ S(n) + m = S(n + m) \\end{matrix}\\right.\\)</p> <p>Exemple</p> <p>(en d\u00e9signant \\(Z\\) par \\(0\\), \\(2\\) par \\(S(S(Z))\\)) etc.</p> <p>\\(2 + 3 = S(1) + 3 = S(1 + 3) = S(S(0) + 3) = S(S(0 + 3)) = S(S(3)) = 5\\).</p>"},{"location":"Arbres/induction_structurelle/#constructeurs","title":"Constructeurs","text":"<p>On utilise une syntaxe proche de OCaml.</p> <p>A chaque objet de base et chaque mani\u00e8re de construire un nouvel objet \u00e0 partir d'objets plus petits sont associ\u00e9s un symbole appel\u00e9 constructeur.</p> <p>Tout objet est alors construit comme une combinaison d'applications explicites de ces constructeurs.</p>"},{"location":"Arbres/induction_structurelle/#constructeurs-arites-termes","title":"Constructeurs, arit\u00e9s, termes","text":"<p>D\u00e9finition : Constructeur</p> <p>Un constructeur est un symbole attendant un nombre fixe d'arguments. Ce nombre est l'arit\u00e9 du constructeur.</p> <p>Pour d\u00e9finir un ensemble \\(E\\) d'objets inductifs, on fournit une signature, c.a.d un ensemble de constructeurs. Les \u00e9l\u00e9ments de \\(E\\), appel\u00e9s termes sont alors construits en utilisant exclusivement la r\u00e8gle suivante :    - Si c est un constructeur d'arit\u00e9 n et si \\(t_1,...,t_n\\) sont \\(n\\) termes alors l'application \\(c(t_1,...,t_n)\\) forme un terme.</p>"},{"location":"Arbres/induction_structurelle/#sous-termes-immediats","title":"Sous-termes imm\u00e9diats","text":"<p>Si \\(t=c(t_1,...,t_n)\\), on dit que \\(t_1\\) (ou \\(t_2\\) etc.) est un sous-terme imm\u00e9diat de \\(t\\). Dans la notation,</p> \\[t=c(c(t_2,t_3),t_1)\\] <p>On a \\(t_1\\) qui est un sous-terme imm\u00e9diat de \\(t\\) mais \\(t_2,t_3\\) sont des sous-termes (non imm\u00e9diats)</p>"},{"location":"Arbres/induction_structurelle/#cas-de-bases-cas-de-combinaisons","title":"Cas de bases, cas de combinaisons","text":"<p>Un constructeur \\(c\\) d'arit\u00e9 z\u00e9ro est lui-m\u00eame un terme. Un tel constructeur est appel\u00e9 une constante et forme un cas de base.</p> <p>Un constructeur \\(c\\) d'arit\u00e9 non nulle doit n\u00e9cessairement \u00eatre appliqu\u00e9 \u00e0 plusieurs termes d\u00e9j\u00e0 construits pour former un nouveau terme. Cela repr\u00e9sente un cas de combinaison.</p> <p>Un constructeur n-aire est un constructeur d'arit\u00e9 \\(n\\). On parle de constructeurs unaires, binaires, ternaires pour les arit\u00e9s \\(1, 2, 3\\)</p>"},{"location":"Arbres/induction_structurelle/#structure-des-termes","title":"Structure des termes","text":"<p>D\u00e9finition : Sous termes imm\u00e9diats</p> <p>Les termes \\(t_1\\) \u00e0 \\(t_n\\) utilis\u00e9s pour construire un terme \\(t=c(t_1,...,t_n)\\) sont appel\u00e9s sous-termes imm\u00e9diats de \\(t\\). Deux termes sont \u00e9gaux si et seulement si ils sont construits de la m\u00eame fa\u00e7on, c'est \u00e0 dire \u00e0 partir des m\u00eames sous-termes, combinas par les m\u00eames constructeurs</p> <p>Remarque</p> <p>Cette \u00e9galit\u00e9 est syntaxique. </p> <p>Contre-exemple : L'\u00e9galit\u00e9 dans \\(\\mathbb{Q}\\) n'est pas seulement syntaxique. En e\ufb00et \\(\\frac{6}{4}\\) est \u00e9gal \u00e0 \\(\\frac{3}{2}\\).</p>"},{"location":"Arbres/induction_structurelle/#precisions","title":"Pr\u00e9cisions","text":"<p>Sauf mention du contraire, on ne consid\u00e8re que des termes finis : ceux qui peuvent \u00eatre form\u00e9s \u00e0 partir d'un nombre fini d'applications de constructeurs.</p> <p>Un ensemble inductif \\(E\\) dont la signature contient au moins un symbole de constante est non vide.</p> <p>Une signature peut tr\u00e8s bien contenir une infinit\u00e9 de symboles (mais les termes n'en utilisent qu'un nombre fini).</p>"},{"location":"Arbres/induction_structurelle/#signature-typee","title":"Signature typ\u00e9e","text":"<p>Parfois, on impose que chaque \u00e9l\u00e9ment d'un constructeur soit d'une nature pr\u00e9cise.</p> <p>Par exemple dans <code>e::l</code>, on s'attend \u00e0 ce que <code>e</code> et <code>l</code> aient des types di\ufb00\u00e9rents. Le premier est de type \u00e9l\u00e9ment et le second de type liste d'\u00e9l\u00e9ments.</p> <p>On peut donc utiliser une notation de type</p> \\[c\\text{ : }E_1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 E_n \u2192 E\\] <p>pour indiquer qu'un constructeur \\(c\\) d'arit\u00e9 \\(n\\) attend des arguments pris dans les ensembles respectifs \\(E_1, . . . , E_n\\).</p> <p>Avec cette convention, \\(c\\) \\(:\\) \\(E\\) d\u00e9signe que \\(c\\) est une constante de l'ensemble \\(E\\) .</p>"},{"location":"Arbres/induction_structurelle/#ordre-structurel","title":"Ordre structurel","text":""},{"location":"Arbres/induction_structurelle/#relation-dordre","title":"Relation d'ordre","text":"<p>D\u00e9finition : </p> <p>Soit \\(E\\) un ensemble; une relation \\(\u2264\\) sur \\(E\\) est une realtion d'ordre si pour tous \\(x,y\\) et \\(z\\) \u00e9l\u00e9ments de \\(E\\) :</p> <ul> <li>\\(x \u2264 x\\) (r\u00e9fl\u00e9xivit\u00e9)</li> <li>(\\(x \u2264 y\\) et \\(y \u2264 x\\)) \\(\u21d2\\) \\(x=y\\) (antisym\u00e9trie)</li> <li>(\\(x \u2264 y\\) et \\(y \u2264 z\\)) \\(\u21d2\\) \\(x \u2264 z\\)</li> </ul>"},{"location":"Arbres/induction_structurelle/#ensembles-bien-fondes","title":"Ensembles bien fond\u00e9s","text":"<p>D\u00e9finition : </p> <p>Un ensemble \\(E\\) est dit bien fond\u00e9 s'il est muni d'une relation d'ordre \\(\u227c\\) telle qu'il n'existe pas de suite\\(^a\\) strictement d\u00e9croissante de cet ensemble.</p> <p>Un ensemble est dit bien ordonn\u00e9, si il est bien fond\u00e9 et si, de plus, la relation d'ordre est totale.</p> <p>\\(a\\). Rappel : une suite sur \\(E\\) est simplement une application \\(f : \\mathbb{N} \u2192 E\\)</p>"},{"location":"Arbres/induction_structurelle/#ensembles-bien-ordonnesfondes","title":"Ensembles bien ordonn\u00e9s/fond\u00e9s","text":"<p>Exemples</p> <p>\\(\u2115\\) muni de \\(\u2264\\) usuel est bien ordonn\u00e9</p> <p>\\(\u2115^2\\) muni de l'ordre lexicographique est bien ordonn\u00e9 </p> <p>\\((a, b)  \u227c_L (a', b') \\Leftrightarrow (a &lt; a') \u2228 (a = a' \u2227 b \u2264 b')\\)</p> <p>\\(\u2115^2\\) muni de l'ordre produit est bien fond\u00e9 </p> <p>\\((a, b)  \u227c_P(a', b') \\Leftrightarrow (a \u2264 a') \u2227 (b \u2264 b')\\)</p> <p>Relation non totale.</p> <p>\\(\u2124\\) muni de l'ordre usuel n'est pas bien fond\u00e9 \\((\u22121, \u22122, \u22123 . . .\\) est infini strictement d\u00e9croissante).</p>"},{"location":"Arbres/induction_structurelle/#bon-ordre-et-element-minimal","title":"Bon ordre et \u00e9l\u00e9ment minimal","text":"<p>Proposition</p> <p>Un ensemble ordonn\u00e9 \\(E\\) est bien ordonn\u00e9 si et seulement si toutes les parties non vides de \\(E\\) admettent un \u00e9l\u00e9ment minimal unique. </p> <p>Par \u00e9l\u00e9ment minimal, on entend un \u00e9l\u00e9ment plus petit que tous les autres.</p> <p>Preuve</p> <p>Si \\(E\\) est bien ordonn\u00e9</p> <p>Soit \\(A \u2282 E\\) une partie non vide sans \u00e9l\u00e9ment minimal. Prenons \\(e_0 \u2208 A\\).</p> <ul> <li>Puisque \\(e_0\\) n'est pas minimal, on peut trouver \\(e_1 \u2208 A\\) tel que \\(\u00ac(e_1 \u2265 e_0)\\), c'est \u00e0 dire \\(e_1 &lt; e_0\\) puisque l'ordre est total.</li> <li>De proche en proche on construit un \\(n\\)-uplet (\\(e_0, e_1, . . . , e_n\\)) de valeurs de \\(A\\) donc de \\(E\\) strictement d\u00e9croissantes aussi longue qu'on veut. Contradiction avec \"bien fond\u00e9\". A poss\u00e8de donc un \u00e9l\u00e9ment minimal.</li> <li>L'unicit\u00e9 de l'\u00e9l\u00e9ment minimal vient de l'antisym\u00e9trie.    Si \\(e, e'\\) sont minimaux dans \\(A\\), \\(e \u2264 e'\\) et \\(e' \u2264 e\\), donc \\(e = e'\\) par antisym\u00e9trie.</li> </ul> <p>Si toute partie a un \u00e9l\u00e9ment minimal</p> <p>L'ordre est total car toute partie \u00e0 deux \u00e9l\u00e9ments admet un \u00e9l\u00e9ment minimal. L'un est donc plus petit que l'autre.</p> <ul> <li>Consid\u00e9rons la suite \\((u_n)_n\\) d'\u00e9l\u00e9ments de \\(E\\) .    Posons \\(U={u_n|n\\in\\mathbb{N}}\u2282E\\).</li> <li>Comme \\(U\u2260\u2205\\), \\(U\\) admet un \u00e9l\u00e9ment minimal, disons, \\(u_k\\) . Si la suite est strictement d\u00e9croissante, alors \\(u_k&gt;u_{k+1}\\), ce qui contredit la minimalit\u00e9.</li> <li>Il n'y a pas de suite strictement d\u00e9croissante dans l'ensemble : il est bien fond\u00e9.</li> </ul>"},{"location":"Arbres/induction_structurelle/#elements-sans-predecesseurs","title":"\u00c9l\u00e9ments sans pr\u00e9d\u00e9cesseurs","text":"<p>D\u00e9finition: Elements sans pr\u00e9d\u00e9cesseur</p> <p>Dans toute partie d'un ensemble bien fond\u00e9, il y a un ou des \u00e9l\u00e9ments qui ne sont plus petits qu'aucun autre de cette partie. On les appelle \u00e9l\u00e9ments sans pr\u00e9d\u00e9cesseur.</p> <p>Soit \\(E\\) bien fond\u00e9 et \\(e_0\\), \\(F\\) tels que \\(e_0\u2208 F \u2282 E\\) . Si \\(e_0\\) est sans pr\u00e9d\u00e9cesseur dans \\(F\\) , alors on est content. Sinon, on peut trouver \\(e_1 &lt; e_0\\) dans \\(F\\) .</p> <p>De proche en proche on construit une suite \\(e_0 &gt; e_1 &gt;\u00b7\u00b7\u00b7&gt;e_n\\) dans \\(F\\). Mais cette suite ne se prolonge pas ind\u00e9finiment car l'ordre est bien fond\u00e9.</p> <p>Donc il existe \\(e_k \u2208 F\\) sans pr\u00e9d\u00e9cesseur.</p> <p>R\u00e9ciproquement \\(\\color{red}\\text{Si toute partie d'un ensemble ordonn\u00e9 admet des \u00e9l\u00e9ments}\\) \\(\\color{red}\\text{sans pr\u00e9d\u00e9cesseur, l'ensemble est bien fond\u00e9}\\).</p> <p>Preuve : adapter le transparent pr\u00e9c\u00e9dent.</p>"},{"location":"Arbres/induction_structurelle/#taille-et-ordre","title":"Taille et ordre","text":""},{"location":"Arbres/induction_structurelle/#taille","title":"Taille","text":"<p>D\u00e9finition : Taille d'un terme</p> <p>La taille d'un terme est le nombre de constructeurs qui le composent. Si \\(t\\) est un terme, on note \\(|t|\\) sa taille.</p> <p>Exemple</p> <p>Pour les entiers de Peano, la taille de \\(Z\\) est \\(1\\), celle de \\(S(S(S(Z)))\\) est \\(4\\).</p> <p>La d\u00e9finition de la taille peut subir quelques am\u00e9nagements suivant les contextes.</p> <p>Par exemple, pour les listes on a coutume de dire que <code>[]</code> est de taille \\(0\\) et non \\(1\\), et que la taille de <code>[1;2]</code> (qui est en fait <code>1::2::[]</code>) est \\(2\\) et non \\(3\\). La taille des listes est donc usuellement un translat\u00e9 de \\(-1\\) de la d\u00e9finition de la taille prise dans le transparent pr\u00e9c\u00e9dent.</p>"},{"location":"Arbres/induction_structurelle/#ordre-structurel_1","title":"Ordre structurel","text":"<p>D\u00e9finition : Ordre structurel</p> <p>Soit \\(E\\) un ensemble de termes et \\((t_1, t_2) \u2208 E^2\\). Notons \\(t_1 &lt;_i t_2\\) pour indiquer que \\(t_1\\) est un sous-terme \"imm\u00e9diat\" de \\(t_2\\).</p> <p>L'ordre structurel sur \\(E\\) est la relation d'ordre \\(\u2264\\) engendr\u00e9 par \\(&lt;_i\\), c.a.d la cl\u00f4ture r\u00e9\ufb02exive-transitive de \\(&lt;_i\\) (plus petite relation binaire contenant \\(&lt;_i\\) et \u00e0 la fois r\u00e9\ufb02exive et transitive).   Un sous-terme de \\(t\\) est un terme \\(t'\\) tel que \\(t' \u2264 t\\)</p> <p>Remarque</p> <p>Pour s'assurer que la relation \\(\u2264\\) engendre bien un ordre, il faut s'assurer qu'elle est anti-sym\u00e9trique. Elle est, par d\u00e9finition de la cl\u00f4ture, r\u00e9\ufb02exive et transitive.</p>"},{"location":"Arbres/induction_structurelle/#cloture-reflexive-transitive","title":"Cl\u00f4ture r\u00e9\ufb02exive-transitive","text":"<p>La cl\u00f4ture r\u00e9\ufb02exive-transitive de \\(&lt;_i\\) est par d\u00e9finition la plus petite relation binaire \\(R\\) sur \\(E\\) (i.e. partie de \\(E \u00d7 E\\) ) telle que :</p> <ol> <li>\\(&lt;_i\\) est incluse dans \\(R\\)</li> <li>Si \\(x\u2208E\\), alors \\((x,x)\u2208R\\)</li> <li>Si \\((x, y ) \u2208 R\\) et \\((y , z) \u2208 R\\) alors \\((x, z) \u2208 R\\)</li> </ol> <p>Remarque</p> <p>Id\u00e9e de la preuve pour l'existence de \\(\u2264\\) (qu'on pr\u00e9f\u00e8re noter de fa\u00e7on infixe)</p> <p>Indication : \\(E \u00d7 E\\) contient  \\(&lt;_i\\) et est r\u00e9\ufb02exive-transitive. Donc l'ensemble des relations qui v\u00e9rifient les 3 points est non vide.    Alors l'intersection de toutes les relations \\(R\\) qui v\u00e9rifient les points ci-dessus est bien r\u00e9\ufb02exive-transitive.    Et c'est la plus petite \u00e0 le v\u00e9rifier : on la note \\(\u2264\\).</p>"},{"location":"Arbres/induction_structurelle/#theoreme-de-lordre-bien-fonde","title":"Th\u00e9or\u00e8me de l'ordre bien fond\u00e9","text":"<p>Th\u00e9or\u00e8me   Soit \\(E\\) un ensemble de termes. Notons \\(\u2264\\) l'ordre structurel sur \\(E\\) et \\(&lt;\\) l'ordre strict associ\u00e9. On a les propri\u00e9t\u00e9s suivantes :</p> <ul> <li>Si \\(t_1 &lt; t_2\\), alors \\(|t_1| &lt; |t_2|\\)</li> <li>La relation \\(\u2264\\) est une relation d'ordre bien fond\u00e9e.</li> </ul> <p>Preuve</p> <p>On suppose \\(t_1 &lt; t_2\\),</p> <p>Puisque \\(t_1 \u2264 t_2\\), alors par cons\u00e9quence de la d\u00e9finition de la cl\u00f4ture r\u00e9\ufb02exive-transitive, il existe \\(x_1,x_2,...,x_k\\) tels que \\(x_1=t_1,x_k=t_2\\) et pour tout \\(j\u2208\u27e61,k\u22121\u27e7\\), \\(x_j &lt;_i x_{j+1}\\).</p> <p>Comme \\(t_1 &lt; t_2\\), alors \\(k \u2265 2\\).</p> <p>Pour \\(j\\) convenable, puisque \\(x_j\\) est un sous-terme imm\u00e9diat de \\(x_{j+1}\\) (ce que signifie \\(x_j  &lt;_i x_{j+1}\\)) et donc \\(|x_j| &lt; |x_{j+1}|\\) (puisqu'il faut au moins un constructeur de plus pour construire \\(x_{j+1}\\) que pour \\(x_j\\) ). </p> <p>Par transitivit\u00e9 de \\(&lt;\\) sur \\(\u2115\\), on a \\(|t_1| &lt; |t_2|\\)</p> <p>Preuve : anti-sym\u00e9trie</p> <p>Soient \\(t_1, t_2\\) deux termes tels que \\(t_1 \u2264 t_2, t_2 \u2264 t_1\\) et \\(t_1 \\neq  t_2\\). </p> <p>On a donc \\(t_1 &lt; t_2\\) puisque \\(t_1 \u2264 t_2\\) et \\(t_1\u2260t_2\\). </p> <p>Ainsi \\(|t_1| &lt;_\u2115 |t_2|\\) par le point pr\u00e9c\u00e9dent.    De m\u00eame, on obtient \\(|t_2| &lt;_\u2115 |t_1|\\).    Alors \\(|t_2|, |t_1|\\) sont dans \\(\u2115\\), \\(|t_1| &lt;_\u2115 |t_2|\\) et \\(|t_2| &lt;_\u2115 |t_1|\\) : ABSURDE.</p> <p>Preuve : caract\u00e8re bien fond\u00e9</p> <p>Supposons qu'il existe une suite infinie strictement d\u00e9croissante \\((t_i)_{i\u2208\u2115}\\) pour l'ordre structurel. </p> <p>Alors, par le point 1 du th\u00e9or\u00e8me, la suite des tailles \\((|t_i|)_{i\u2208\u2115}\\) est une suite infinie strictement d\u00e9croissante de \\(\u2115\\).    Or cela est impossible puisque \\(\u2115\\) est bien ordonn\u00e9. ABSURDE.</p>"},{"location":"Arbres/induction_structurelle/#principe-dinduction","title":"Principe d'induction","text":""},{"location":"Arbres/induction_structurelle/#presentation_1","title":"Pr\u00e9sentation","text":"<p>La d\u00e9finition des ensembles inductifs am\u00e8ne naturellement \u00e0 une technique de raisonnement sur les termes proche de la r\u00e9currence.</p> <p>On peut r\u00e9sumer cette technique ainsi : une propri\u00e9t\u00e9 \u00e0 propos des objets inductifs qui vaut pour toutes les constantes et est pr\u00e9serv\u00e9e par chaque construction inductive, est n\u00e9cessairement vraie pour tous les objets pouvant \u00eatre construits.</p>"},{"location":"Arbres/induction_structurelle/#principe-dinduction-structurelle","title":"Principe d'induction structurelle","text":"<p>Th\u00e9or\u00e8me</p> <p>Soit \\(E\\) un ensemble inductif (non vide donc avec au moins une constante) et une propri\u00e9t\u00e9 \\(P\\) \u00e0 propos des objets de \\(E\\). Si, pour chaque constructeur \\(c\\) d'arit\u00e9 \\(n\\), la propri\u00e9t\u00e9 \\(P(c(t_1,...,t_n))\\) est satisfaite d\u00e8s lors que les propri\u00e9t\u00e9s \\(P(t_1)\\) \u00e0 \\(P(t_n)\\) sont satisfaites, alors \\(P(t)\\) est satisfaite pour tout \\(t\\) de \\(E\\) .</p> <p>Remarque</p> <p>Si \\(t\\) est une constante, alors pour tout terme \\(x \u2208 E , x &lt;_i t\\) est faux. Donc \\(\u2200x \u2208 E , (x  &lt;_i t \\Rightarrow P(x))\\) est vraie. Par suite \\(P\\) est satisfaite pour tous les sous-termes imm\u00e9diats de \\(t\\). Il vient donc que \\(P(t)\\) est satisfaite.</p> <p>Rappel :\\(x &lt;_i t\\) signifie que x est sous-terme imm\u00e9diat de t.</p> <p>Preuve</p> <p>Supposons que le sous-ensemble \\(A \u2282 E\\) des termes ne satisfaisant pas \\(P\\) est non vide.</p> <p>\\(A\\) admet donc un \u00e9l\u00e9ment sans pr\u00e9d\u00e9cesseur \\(t_0\\) puisque l'ordre est bien fond\u00e9. </p> <p>Si \\(t_0\\) est une constante, alors \\(P(t_0)\\) est satisfaite. Ce n'est pas possible puisque \\(t_0 \u2208 A\\). </p> <p>Si \\(t_0\\) n'est pas une constante, il a des sous-termes imm\u00e9diats. Ils ne peuvent donc \u00eatre dans \\(A\\) puisque plus petits strictement que \\(t_0\\).</p> <p>M\u00e9zalors, chaque sous-terme satisfait la propri\u00e9t\u00e9 \\(P\\). </p> <p>D'apr\u00e8s l'hypoth\u00e8se sur \\(t\\), cela veut dire que \\(P(t_0)\\) est satisfaite et donc que \\(t_0\u2209A\\) : ABSURDE.</p> <p>Exemple : \u00e9l\u00e9ment neutre</p> <p>Les \u00e9quations d\u00e9finissant l'addition des entiers de Peano assurent que \\(Z + n = n\\) vaut pour tout \\(n \u2208 \u2124\\).</p> <p>Montrons que \\(n + Z = n\\) pour tout \\(n\\) \u00e9galement :    - Cas de base : \\(Z + Z = Z\\) par d\u00e9finition de \\(+\\) (1ere \u00e9quation)    - H\u00e9r\u00e9dit\u00e9 : prenons un entier de Peano \\(n\\) satisfaisant \\(n + Z = n\\). Alors : </p> <p>\\(S(n) + Z = S(n + Z)\\text{ par d\u00e9f. de +} \\\\ = S(n) \\text{ Par HI }\\)</p> <ul> <li>On en d\u00e9duit que pour tout entier de Peano \\(n\\), \\(n + Z = n\\).</li> </ul>"},{"location":"Arbres/induction_structurelle/#recurrence","title":"R\u00e9currence","text":"<p>En r\u00e9crivant le principe d'induction structurelle des entiers de Peano avec les notations habituelles (\\(0\\) au lieu de \\(Z\\), \\(2\\) au lieu de \\(S(S(Z))\\)), et en consid\u00e9rant \\(P\\), un pr\u00e9dicat sur les entiers, nous obtenons que :</p> <ul> <li>Si \\(P(0)\\) est vrai</li> <li>Si pour tout \\(n\\) satisfaisant \\(P(n)\\), la propri\u00e9t\u00e9 \\(P(n + 1)\\) est satisfaite ;</li> <li>Alors pour tout \\(n\\) entier, la propri\u00e9t\u00e9 \\(P(n)\\) est satisfaite.</li> <li>C'est pr\u00e9cis\u00e9ment le principe de r\u00e9currence !!</li> </ul>"},{"location":"Divers/Backtracking/","title":"Backtracking","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <p>Un cours de Sol\u00e8ne Mirliaz ; Cette page de Wikipedia</p>"},{"location":"Divers/Backtracking/#probleme-dexploration","title":"Probl\u00e8me d'exploration","text":"<p>D\u00e9finition Un probl\u00e8me d\u2019exploration (ou de recherche) est un probl\u00e8me algorithmique \\(P\\) donn\u00e9 par une relation binaire \\(R\u2282E \u00d7(S \\sqcup  \\{None\\})\\) telle qu\u2019il existe deux sous-ensembles not\u00e9s \\(E^+\\), \\(E^\u2212\\) de \\(E\\) formant une partition de \\(E\\) et v\u00e9rifiant : \\(R\u2282(E^+ \\times S )\\sqcup (E^\u2212 \\times \\{None\\})\\)</p> <p>Remarque</p> <p>Les \u00e9l\u00e9ments de \\(E\\) sont appel\u00e9s des entr\u00e9es et ceux de \\(S\\) des solutions;</p> <p>Le fait que l\u2019union soit disjointe interdit d\u2019avoir une entr\u00e9e \\(e\\) et une solution \\(s\\) telles que \\((e, s ) \u2208R\\) et \\((e, None) \u2208R\\).</p>"},{"location":"Divers/Backtracking/#vocabulaire-solution","title":"Vocabulaire : solution","text":"<p>Avec les notations de la d\u00e9finition pr\u00e9c\u00e9dente :</p> <ul> <li>si \\((e, s ) \u2208E \u00d7S\\) , on dit que \\(s\\) est une solution de l\u2019entr\u00e9e \\(e\\);</li> <li>si \\((e, Node) \u2208R\\), on dit que l\u2019entr\u00e9e \\(e\\) n\u2019a pas de solution.</li> </ul>"},{"location":"Divers/Backtracking/#backtracking-presentation-informelle","title":"Backtracking : pr\u00e9sentation informelle","text":"<p>D\u00e9finition Le backtracking (ou retour sur trace) est une classe d\u2019algorithmes cherchant la solution de probl\u00e8mes d\u2019exploration.</p> <p>Notamment les probl\u00e8mes avec contraintes de satisfactions comme le Sudoku o\u00f9 les \\(N\\)-reines sont r\u00e9solubles par backtracking.</p> <p>Le backtracking construit incr\u00e9mentalement des candidats-solutions partiels qui sont abandonn\u00e9s d\u00e8s lors qu\u2019on \u00e9tablit qu\u2019ils ne peuvent pas \u00eatre compl\u00e9t\u00e9s en une solution.</p> <p>Conceptuellement, les candidats-solutions partiels sont repr\u00e9sent\u00e9s comme des n\u0153uds d\u2019une structure arborescente : l\u2019arbre de recherche potentiel.</p> <p>Chaque candidat-solution partiel est le parent d\u2019autres candidats-solutions qui diff\u00e8rent de lui par une simple \u00e9tape d\u2019extension (par exemple ajout d\u2019un \u00e9l\u00e9ment unique \u00e0 une liste).</p> <p>Les feuilles sont les candidats-solutions qui ne peuvent pas \u00eatre d\u00e9velopp\u00e9s plus avant (ce sont des candidats-solutions complets). Certains candidats-solutions complets sont effectivement des solutions, d\u2019autres non.</p>"},{"location":"Divers/Backtracking/#backtracking-arbre-de-decision","title":"Backtracking : arbre de d\u00e9cision","text":"<p>L\u2019algorithme de backtracking parcourt l\u2019arbre de recherche potentiel par un DFS. A chaque n\u0153ud \\(c\\) (donc, un candidat-solution), l\u2019algorithme cherche si \\(c\\) peut \u00eatre compl\u00e9t\u00e9 en une solution valide.</p> <ul> <li>Si ce n\u2019est pas possible, le sous-arbre de racine \\(c\\) dans l\u2019arbre solution est supprim\u00e9.</li> <li>Par ailleurs, si \\(c\\) est une feuille, l\u2019algorithme cherche si \\(c\\) lui-m\u00eame peut \u00eatre consid\u00e9r\u00e9 comme une solution valide (exemple une grille compl\u00e8tement remplie constitue-t-elle une solution au probl\u00e8me de Sudoku ?).</li> </ul> <p>L\u2019arbre effectivement parcouru par le backtracking est un sous-arbre (souvent strict) de l\u2019arbre de recherche potentiel.</p>"},{"location":"Divers/Backtracking/#algorithme-de-backtracking","title":"Algorithme de Backtracking","text":"<pre><code>fonction backtrack(e, c):\n    entree : e entr\u00e9e du probl\u00e8me; c candidat\u2212solution partiel\n    sortie : une solution de e s'il en existe, None sinon\n    debut\n        si c est un candidat\u2212solution complet(une feuille) alors\n            si c est une solution de e alors renvoyer c\n            sinon renvoyer None;\n        sinon\n            pour tout c' fils candidat\u2212solution POSSIBLE de c faire\n                v \u27f5 backtrack(e, c');\n                si v \u2260 None alors renvoyer v\n            renvoyerNone;\n    fin\n</code></pre> <p>Remarque Un candidat-solution impossible est un candidat dont on se rend compte qu\u2019il ne peut pas \u00eatre compl\u00e9t\u00e9 en une solution. La d\u00e9tection pr\u00e9coce des candidats-solutions impossibles permet de limiter le co\u00fbt de l\u2019exploration.</p>"},{"location":"Divers/Backtracking/#complexite","title":"Complexit\u00e9","text":"<p>La complexit\u00e9 d\u2019un algorithme de backtracking de recherche de solution pour une entr\u00e9e \\(e\\) d\u00e9pend en particulier de la taille de l\u2019arbre explor\u00e9.</p> <p>On se place dans le cas le pire o\u00f9 aucune d\u00e9tection pr\u00e9coce de candidat impossible n\u2019est d\u00e9tect\u00e9e.</p> <p>Il faut alors explorer tout l\u2019arbre de d\u00e9cision.</p> <p>Complexit\u00e9</p> <p>On note \\(h\\) la hauteur de l\u2019arbre et \\(p\\), l\u2019arit\u00e9 maximum d\u2019un n\u0153ud. L\u2019arbre est alors de taille \\(\\sum_{i=0}^{h}{p^i} = O(p^h)\\).</p> <p>Le test de d\u00e9tection pr\u00e9coce d\u2019impossibilit\u00e9 pour un candidat \\(c\\) a une complexit\u00e9 en \\(O (g(|c|))\\) pour une certaine fonction \\(g\\). La taille \\(|c|\\) du candidat est domin\u00e9e grossi\u00e8rement par un \\(k (|e|)\\) pour une certaine fonction \\(k\\) ne d\u00e9pendant que de \\(e\\). Ainsi, la d\u00e9tection pr\u00e9coce est en \\(O (g\u25e6k (|e|))\\)</p> <p>Lorsque le candidat \\(c\\) est une feuille, le test de validit\u00e9 du candidat comme solution est en \\(O (l(|c |))\\) donc en \\(O (l \u25e6k (|e|))\\) pour une certaine fonction \\(l\\)</p> <p>Bref, il existe \\(f\\), tel que pour tout candidat \\(c\\), la d\u00e9tection pr\u00e9coce et le test de validit\u00e9 ont une complexit\u00e9 en \\(O (f (|e|))\\) o\u00f9 \\(f = max(g \u25e6k , l \u25e6k )\\).</p> <p>Ainsi, le backtracking a une complexit\u00e9 major\u00e9e par un \\(O (p^h \\times f(|e|))\\)</p>"},{"location":"Graphes/Graphes/","title":"Graphes","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"Graphes/Graphes/#credits","title":"Cr\u00e9dits","text":"<ul> <li>Wikip\u00e9dia : th\u00e9orie des graphes</li> <li>Wikip\u00e9dia : graphes simples</li> <li>Toujours le Mansuy.  </li> </ul>"},{"location":"Graphes/Graphes/#historique","title":"Historique","text":""},{"location":"Graphes/Graphes/#les-sept-ponts-de-konigsberg","title":"Les sept ponts de K\u00f6nigsberg","text":"<p>Un article du math\u00e9maticien suisse Leonhard Euler, pr\u00e9sent\u00e9 \u00e0  l\u2019Acad\u00e9mie de Saint-P\u00e9tersbourg en 1735 puis publi\u00e9 en 1741.  </p> <p>Trouver une promenade \u00e0 partir d\u2019un point donn\u00e9 qui fasse revenir \u00e0  ce point en passant une fois et une seule par chacun des sept ponts  de la ville de K\u00f6nigsberg : Circuit eul\u00e9rien.</p> <p>Euler fut sans doute le premier \u00e0 proposer un traitement  math\u00e9matique de la question, suivi par Vandermonde.</p> <p></p> <p>Figure \u2013 Abstraction du probl\u00e8me des 7 ponts de K\u00f6nigsberg</p> <p>Th\u00e9or\u00e8me</p> <p>Un graphe connexe admet un circuit eul\u00e9rien si et  seulement si tous ses sommets sont de degr\u00e9 pair. Ici un des sommets a 3 voisins: pas de circuit eul\u00e9rien.  </p>"},{"location":"Graphes/Graphes/#graphes-representation-sous-graphes","title":"Graphes, repr\u00e9sentation, sous-graphes","text":""},{"location":"Graphes/Graphes/#informellement","title":"Informellement","text":"<p>Un graphe est un ensemble de points dans lequel on fait appara\u00eetre  une ou plusieurs relations(s) entre deux points. Ces relations sont en g\u00e9n\u00e9ral repr\u00e9sent\u00e9es par des \ufb02\u00e8ches ou par des  segments. Dans le premier cas, le graphe est dit orient\u00e9 et les liens  sont appel\u00e9s des arcs. Dans le second, le graphe est dit non orient\u00e9 et  les liens sont souvent appel\u00e9s des ar\u00eates.  </p> <p>Les points sont appel\u00e9s les sommets (en r\u00e9f\u00e9rence aux poly\u00e8dres) ou  les n\u0153uds (en r\u00e9f\u00e9rences \u00e0 la loi des n\u0153uds).</p> <p></p> <p>Figure \u2013 Un graphe orient\u00e9 avec des arcs - un graphe non orient\u00e9 et ses ar\u00eates.</p> <p>Exemple : plan d\u2019une ville. <p></p></p> <p>Figure \u2013 Un multigraphe non orient\u00e9 : ses ar\u00eates multiples en bleu et ses boucles en rouge.</p> <p>En anglais, sommet se dit vertice, ar\u00eate se dit undirected edge et arc  se dit directed edge.  </p> <p>Les ar\u00eates multiples ne sont pas au programme.  </p>"},{"location":"Graphes/Graphes/#graphe-simple-non-oriente","title":"Graphe simple non orient\u00e9","text":"<p>La d\u00e9finition suivante ne s\u2019applique pas aux graphes avec ar\u00eates multiples.</p> <p>D\u00e9finition: Graphe simple non orient\u00e9</p> <p>Un graphe (simple) non orient\u00e9 \\(G\\) est un couple \\((V, E)\\) o\u00f9 \\(E \u2286 P(V)\\) est un ensemble de paires ou de singleton d\u2019\u00e9l\u00e9ments de \\(V\\). On appelle sommets les \u00e9l\u00e9ments de \\(V\\) et arcs ceux de \\(E\\).</p> <p>La lettre E est utilis\u00e9e pour les arcs car en anglais, arcs se dit edge.  </p> <p>Certains auteurs utilisent un vocabulaire sp\u00e9cial pour les graphes non  orient\u00e9s. Par exemple, une ar\u00eate (undirected edge) d\u00e9signe un arc.  </p> <p>Soit \\(a = \\{x, y\\}\\). On dit que :  </p> <ul> <li>\\(a\\) relie les sommets \\(x\\) et \\(y\\), \\(x\\) et \\(y\\) sont adjacents ou encore voisins</li> <li>\\(a\\) est incidente avec \\(x\\) et \\(y\\) ou encore \\(x\\) et \\(y\\) sont incidents avec \\(a\\).  </li> </ul>"},{"location":"Graphes/Graphes/#graphe-simple-oriente","title":"Graphe simple orient\u00e9","text":"<p>Au programme ne figurent que les graphes avec au plus un seul arc d\u2019un  sommet \u00e0 un autre.</p> <p>D\u00e9finition: Graphe simple orient\u00e9</p> <p>Un graphe simple orient\u00e9 \\(G\\) est un couple \\((V, E)\\) o\u00f9 :</p> <ul> <li>\\(V\\) est appel\u00e9 l\u2019ensemble des sommets de \\(G\\),</li> <li>Et \\(E \u2286 V^2\\) est un ensemble de couples d\u2019\u00e9l\u00e9ments de \\(V\\) appel\u00e9 l\u2019ensemble des arcs de \\(G\\).</li> </ul> <p>La lettre \\(V\\) est utilis\u00e9e pour les sommets car en anglais, sommet se dit vertex (au pluriel vertices).  </p> <p>Un arbre est un cas particulier de graphe orient\u00e9 simple.</p> <p>Mais pour certains auteurs, un arbre est un graphe non orient\u00e9  connexe et acyclique (voir plus loin pour les d\u00e9finitions).  </p> <p>Un arc est not\u00e9 \\(a = (x, y)\\) ou \\(a = x \u2192 y\\) et on dit que :  </p> <ul> <li>\\(a\\) va de \\(x\\) \u00e0 \\(y\\)</li> <li>\\(x\\) est l\u2019extr\u00e9mit\u00e9 initiale de \\(a\\) </li> <li>\\(y\\) est l\u2019extr\u00e9mit\u00e9 terminale de \\(a\\)</li> <li>\\(y\\) est un voisin de \\(x\\). \\(a\\) est incident \u00e0 \\(x\\) et \\(y\\) </li> </ul>"},{"location":"Graphes/Graphes/#degre","title":"Degr\u00e9","text":"<p>Dans un graphe g\u00e9n\u00e9ral (orient\u00e9 ou non), on appelle degr\u00e9 d\u2019un  sommet \\(s\\) et on note \\(d(s)\\), le nombre d\u2019arcs incidents au sommet \\(s\\). Dans un graphe g\u00e9n\u00e9ral orient\u00e9, on distingue le degr\u00e9 sortant ou  ext\u00e9rieur \\(d^{+}(s)\\) qui est \u00e9gal au nombre d\u2019arcs dont \\(s\\) est l\u2019extr\u00e9mit\u00e9  initiale et le degr\u00e9 entrant ou int\u00e9rieur \\(d^{\u2212}(s)\\) qui est \u00e9gal au nombre  d\u2019arcs dont \\(s\\) est l\u2019extr\u00e9mit\u00e9 finale.  </p> <ul> <li>\\(d^{-}(S_3) = 3\\)</li> <li>\\(d^{+}(S_3) = 1\\)</li> <li>\\(d(S_3) = 4\\)</li> </ul> <p></p>"},{"location":"Graphes/Graphes/#matrice-dadjacence-sommets-sommets","title":"Matrice d\u2019adjacence sommets-sommets","text":"<p>D\u00e9finition: Matrice d'adjacence</p> <p>Soit \\(G = (V, E)\\) un graphe fini simple. Notons \\(\\{v_1,..., v_n\\}\\) les sommets de \\(S\\). On appelle matrice d\u2019adjacence sommets-sommets de \\(G = (V, E)\\) la matrice \\(A_{n\u00d7n} = (a_{ij})_1{\u2264i,j\u2264n}\\) telle que</p> \\[ a_{ij} =  \\begin{equation} \\nonumber     \\begin{cases}         1 \\text{ si il existe un arc de } v_i \\text{ \u00e0 } v_j\\\\         0 \\text{ sinon}     \\end{cases} \\end{equation} \\] <p>Remarque</p> <ul> <li>La matrice d\u2019adjacence d\u00e9pend de la num\u00e9rotation des sommets. Il  faut que cette num\u00e9rotation soit connue pour comprendre la matrice.  </li> <li>\\(A\\)    une num\u00e9rotation des sommets correspond une unique matrice  d\u2019ajacence sommets-sommets.  </li> <li>Inadapt\u00e9e pour les ar\u00eates (ou les arcs) multiples. Pr\u00e9sence de boucle  si \\(a_{ii} = 1\\).  Graphe non orient\u00e9 \\(\\Rightarrow\\) matrice sym\u00e9trique.  </li> </ul>"},{"location":"Graphes/Graphes/#liste-dadjacence","title":"Liste d\u2019adjacence","text":"<p>D\u00e9finition: Liste d'adjacence</p> <p>Soit \\(G = (V, E)\\) un graphe fini simple.</p> <p>On appelle liste d\u2019adjacence de \\(G\\) toute liste de couples \\((s, l)\\) o\u00f9 \\(s\\) parcourt \\(V\\) et \\(l\\) est une liste de ses voisins.</p> <p>Remarque</p> <p>Si une num\u00e9rotation des sommets est choisie, on peut se contenter de donner la liste des voisins. La premi\u00e8re liste donne les voisins du premier sommet, la seconde celle du second sommet etc...</p>"},{"location":"Graphes/Graphes/#exemple-de-repesentation","title":"Exemple de rep\u00e9sentation","text":""},{"location":"Graphes/Graphes/#cas-non-oriente","title":"Cas non orient\u00e9","text":"<p>Figure - Un graphe \u00e9tiquet\u00e9 non orient\u00e9</p>"},{"location":"Graphes/Graphes/#matrice-dadjacence","title":"Matrice d'adjacence","text":"<p>Matrice sym\u00e9trique</p> \\[\\begin{pmatrix}0 &amp; 1 &amp; 1 &amp; 1\\\\1 &amp; 0 &amp; 0 &amp; 0\\\\1 &amp; 0 &amp; 0 &amp; 1\\\\1 &amp; 0 &amp; 1 &amp; 0\\end{pmatrix}\\]"},{"location":"Graphes/Graphes/#liste-dadjacence_1","title":"Liste d'adjacence","text":"<p><pre><code>[(\u2019A\u2019, [\u2019B\u2019, \u2019C\u2019, \u2019D\u2019]), (\u2019B\u2019, [\u2019A\u2019]), (\u2019C\u2019, [\u2019A\u2019, \u2019D\u2019]), (\u2019D\u2019, [\u2019C\u2019, \u2019A\u2019])]\n</code></pre> ou <pre><code>[[\u2019B\u2019, \u2019C\u2019, \u2019D\u2019], [\u2019A\u2019], [\u2019A\u2019, \u2019D\u2019], [\u2019C\u2019, \u2019A\u2019]]\n</code></pre></p>"},{"location":"Graphes/Graphes/#cas-oriente","title":"Cas orient\u00e9","text":"<p>Figure - Un graphe \u00e9tiquet\u00e9 orient\u00e9</p>"},{"location":"Graphes/Graphes/#matrice-dadjacence_1","title":"Matrice d'adjacence","text":"<p>Matrice non sym\u00e9trique</p> \\[\\begin{pmatrix}0 &amp; 1 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\\\1 &amp; 0 &amp; 0 &amp; 0\\end{pmatrix}\\]"},{"location":"Graphes/Graphes/#liste-dadjacence_2","title":"Liste d'adjacence","text":"<p><pre><code>[(\u2019A\u2019, [\u2019B\u2019, \u2019C\u2019]), (\u2019B\u2019,[]), (\u2019C\u2019, [\u2019D\u2019]), (\u2019D\u2019,[\u2019A\u2019])] \n</code></pre> ou <pre><code>[[\u2019B\u2019, \u2019C\u2019], [], [\u2019D\u2019], [\u2019A\u2019]]\n</code></pre></p>"},{"location":"Graphes/Graphes/#matrices-dadjacence-quelle-representation","title":"Matrices d\u2019adjacence : quelle repr\u00e9sentation ?","text":"<p>En Ocaml ou C, les matrices d\u2019adjacence sont simplement  repr\u00e9sent\u00e9es par des matrices carr\u00e9es c.a.d. des tableaux \u00e0 deux  dimensions avec m\u00eame nombre de lignes que de colonnes.  </p> <p>A la place de 0 et de 1, on peut utiliser des boul\u00e9ens.  </p> <p>Implicitement on consid\u00e8re que les sommets sont des nombres. Ou  alors on dispose d\u2019un tableau de correspondance entre les sommets et  leurs num\u00e9ros (utile si les sommets contiennent des informations).  </p> <p>Avec un tel choix :  </p> <ul> <li>il est facile de supprimer ou d\u2019ajouter un arc entre deux sommets  existants.  </li> <li>On teste en \\(O(1)\\) si deux sommets sont voisins.  </li> <li>Ajouter un sommet n\u00e9cessite en g\u00e9n\u00e9ral une copie de la matrice  (complexit\u00e9 quadratique).  </li> <li>Place m\u00e9moire perdue importante si beaucoup de sommets et matrice  creuse.  </li> </ul>"},{"location":"Graphes/Graphes/#listes-dadjacence-en-ocaml-quelle-representation","title":"Listes d\u2019adjacence en Ocaml : quelle repr\u00e9sentation ?","text":"<p>En Ocaml pour un graphe \\(G = (V, E)\\) : On peut consid\u00e9rer une liste \\(L\\) de longueur \\(|V|\\) de tuples \\((s, l)\\) ou \\(s\\) est un sommet et \\(l\\) la liste des voisins de \\(s\\).  </p> <ul> <li>Avantages : pas de place m\u00e9moire perdue ; possibilit\u00e9 d\u2019ajouter un  nouveau sommet apr\u00e8s avoir v\u00e9rifi\u00e9 que ce sommet n\u2019est pas d\u00e9j\u00e0 dans  la liste.  </li> <li>Inconv\u00e9nients : Acc\u00e8s \u00e0 la liste d\u2019adjacence de \\(s\\) en \\(O(|V|)\\) ; test de voisinage entre \\(s\\) et \\(x\\) en \\(O(|V| + deg (s))\\) ; ajout d\u2019un arc \\((s, x)\\) en  \\(O(|V| + deg (s))\\).  </li> </ul> <p>On peut pr\u00e9ferer g\u00e9rer un tableau de listes \\(l\\) plut\u00f4t qu\u2019une liste de  tuples (les sommets sont alors des nombres).  </p> <ul> <li>Avantage : l\u2019acc\u00e8s \u00e0 la liste d\u2019adjacence de \\(s\\) est en \\(O(1)\\) ; test de voisinage avec \\(x\\) en \\(O(deg (s))\\); ajout d\u2019un arc \\((s, x)\\) en \\(O(deg (s))\\) (il faut v\u00e9rifier que l\u2019arc n\u2019est pas d\u00e9j\u00e0 pr\u00e9sent - usage de list.mem -).  </li> <li>Inconv\u00e9nient : pour ajouter un sommet, il faut recopier le tableau.  </li> </ul>"},{"location":"Graphes/Graphes/#listes-dadjacence-en-c-quelle-representation","title":"Listes d\u2019adjacence en C : quelle repr\u00e9sentation ?","text":""},{"location":"Graphes/Graphes/#tableau-de-liste-de-chaines","title":"Tableau de liste de cha\u00eenes","text":"<p>Dans le m\u00eame esprit qu\u2019en Ocaml, pour repr\u00e9senter \\(G = (V, E)\\) Tableau \\(t\\) des successeurs de chaque sommet. \\(t[i]\\) pointe sur la liste des sucesseurs du sommet \\(i\\). Acc\u00e8s direct \u00e0 un sommet via \\(t\\). Complexit\u00e9 spatiale optimale en \\(O(|E| + |V|)\\) </p> <p></p> <p>Figure \u2013 Un tableau de liste cha\u00een\u00e9e de successeurs. (F. Pesseaux)</p> <pre><code>typedef int edge_val ;// \u00e9tiquette sur les arcs\ntypedef int vertex_name_t ;//nom des sommet\n\nstruct edge_list_t {// liste de voisins = extr\u00e9mit\u00e9s d\u2019 arcs\n    int dest ;\n    edge_val data ;// \u00e9tiquette sur l' arc\n    struct edge_list_t \u2217 next;\n};\n\nstruct vertex_t {\n    vertex_name_t name ;// nom du sommet\n    struct edge_list_t \u2217 edges;// liste de voisins\n};\n\nstruct graph_t {\n    int nb_vertices ;\n    struct vertex_t \u2217 vertices [ MAX VERTICES ];\n};\n</code></pre> <ul> <li>ici il y a des \u00e9tiquettes sur les  arcs;</li> <li>si nom \\(\u2260\\) index de tableau : besoin d'une fonction nom \\(\\rightarrow\\) index</li> </ul>"},{"location":"Graphes/Graphes/#partage-physique-des-sommets","title":"Partage physique des sommets","text":"<p>On peut aussi partager physiquement les sommets. - Chaque sommet est repr\u00e9sent\u00e9 1 et 1 seule fois. - Chaque sommet est associ\u00e9 \u00e0 une liste dont les \u00e9l\u00e9ments pointent sur  ses successeurs.  </p> <p></p> <p>Figure \u2013 Partage physique des donn\u00e9es (F.Pesseaux)</p> <pre><code>struct vertex_list_t ;\nstruct vertex_t ;\n\nstruct vertex_t {\n    vertex_name_t name ;    //nom\n    struct vertex_list_t\u2217 neighbours;   // liste de sommets voisins\n    bool seen ;    // visit\u00e9 / pas visit\u00e9\n};\n\nstruct vertex_list_t {\n    struct vertex_t\u2217 vertex ;   // sommet\n    struct vertex_list_t\u2217 next; // pointeur sur liste de sommets\n};\n\nstruct graph_t{\n    int nb vertices ;\n    struct vertex_list_t\n};\n</code></pre> <ol> <li> <p>Chaque sommet vient avec son nom, un pointeur sur sa liste de sommets voisins (qui est une liste de pointeurs sur sommets) et une \u00e9tiquette (visit\u00e9 ou non) ;</p> </li> <li> <p>une liste de sommets contient un pointeur sur sommet et un pointeur sur le mailllon suivant.</p> </li> </ol>"},{"location":"Graphes/Graphes/#sous-graphes","title":"Sous-graphes","text":"<p>Convention : \\(V\\) pour vertice, \\(E\\) pour edge.  </p> <ul> <li> <p>Un sous-graphe est un graphe contenu dans un autre graphe :  \"\\(H = (V_H, E_H)\\) est un sous-graphe de \\(G = (V_G, E_G)\\) si \\(V_H \u2282 V_G\\),  \\(E_H \u2282 E_G\\) et pour tout arc (resp. ar\u00eate) de \\(E_H\\), les extr\u00e9mit\u00e9s sont  dans \\(V_H\\)\". On supprime des arcs et des sommets avec la contrainte qu\u2019il ne faut pas conserver d\u2019arc dont une extr\u00e9mit\u00e9 a \u00e9t\u00e9 supprim\u00e9e de l\u2019ensemble des sommets.</p> </li> <li> <p>Un sous-graphe couvrant (ou graphe partiel) est un sous-graphe ayant  le m\u00eame ensemble de sommets que le graphe qui le contient.  \"\\(H\\) est un sous-graphe couvrant de \\(G\\) (ou \\(H\\) couvre \\(G\\)) si \\(V_H = V_G\\)  et \\(E_H \u2282 E_G\\).\"  On garde tous les sommets, on enl\u00e8ve certains arcs.</p> </li> <li> <p>Un sous-graphe induit est un sous-graphe d\u00e9fini par un sous ensemble  de sommets.  \"H est un sous-graphe induit de \\(G\\) si, pour tout \\((x, y) \\in V_H^2\\), l\u2019existence d\u2019un lien entre \\(x\\) et \\(y\\) dans \\(H\\) est \u00e9quivalente \u00e0 l\u2019existence  d\u2019un lien entre \\(x\\) et \\(y\\) dans \\(G\\).\" On enl\u00e8ve des sommets, toutes les ar\u00eates correspondant \u00e0 ces sommets et uniquement celles-l\u00e0.</p> </li> </ul> <p>Exemples</p> <p><p></p></p>"},{"location":"Graphes/Graphes/#chaines-et-chemins-connexite","title":"Cha\u00eenes et chemins, connexit\u00e9","text":""},{"location":"Graphes/Graphes/#accessibilite","title":"Accessibilit\u00e9","text":""},{"location":"Graphes/Graphes/#chaines-et-chemins","title":"Cha\u00eenes et Chemins","text":"<p>Soit \\(G = (V, E)\\) un graphe.  </p> <ul> <li>Un chemin d\u2019un sommet \\(x\\) \u00e0 un sommet \\(y\\) est une s\u00e9quence de (au  moins 2) sommets \\(x = x_0, x_1,..., x_{n\u22121}, x_n\\) = y dans laquelle chaque \\(x_i\\)  admet \\(x_{i+1}\\) pour voisin.  </li> <li>Un sommet \\(y\\) est accessible depuis \\(x\\) s\u2019il existe un chemin de \\(x\\) \u00e0 \\(y\\).  </li> <li>La longueur d\u2019un chemin est \u00e9gale au nombre d\u2019ar\u00eates qui la  constituent.  </li> <li>Un chemin simple est une chemin qui ne contient pas plusieurs fois  une m\u00eame ar\u00eate/arc (on dit aussi eul\u00e9rien).  </li> <li>Un chemin \u00e9l\u00e9mentaire est une chemin qui ne passe pas plusieurs fois  par un m\u00eame sommet.  </li> <li>\u00e9l\u00e9mentaire \\(\\Rightarrow\\) simple.  </li> <li>En CPGE, les cha\u00eenes sont souvent \u00e9l\u00e9mentaires (pas de doublon de  sommet sauf pour d\u00e9finir les cycles).  </li> <li>Certains auteurs utilisent le mot cha\u00eene pour d\u00e9signer les chemins  dans les graphes non orient\u00e9s.  </li> </ul>"},{"location":"Graphes/Graphes/#cycles-et-circuits","title":"Cycles et circuits","text":"<ul> <li> <p>Un chemin est dit simple si chacun de ses arcs/ar\u00eates  n\u2019est emprunt\u00e9 qu\u2019une fois.</p> </li> <li> <p>Un cycle \\(x_0, x_1,..., x_n\\) est un chemin dont les extr\u00e9mit\u00e9s sont  confondues : \\(\\color{red}\\text{dans l\u2019immense majorit\u00e9 des cas, on impose qu\u2019il soit simple}\\), c\u2019est \u00e0 dire qu\u2019aucun arc/ar\u00eate n\u2019y figure deux fois.  </p> </li> <li>Remarque : le sommet r\u00e9p\u00e9t\u00e9 peut varier. Le cycle \\(x_0\\) , \\(x_1\\) , \\(x_2\\) , \\(x_0\\) est consid\u00e9r\u00e9 comme \u00e9gal au cycle \\(x_1\\) , \\(x_2\\) , \\(x_0\\) , \\(x_1\\).</li> <li>Un cycle est dit \u00e9l\u00e9mentaire si, lorsqu\u2019on enl\u00e8ve un arc quelconque et une extr\u00e9mit\u00e9 de cet arc, le chemin restant est \u00e9l\u00e9mentaire.  </li> <li>Un graphe est acyclique s\u2019il ne poss\u00e8de aucun cycle.  </li> <li>Certains auteurs distinguent la notion de circuit (pour les graphes orient\u00e9s) de celle de cycle (pour les graphes non orient\u00e9s). Dans un graphe non orient\u00e9, la plupart du temps, on consid\u00e8re qu\u2019un cycle est simple et poss\u00e8de au moins 3 ar\u00eates (les boucles ne sont alors pas consid\u00e9r\u00e9es comme des cycles).</li> </ul>"},{"location":"Graphes/Graphes/#existence-de-chemin-elementaire-propriete-de-konig","title":"Existence de chemin \u00e9l\u00e9mentaire (Propri\u00e9t\u00e9 de  K\u00f6nig)","text":"<p>Proposition S\u2019il existe un chemin de \\(x\\) \u00e0 \\(y\\) dans le graphe \\(G = (V , E )\\), alors il existe un chemin \u00e9l\u00e9mentaire de \\(x\\) \u00e0 \\(v\\) .</p> <p>Preuve en TD.</p>"},{"location":"Graphes/Graphes/#distance-et-diametre","title":"Distance et diam\u00e8tre","text":"<p>La distance entre deux sommets \\(x\\) et \\(y\\) d\u2019un graphe \\(G = (V, E)\\)  orient\u00e9 (resp. non orient\u00e9) est not\u00e9e \\(d_G (x, y)\\) et est \u00e9gale \u00e0 la longueur d\u2019un plus court chemin (resp. cha\u00eene) allant de \\(x\\) \u00e0 \\(y\\) s\u2019il en  existe un ou bien \\(+\\infty\\) sinon.</p> <p>Il s\u2019agit bien d\u2019une distance au sens math\u00e9matiques. En particulier,  elle v\u00e9rifie l\u2019in\u00e9galit\u00e9 triangulaire  </p> \\[ \\forall (x, y, z) \\in S^3, d_G (x, z) \\leq d_G (x, y) + d_G (y, z) \\] <p>Le diam\u00e8tre d\u2019un graphe \\(G\\) est la valeur : \\(sup_{(x,y) \\in S^2} (d_G (x, y))\\). C\u2019est \"la longueur du plus long plus court chemin entre deux sommets\".  </p>"},{"location":"Graphes/Graphes/#connexite","title":"Connexit\u00e9","text":""},{"location":"Graphes/Graphes/#relation-de-connexite","title":"Relation de connexit\u00e9","text":"<ul> <li>La connexit\u00e9 dans un graphe non orient\u00e9 est une relation binaire entre  deux sommets : \\(x\\) et \\(y\\) sont en relation de connexit\u00e9 si et seulement si  \\(y\\) est accessible depuis \\(x\\).  </li> <li>Comme le graphe est non orient\u00e9, si \\(y\\) est accessible depuis \\(x\\), alors \\(x\\)  est accessible depuis \\(y\\).</li> <li>La connexit\u00e9 est une relation d\u2019\u00e9quivalence.  </li> <li>Les classes d\u2019\u00e9quivalences sont appel\u00e9es composantes connexes. La composante connexe d\u2019un sommet \\(x\\) est not\u00e9e ici \\(\\dot{x}\\) et vaut :  </li> </ul> \\[\\dot{x} = \\{y \u2208 V| \\text{ il existe une cha\u00eene de x \u00e0 y }\\}\\] <ul> <li>Un graphe est dit connexe si il poss\u00e8de une seule composante  connexe.</li> <li>La connexit\u00e9 est \u00e9tendue aux graphes orient\u00e9s en ne tenant pas compte du sens des arcs.  </li> </ul>"},{"location":"Graphes/Graphes/#relation-de-forte-connexite","title":"Relation de forte connexit\u00e9","text":"<p>La relation de forte connexit\u00e9 est une relation binaire entre sommets  d\u2019un graphe orient\u00e9 : \\(x\\) et \\(y\\) sont en relation de forte connexit\u00e9 si et  seulement si  </p> <ul> <li>il existe un chemin de \\(x\\) \u00e0 \\(y\\) et il existe un chemin de \\(y\\) \u00e0 \\(x\\) </li> <li>ou bien \\(x = y\\).  </li> </ul> <p>\\(\\color{red}\\text{Il peut y avoir un chemin de }x\\text{ \u00e0 }y\\text{ sans chemin de }y\\text{ \u00e0 }x{.}\\)</p> <p>Les classes d\u2019\u00e9quivalence de la relation de forte connexit\u00e9 sont  appel\u00e9es composantes fortement connexes. La composante fortement connexe de \\(x\\), not\u00e9e ici \\(\\tilde{x}\\) vaut :  </p> \\[ \\tilde{x} = \\{y \\in S| \\text{ il existe un chemin de $x$ \u00e0 $y$ et de $y$ \u00e0 $x$} \\} \\] <p>Elle v\u00e9rifie \\(\\tilde{x} \u2282 \\dot{x}\\). L\u2019inclusion r\u00e9ciproque est en g\u00e9n\u00e9ral fausse.</p> <p>On dit qu\u2019un graphe est fortement connexe si et seulement si il est  constitu\u00e9 d\u2019une seule composante fortement connexe, c\u2019est \u00e0 dire si  pour tout couple de sommet \\((x, y)\\) il existe un chemin allant de \\(x\\) \u00e0 \\(y\\)  et r\u00e9ciproquement.  </p> <p>Connexit\u00e9 : exemple</p> <pre><code>graph TB; \n    A((S1))--&gt;B((S8))\n    D((S7))--&gt;B\n    A--&gt;D\n    J((S10))--&gt;C((S2))\n    C--&gt;A\n    C--&gt;D\n    J--&gt;B\n    E((S3))--&gt;C\n    E--&gt;H((S5))\n    H--&gt;G((S4))\n    G--&gt;E\n    F((S6))--&gt;C\n    D--&gt;F\n    H--&gt;F</code></pre> <p>Graphe connexe (quand on ne consid\u00e8re pas le sens des \ufb02\u00e8ches).</p> <p>\\(S8\\) est accessible depuis tous les sommets.  \\(\\tilde{S8} = \\{S8\\}\\). Donc le graphe n\u2019est pas fortement connexe, sinon \\(\\tilde{S8}\\)  contiendrait tous les sommets.  </p> <ul> <li>Sommets accessibles(qui partent de \\(S2\\)) depuis \\(S2 : \\{S1, S2, S6, S7, S8\\}\\).  </li> <li>Sommets coaccessibles(qui viennent vers \\(S2\\)) depuis \\(S2 : \\{S1, S2, S3, S4, S5, S6, S7, S10\\}\\).  </li> <li>\\(\\tilde{S2} = \\{S1, S2, S6, S7\\}\\) est l\u2019intersection des accessibles et des  coaccessibles.  </li> </ul>"},{"location":"Graphes/Graphes/#isthme","title":"Isthme","text":"<p>D\u00e9finition: Isthme</p> <p>Une ar\u00eate \\(u\\) d\u2019un graphe \\(G\\) non orient\u00e9 est appel\u00e9e un isthme si sa suppression met ses extr\u00e9mit\u00e9s dans deux composantes connexes  di\ufb00\u00e9rentes (donc la suppression augmente le nombre de composante  connexes du graphe).  </p> <p></p> <p>Une seule composante connexe.</p> <p></p> <p>Deux composantes connexes apr\u00e8s suppression de \\(\\{S_4, S_5\\}\\).</p> <p>Proposition</p> <p>Soit \\(G\\) un graphe non orient\u00e9. Une ar\u00eate \\(u\\) est un isthme si et seulement si \\(u\\) n\u2019appartient \u00e0 aucun cycle  de \\(G\\).  </p> <p>Preuve</p> <p>Soit \\(u = \\{x, y\\}\\) une ar\u00eate avec \\(x \\neq y\\). On montre que \\(u\\) est un isthme si et  seulement si \\(u\\) n\u2019appartient \u00e0 aucun cycle de \\(G\\). </p> <ul> <li>Supposons que \\(u\\) soit un isthme. Supprimer \\(u\\) met \\(x\\), \\(y\\) dans deux  composantes connexes di\ufb00\u00e9rentes. Cela veut dire qu\u2019il n\u2019existe pas de  chemin de \\(x\\) \u00e0 \\(y\\) qui ne passe pas par \\(u\\). Et donc, \\(u\\) n\u2019est sur aucun  cycle.  </li> <li>Si \\(u\\) n\u2019appartient \u00e0 aucun cycle, supposons qu\u2019il y ait un chemin  allant de \\(x\\) \u00e0 \\(y\\) ne passant pas par \\(u\\) (on peut le prendre \u00e9l\u00e9metaire). En y ajoutant \\(u\\), on obtient un cycle passant par \\(u\\) : ABSURDE. Si on supprime \\(u\\), on ne peut donc plus joindre \\(y\\) depuis \\(x\\). Alors \\(x\\), \\(y\\)  sont dans deux \\(CC\\) di\ufb00\u00e9rentes. On en d\u00e9duit que \\(u\\) est un istme.  </li> </ul>"},{"location":"Graphes/Graphes/#nombre-daretes-et-de-sommets","title":"Nombre d\u2019ar\u00eates et de sommets","text":"<p>Proposition</p> <p>Soit \\(G\\) un graphe non orient\u00e9 sans boucle de \\(n\\) sommets et \\(p\\) ar\u00eates.  </p> <ul> <li>\\(G\\) connexe \\(\\Rightarrow p \u2265 n \u2212 1\\),  </li> <li>\\(G\\) acyclique (i.e. pas de cycle simple) \\(\\Rightarrow p \u2264 n \u2212 1\\).  </li> </ul> <p>Corollaire</p> <p>Si \\(G\\) non orient\u00e9 sans boucle est acyclique connexe, alors \\(p = n \u2212 1\\).</p> <p>Remarque Ce sont des conditions n\u00e9cessaires, pas suffisantes (exo : donner des contre-exemples).</p> <p>Preuve</p>"},{"location":"Graphes/Graphes/#si-g-v-e-non-oriente-est-connexe-p-n-1","title":"Si \\(G = (V, E)\\) non orient\u00e9 est connexe, \\(p \u2265 n \u2212 1\\)","text":"<p>Par r\u00e9currence forte :</p> <ul> <li>Vrai si \\(n = 1\\). Alors \\(p \u2265 0\\). Le graphe est connexe et \\(p \u2265 n \u2212 1\\) </li> <li>Si \\(n = 2\\), il faut qu\u2019il y ait une ar\u00eate entre les deux sommets pour que  le graphe soit connexe. Alors \\(p \u2265 1 = n \u2212 1\\).  </li> <li>Cas de base : OK. (Remarque : on pourrait ajouter des boucles \u00e7a ne  changerait rien).  </li> <li> <p>Si \\(P(k)\\) pour \\(n \u2265 2\\) et tout \\(k \u2264 n\\). Soit \\(G\\) connexe \u00e0 \\(n + 1\\) sommets. Tout sommet poss\u00e8de au moins une ar\u00eate incidente car \\(G\\) est connexe.  </p> <ul> <li>Si \\(G\\) poss\u00e8de un sommet \\(x\\) de degr\u00e9 \\(d(x) = 1\\), \\(x\\) n\u2019est sur aucune  cha\u00eene simple joignant deux autres sommets. On supprime \\(x\\) et son  unique arr\u00eate adjacente, le sous-graphe \\(G'\\) obtenu est connexe \u00e0 \\(n\\)  sommets. Par HR le nombre d\u2019ar\u00eates de \\(G'\\) est \\(p' \u2265 n \u2212 1\\). En  remettant l\u2019ar\u00eate de \\(x\\), on a au moins \\((n + 1) \u2212 1\\) ar\u00eates dans \\(G\\).  </li> <li>Sinon, tous les degr\u00e9s sont \\(\u2265 2\\). La somme des degr\u00e9s dans un graphe est \\(\\sum_{x \\in V}d(x) = 2p\\) car toutes les ar\u00eates sont compt\u00e9es deux fois. On  a donc  $$2p = \\sum_{x \\in V} \\underbrace{d(x)}_{\\geq 2} \\geq 2|V| = 2n+2 $$  Donc \\(p \\geq n+1 \\geq (n+1) - 1\\). OK</li> </ul> </li> </ul>"},{"location":"Graphes/Graphes/#si-g-est-non-oriente-sans-boucle-a-au-moins-n-aretes-il-nest-pas-acyclique","title":"Si \\(G\\) est non orient\u00e9 sans boucle a au moins \\(n\\) ar\u00eates, il n\u2019est pas acyclique","text":"<p>On raisonne par contrapos\u00e9e sur \\(\\text{G acyclique} \\Rightarrow p \\leq n-1\\).</p> <ul> <li>Pr\u00e9cisons : pas de cycle simple : \\(x_0 , x_1 , x_0\\) n\u2019est pas un cycle car la m\u00eame ar\u00eate est emprunt\u00e9 deux fois</li> <li>Si le graphe (qui est sans boucle) a au plus deux sommets, il ne poss\u00e8de pas de cycle simple puisqu\u2019il y a au plus une ar\u00eate qu\u2019on ne peut pas emprunter deux fois (en CPGE, il n\u2019y a pas de multigraphe : il existe au plus une ar\u00eate entre deux sommets).</li> <li>Pour \\(n = 3\\). S\u2019il y a 3 ar\u00eates, le graphe tout entier est un cycle.</li> </ul> <p>On consid\u00e8re des graphes non orient\u00e9s \u00e0 au moins 3 sommets. On raisonne par r\u00e9currence forte sur \\(|G| = n\\).  </p> <ul> <li>Cas de base \\(n = 3\\). S\u2019il y a 3 ar\u00eates, le graphe tout entier est un cycle.  </li> <li> <p>Supposons \\(P(k)\\) pour \\(k \u2265 3\\) et tout \\(k \u2264 n\\). Soit \\(G\\) \u00e0 \\(n + 1\\) sommets et  \\(p = n + 1\\) ar\u00eates. On montre qu\u2019il poss\u00e8de un cycle.  Consid\u00e9rons un  sommet quelconque \\(x\\).  </p> <ul> <li>S\u2019il n\u2019y a pas d\u2019ar\u00eate incidente \u00e0 \\(x\\), le graphe priv\u00e9 de \\(x\\) a \\(n\\) sommets  et \\(n + 1\\) ar\u00eates. Il y a un cycle par HR.  </li> <li> <p>Si il existe une ar\u00eate incidente \u00e0 \\(x\\) qui n\u2019est pas un isthme elle est  alors sur un cycle et \\(G\\) poss\u00e8de donc un cycle : OK.  </p> </li> <li> <p>Si toutes ar\u00eate \\(x\\)-incidente est un isthme, soit \\(u = \\{x, y\\} \\in E\\).  Retirons \\(u\\). Alors \\(x\\) se retrouve dans une composante connexe  di\ufb00\u00e9rente de celle de \\(y\\). S\u00e9parons la composante connexe de \\(x\\) et ses ar\u00eates (formant un sous graphe \\(G_1\\)) du reste du graphe (notons \\(G_2\\) ce reste).  </p> <ul> <li>\\(G_1\\) poss\u00e8de, disons \\(k\\) sommets \\((1 \u2264 k &lt; n + 1)\\), l\u2019autre \\(n + 1 \u2212 k\\). \\(G_1\\) poss\u00e8de \\(q_1\\) ar\u00eates et \\(G_2\\) en a \\(q_2\\) avec \\(q_1 + q_2 = n\\).  </li> <li>Si \\(q_1 \u2265 k\\), il y a un cycle dans \\(G_1\\) par HR donc dans \\(G\\) puisque \\(G_1\\) est  un sous-graphe de \\(G\\) : Prouv\u00e9.  </li> <li>Sinon, \\(q_2 = n \u2212 q_1 &gt; n \u2212 k\\) donc \\(q_2 \u2265 (n \u2212 k) + 1\\) et le sous-graphe \\(G\\) par HR a un cycle donc \\(G\\) aussi. CQFD </li> </ul> </li> </ul> </li> </ul>"},{"location":"Graphes/Graphes/#caracterisation-des-arbres-non-enracines","title":"Caract\u00e9risation des arbres non enracin\u00e9s","text":"<p>D\u00e9finition : Arbre non enracin\u00e9</p> <p>On appelle arbre non enracin\u00e9 tout graphe non orient\u00e9 sans boucle acyclique et connexe.</p> <p>Remarque</p> <p>On dit en g\u00e9n\u00e9ral arbre plut\u00f4t que arbre non enracin\u00e9 mais cette appelation am\u00e8ne des confusions avec la notion d\u2019arbre d\u00e9finie inductivement des chapitres pr\u00e9c\u00e9dents.</p> <p>Proposition</p> <p>Soit un graphe non orient\u00e9 sans boucle \\(G\\) de \\(n\\) sommets et \\(p\\) ar\u00eates, les  a\ufb03rmations suivantes sont \u00e9quivalentes : - \\(G\\) est un arbre non enracin\u00e9, - \\(G\\) est acyclique et contient \\(n \u2212 1\\) ar\u00eates \\((p = n \u2212 1)\\), - \\(G\\) est connexe et contient \\(p + 1\\) sommets.  </p> <p>On a d\u00e9j\u00e0 vu les sens directs.  </p> <p>Preuve</p>"},{"location":"Graphes/Graphes/#si-g-acyclique-et-p-n-1","title":"Si \\(G\\) acyclique et \\(p = n \u2212 1\\)","text":"<p>Si \\(x\\), \\(y\\) sont deux \u00e9l\u00e9ments non reli\u00e9s par un chemin, on ajoute l\u2019ar\u00eate  \\(\\{x, y \\}\\)  Cela cr\u00e9e un cycle puisque le nombre d\u2019ar\u00eate est \u00e9gal \u00e0 celui des  sommets. Ce nouveau cycle passe par l\u2019ar\u00eate \\(\\{x, y\\}\\) (avant, il n\u2019y en avait pas). Puisque cycle il y a, c\u2019est que \\(x\\) et \\(y\\) sont joignables sans passer par  \\(\\{x, y\\}\\) : ABSURDE Donc pour tous sommets \\(x\\) et \\(y\\), il y a un chemin de l'un \u00e0 l'autre : \\(G\\) est donc connexe</p>"},{"location":"Graphes/Graphes/#si-g-est-connexe-et-p-n-1","title":"Si \\(G\\) est connexe et \\(p = n \u2212 1\\)","text":"<p>Si \\(G\\) poss\u00e8de un cycle, soit \\(\\{x, y \\}\\) une ar\u00eate de ce cycle. Alors il y a un autre chemin de \\(x\\) \u00e0 \\(y\\) que cette ar\u00eate. Donc on peut  enlever l\u2019ar\u00eate \\(\\{x, y \\}\\) en conservant le caract\u00e8re connexe. Mais alors le nouveau graphe \\(G'\\) est encore connexe et poss\u00e8de \\(n\\)  sommets et \\(n \u2212 2\\) ar\u00eates. ABSURDE  Alors \\(G\\) est aussi acyclique. Et comme graphe connexe acyclique N.O., \\(G\\) est un arbre.</p>"},{"location":"Graphes/Graphes/#graphes-particuliers","title":"Graphes particuliers","text":""},{"location":"Graphes/Graphes/#arbres-et-forets","title":"Arbres et for\u00eats","text":"<p>Pour certains auteurs, un arbre est un graphe non orient\u00e9 connexe et  acyclique. S\u2019il a \\(n\\) sommets, il poss\u00e8de donc \\(n \u2212 1\\) ar\u00eates. Comme il y a con\ufb02it avec la d\u00e9finition du cours, ces graphes non  orient\u00e9s connexes acycliques sont dits arbres non enracin\u00e9s (on l\u2019a  d\u00e9j\u00e0 vu). \u00c0 contrario, on parle des objets du premier chapitre (d\u00e9finis  inductivement) comme des arbres.  </p> <p>Dans un arbre non enracin\u00e9, on peut choisir une racine. Il y a alors un  chemin unique de la racine \u00e0 tous les sommets (cela se montre). La  pr\u00e9sence de la racine induit alors une orientation.  La structure ainsi construite est ce que certains auteurs appellent  arborescence ou arbre enracin\u00e9 (cf def \\(\\color{red}6\\))  </p> <p>Une arborescence n\u2019est pas encore un des objets que nous manipulons  sous le nom d\u2019arbres. Il n\u2019y a pas, dans les arborescences de notion  comme fils gauche et fils droit. Il manque une notion de lat\u00e9ralisation.  </p>"},{"location":"Graphes/Graphes/#forets","title":"For\u00eats","text":"<p>Une for\u00eat est un graphe non orient\u00e9 acyclique, c\u2019est une union disjointe  d\u2019arbres non enracin\u00e9s (qui en sont les composantes connexes).  </p> <p>Exemple</p> <p><p></p></p>"},{"location":"Graphes/Graphes/#racine-arborescence","title":"Racine, arborescence","text":"<p>D\u00e9finition: Racine et Arborescence</p> <p>Un sommet \\(r\\) d\u2019un graphe orient\u00e9 \\(G = (V , E)\\) est une racine de \\(G\\) si  pour tout sommet \\(x\\) de \\(G\\) il existe un chemin de \\(r\\) \u00e0 \\(x\\).  </p> <p>On dit qu\u2019un graphe orient\u00e9 \\(G = (V , E)\\) est une arborescence s\u2019il  poss\u00e8de un unique \u00e9l\u00e9ment \\(x_0\\) de degr\u00e9 entrant nul, si tous les autres  sont de degr\u00e9 entrant 1 et si il existe un chemin de \\(x_0\\) \u00e0 tous les  autres sommets.  </p> <p>Exemple</p> <p><p></p></p>"},{"location":"Graphes/Graphes/#graphes-non-orientes-particuliers","title":"Graphes non orient\u00e9s particuliers","text":""},{"location":"Graphes/Graphes/#statut-de-cette-section","title":"Statut de cette section","text":"<p>Cette section donne quelques exemples de graphes particuliers sans  qu\u2019aucune preuve ne soit donn\u00e9e.  </p>"},{"location":"Graphes/Graphes/#etoiles-peignes-chenilles","title":"Etoiles, peignes, chenilles","text":"<p>Etoile : Un arbre dont un sommet est adjacent \u00e0 tous les autres.</p> <p></p> <p>Chenille : arbre tel que tout sommet de degr\u00e9 \\(\\geq 2\\) est adjacent \u00e0 au plus deux sommets de degr\u00e9 \\(\\geq 2\\).</p> <p></p> <p>Peigne : Bon j'ai vraiment besoin de d\u00e9crire \u00e7a ?</p> <p></p>"},{"location":"Graphes/Graphes/#graphe-planaire","title":"Graphe planaire","text":"<p>Un graphe est planaire  si on peut le dessiner sans  qu\u2019aucune ar\u00eate n\u2019en coupe  une autre.  </p> <p>4-coloriabilit\u00e9 :  les sommets d\u2019un graphe planaire  peuvent \u00eatre colori\u00e9s  avec 4 couleurs sans  que deux sommets adjacents  ne soient de la m\u00eame couleur.  </p> <p></p>"},{"location":"Graphes/Graphes/#graphe-complet-tournoi","title":"Graphe complet, tournoi","text":"<p>Un graphe complet est un graphe  non orient\u00e9 o\u00f9  tous les sommets sont deux \u00e0 deux adjacents.  </p> <p></p> <p>Un tournoi est un graphe orient\u00e9  obtenu \u00e0 partir d\u2019un graphe complet  en orientant chaque ar\u00eate.  </p>"},{"location":"Graphes/Graphes/#graphe-biparti","title":"Graphe biparti","text":"<p>Un graphe biparti \\(G = (V , E)\\)  est un graphe (orient\u00e9 ou non orient\u00e9)  admettant une partition \\(\\{P_1, P_2\\}\\)  de ses sommets telle que  \\(\\{x, y\\} \\in E \\Rightarrow (x, y) \u2208 P_1 \u00d7 P_2 \u222a P_2 \u00d7 P_1\\) </p> <p>Les arbres (et plus g\u00e9n\u00e9ralement les for\u00eats)  sont des graphes bipartis.  </p> <p></p>"},{"location":"Graphes/Graphes/#graphe-biparti-complet","title":"Graphe biparti complet","text":"<p>Un graphe est dit biparti complet (ou encore est appel\u00e9 une biclique) s\u2019il  est biparti et contient le nombre maximal d\u2019ar\u00eates.  Si \\(P_1\\) est de cardinal \\(m\\) et \\(P_2\\) est de cardinal \\(n\\) le graphe biparti complet  est not\u00e9 \\(K_{m,n}\\).  </p> <p></p>"},{"location":"Graphes/Graphes/#un-peu-de-ocaml","title":"Un peu de OCAML","text":""},{"location":"Graphes/Graphes/#liste-dadjacence_3","title":"Liste d\u2019adjacence","text":"<pre><code>type graphe = int list array ;;\n(* graphe orient\u00e9 *)\nlet g1 = [|[1; 2]; [2]; [0]|];;\n(* graphe non orient\u00e9 *)\nlet g2 = [|[1; 2]; [2; 0]; [0; 1]|] ;;\n</code></pre> <p>Les sommets sont num\u00e9rot\u00e9s de \\(0\\) \u00e0 \\(|g| \u2212 1\\).  </p> <p></p> <p>Voir TD pour les exercices  </p>"},{"location":"Graphes/Graphes/#matrice-dadjacence_2","title":"Matrice d\u2019adjacence","text":"<pre><code>type graphe = int array array ;;\nlet g = Array . make_matrix 4 4 0;;\ng .(0) .(1) &lt; -1; g .(0) .(2) &lt; -1; g .(1) .(3) &lt; -1; g .(2) .(1) &lt; -1;;\n</code></pre> <p>Voir TD pour les exercices  </p>"},{"location":"Graphes/Graphes/#parcours-de-graphes","title":"Parcours de graphes","text":""},{"location":"Graphes/Graphes/#presentation","title":"Pr\u00e9sentation","text":""},{"location":"Graphes/Graphes/#definition","title":"D\u00e9finition","text":"<p>En th\u00e9orie des graphes, un parcours de graphe est un algorithme  consistant \u00e0 explorer les sommets d\u2019un graphe de proche en proche \u00e0  partir d\u2019un sommet initial. Un cas particulier important est le parcours  d\u2019arbre.</p> <p>Un parcours d\u2019un graphe permet de choisir, \u00e0 partir des sommets  visit\u00e9s, le sommet suivant \u00e0 visiter.</p> <p>Le probl\u00e8me consiste \u00e0 d\u00e9terminer un ordre sur les visites des  sommets.</p> <p>Une fois le choix fait, l\u2019ordre des visites induit une num\u00e9rotation des  sommets visit\u00e9s (l\u2019ordre de leur d\u00e9couverte) et un choix sur l\u2019arc ou  l\u2019ar\u00eate utilis\u00e9 pour atteindre un nouveau sommet \u00e0 partir des sommets  d\u00e9j\u00e0 visit\u00e9s.</p> <p>Les arcs ou ar\u00eates distingu\u00e9s forment une arborescence ou un arbre, et  les num\u00e9ros des sommets sont croissants sur les chemins de  l\u2019arborescence ou les cha\u00eenes de l\u2019arbre depuis la racine.  </p>"},{"location":"Graphes/Graphes/#finalite","title":"Finalit\u00e9","text":"<p>Les algorithmes de parcours ne sont pas une fin en eux-m\u00eames. Ils servent  comme outil pour \u00e9tudier une propri\u00e9t\u00e9 globale du graphe, par exemple :</p> <ul> <li>Connexit\u00e9 et forte connexit\u00e9</li> <li>Existence d\u2019un circuit ou d\u2019un cycle et, le cas  \u00e9ch\u00e9ant, d\u00e9finition d\u2019un  ordre total sur les sommets compatible avec le sens des arcs (ce qu\u2019on  appelle tri topologique)  </li> <li>Calcul des plus courts chemins (notamment l\u2019algorithme de Dijkstra)  </li> <li>Calcul d\u2019un arbre recouvrant (notamment l\u2019algorithme de Prim)  </li> <li>Algorithmes pour les \ufb02ots maximums (comme l\u2019algorithme de  Ford-Fulkerson).  </li> <li>Coloration des sommets etc.  </li> </ul>"},{"location":"Graphes/Graphes/#analyse","title":"Analyse","text":"<p>La di\ufb03cult\u00e9 de l\u2019exploration consiste \u00e0 \u00e9viter de visiter plusieurs fois  un m\u00eame sommet. Pour cela on met en oeuvre un marquage des  sommets par des couleurs.  Lors d\u2019une exploration, chaque sommet passe par trois couleurs :</p> <ul> <li><code>bleu</code> tant que la visite du sommet n\u2019a pas commenc\u00e9e  </li> <li><code>vert</code> d\u00e8s que sa visite commence et tant le traitement n\u2019est pas termin\u00e9  </li> <li><code>rouge</code> d\u00e8s que le traitement est termin\u00e9  </li> </ul> <p>L\u2019exploration \u00e0 partir d\u2019un sommet s ne permet pas n\u00e9cessairement  d\u2019explorer tout le graphe (il peut y avoir plusieurs \\(CC\\)\\(/\\)\\(CFC\\) ). Pour  e\ufb00ectuer une exploration compl\u00e8te il faut relancer le parcours \u00e0 partir  d\u2019un sommet bleu tant qu\u2019il en existe.  </p>"},{"location":"Graphes/Graphes/#parcours-a-partir-dun-sommet","title":"Parcours \u00e0 partir d\u2019un sommet","text":"<p>On g\u00e8re une structure \\(S\\) (pile, file, ou autre). On dispose d\u2019une fonction  d\u2019ajout (dans) et de retrait (de) cette structure. Depuis un sommet donn\u00e9  on peut s\u00e9lectionner un successeur (par exemple un voisin).  Le parcours d\u00e9bute par un sommet \\(s_0\\).  </p> <pre><code>/* parcourir les sommets bleus accessibles depuis s0 \u2217/\nColorer en bleu tous les sommets .\nCr\u00e9er une structure S vide , y ajouter s0 ,colorer s0 en vert\n    tant que S n\u2019est pas vide faire\n    retirer un sommet s de S\n    (traiter s et le colorer en Rouge ) ou bien le rajouter \u00e0 S\n    si s a des successeurs Bleus\n        en choisir un ou m\u00eame plusieurs ;\n        le/les colorer en Vert ; le/les ajouter \u00e0 S ;\n    sinon\n        si s \u2208 S , le retrirer d\u00e9finitivement , traiter + colorer s en Rouge\n</code></pre> <p>D\u00e8s qu\u2019un sommet bleu est abord\u00e9, il devient vert. Suivant les traitements,  on peut choisir de traiter \\(s\\) \u00e0 plusieurs endroits (L6 ou L11).  </p>"},{"location":"Graphes/Graphes/#graphe-de-liaison-induit","title":"Graphe de liaison induit","text":"<p>Soit \\(G = (V , E)\\) un graphe et \\(s_0 \\in S\\). On appelle graphe de liaison  induit par l\u2019exploration de \\(G\\) \u00e0 partir de \\(x\\), le sous-graphe de \\(G\\)  engendr\u00e9 par les ar\u00eates\\(\\left \\{u,v \\right \\}\\in E\\) (resp. les arcs) par lesquelles  passent l\u2019exploration de \\(G\\) , (l\u2019exploration passe par \\(\\left \\{u,v \\right \\}\\) (resp.  \\((u, v)\\)) si celle-ci provoque le coloriage du sommet \\(v\\) en vert).  </p> <p>Pour un parcours depuis \\(s_0\\) :  </p> <ul> <li>on d\u00e9bute avec le graphe (\\(s_0,\\varnothing\\))</li> <li>lors du passage du parcours par un sommet \\(s\\) vert on ajoute chaque  voisin bleu \\(t\\) et l\u2019ar\u00eate (resp. arc) \\(\\left \\{s,t \\right \\}\\) (resp. \\((s, t)\\)) au graphe induit  (mais peut-\u00eatre pas tous en m\u00eame temps).</li> <li>On construit ainsi un graphe connexe ayant \\(k\\) sommets et \\(k \u2212 1\\) ar\u00eates,  autrement dit un arbre ou une arborescence.</li> </ul> <p>Le graphe de liaison induit par une exploration compl\u00e8te de \\(G\\) est un ensemble d\u2019arbre ou une arborescence.  </p>"},{"location":"Graphes/Graphes/#tableau-de-couleurs","title":"Tableau de couleurs","text":"<ul> <li> <p>On colorie tous les sommets en bleu \\((O(n))\\) puis on lance  l\u2019exploration de n\u2019importe quel sommet.  </p> </li> <li> <p>Lors d\u2019un parcours, chaque sommet entre au plus une fois dans  l\u2019accumulateur <code>Verts</code> , et n\u2019en sort qu\u2019au plus une fois (quand il  devient rouge).</p> </li> <li> <p>On s\u2019arrange pour que ces op\u00e9rations d\u2019entr\u00e9e et de sortie  dans/de l\u2019accumulateur sont de co\u00fbt constant. Pour r\u00e9aliser cette  condition, la solution que nous adoptons consiste \u00e0 utiliser un tableau  de couleurs R,V,B.  </p> </li> </ul>"},{"location":"Graphes/Graphes/#parcours-en-largeur-dabord","title":"Parcours en largeur d'abord","text":""},{"location":"Graphes/Graphes/#algorithme","title":"Algorithme","text":"<p>L\u2019ensemble des sommets Verts est repr\u00e9sent\u00e9 par une file  (biblioth\u00e8que OCAML queue par exemple)</p> <p>\\(\\color{red}Principe\\) : on explore le graphe \u00e0 partir d\u2019un sommet en visitant  d\u2019abord tous les sommets voisins (\u00e0 une distance 1), puis tous les  sommets voisins de ses voisins (\u00e0 une distance 2)....  </p> <p>\\(F\\) : file des sommets verts.  </p> <pre><code>procedure Largeur(G: graphe, s: sommet, F: file)\n    Colorier s en vert et Enfiler s\n    tant que F non vide faire\n        Defiler x\n        pour chaque voisin y de x:\n            si y est bleu alors\n                Enfiler y et le colorier en vert\n            Colorier x en rouge\n\nprocedure Largeur_totale (G:graphe, F:file)\n    Pour chaque sommet s :\n        si s est bleu alors\n            Largeur(G, s, F)\n\nColorier tous les sommets en bleu\nCr\u00e9er une file vide F /\u2217 file des sommets verts \u2217/\nLargeur_totale(G, F)\n</code></pre> <p>Variant de boucle <code>tant que</code> : nombre de sommets bleus + nombre de  sommets verts. L\u2019algorithme termine.  </p> <p>Animation du parcours en largeur d'abord :</p> <p></p> <p>A la fin on obtient :</p> <p></p> <p>Avec en rouge le graphe de liaison induit. Deux arborescences de racines respectives \\(S_1\\) et \\(S_5\\).</p>"},{"location":"Graphes/Graphes/#cout-des-operations-de-file","title":"Co\u00fbt des op\u00e9rations de file","text":"<p>Pour un graphe \\(G = (V , E)\\) avec \\(|E| = p\\) et \\(|V| = n\\) </p> <ul> <li>Tous les sommets sont colori\u00e9s en bleu exactement une fois au d\u00e9but  puis plus jamais : \\(O(n)\\).</li> <li>Un sommet finit toujours par entrer dans la file (soit du fait de la  boucle tant que , soit du fait de Largeur).  Du fait des tests de couleurs, il n\u2019y entre qu\u2019une fois.</li> <li>Un sommet finit toujours par quitter la file car l\u2019algorithme termine.</li> <li>Les op\u00e9rations d\u2019enfilement/d\u00e9filement sont en \\(O(1)\\). Le co\u00fbt total de  gestion de file est en \\(\\Theta(n)\\).  </li> </ul>"},{"location":"Graphes/Graphes/#gestion-des-listes-dadjacence","title":"Gestion des listes d\u2019adjacence","text":"<p>Pour un graphe \\(G = (V , E)\\) avec \\(|E| = p\\) et \\(|V| = n\\)</p> <ul> <li>Une liste d\u2019adjacence donn\u00e9e n\u2019est balay\u00e9e qu\u2019une fois et une seule (puisque chaque sommet est ajout\u00e9 dans la file puis d\u00e9fil\u00e9 une fois et  une seule). Chaque \u00e9l\u00e9ment de cette liste donne lieu \u00e0 des op\u00e9rations  de coloriage/enfilement en \\(O(1)\\).</li> <li>La somme des longueurs des listes d\u2019adjacence est en \\(\\Theta(\\left|E \\right|) = \\Theta(p)\\).  Donc le temps total consacr\u00e9 au balayage des listes d\u2019adjacence est en  \\(\\Theta(p)\\).</li> <li>Enfin la coloration initiale est en \\(\\Theta(n)\\).</li> <li>Le total des op\u00e9rations est en \\(\\Theta(n + p)\\) pour le parcours en largeur.  </li> </ul>"},{"location":"Graphes/Graphes/#proprietes-du-parcours-en-largeur-dabord","title":"Propri\u00e9t\u00e9s du parcours en largeur d\u2019abord","text":"<p>Consid\u00e9rons un parcours en largeur depuis un sommet s :</p> <ul> <li>\\(s\\) est le premier sommet rouge. Un sommet devient rouge avant ses  sucesseurs dans l\u2019ordre de parcours.</li> <li>Un sommet rouge n\u2019a que des sommets adjacents verts ou rouges (en  exo).  </li> <li>Si un sommet \\(x\\) est rouge alors il existe une cha\u00eene/chemin allant de \\(s\\)  \u00e0 \\(x\\) constitu\u00e9e uniquement de sommets rouges (en exo).  </li> <li>Si un sommet \\(x\\) est vert alors il existe une cha\u00eene/chemin allant de \\(s\\) \u00e0  \\(x\\) constitu\u00e9e uniquement de sommets verts ou rouges (en exo).  </li> <li>A la fin du parcours tous les sommets sont soit bleus, soit rouges (et la  file des verts est vide).  </li> </ul> <p>Cons\u00e9quence : \u00e0 la fin de l\u2019appel de <code>Largeur</code> les sommets rouges sont  tous les sommets accessibles \u00e0 partir de \\(s\\).  </p> <p>Preuve : accessiblit\u00e9 = coloration en rouge</p> <p>Posons \\(G = (V , E)\\) et faison un bfs depuis \\(s_0\\in V\\) . On montre qu\u2019il y a un  chemin vert/rouge depuis \\(s_0\\) vers tout sommet de la file, et qu\u2019existe un  chemin totalement rouge de \\(s_0\\) vers tout sommet rouge.</p> <ul> <li>Au tour 1, \\(s_0\\) sort de la file et devient rouge. Alors il y a un chemin  rouge de \\(s_0\\) \u00e0 \\(s_0\\). Et tous les voisins de \\(s\\) deviennent verts : donc il y a  un chemin rouge/vert vers eux.</li> <li> <p>Supposons la propri\u00e9t\u00e9 vraie au tour \\(k\\). Soit \\(s\\) le sommet d\u00e9fil\u00e9 au  tour \\(k + 1\\). Il faut v\u00e9rifier la propri\u00e9t\u00e9 pour le nouveau sommet rouge  et les nouveaux verts.  </p> <ul> <li>\\(s\\) devient rouge. Puisque \\(s\\) \u00e9tait dans la file, il y a \u00e9t\u00e9 plac\u00e9 par un  sommet \\(x\\) qui est devenu rouge. Par HR, il y a un chemin rouge de \\(s\\) \u00e0  \\(x\\) et donc (en ajoutant l\u2019arc \\((x, s)\\)) de \\(s_0\\) \u00e0 \\(s\\).</li> <li>Tout sommet \\(y\\) qui devient vert est un voisin de \\(s\\). Comme il y a un  chemin rouge de \\(s_0\\) \u00e0 \\(s\\), il y a un chemin rouge/vert de \\(s_0\\) \u00e0 \\(y\\) .  </li> </ul> </li> <li> <p>Si un sommet \\(x\\) est rouge, il y a un chemin (rouge) depuis \\(s\\) vers \\(x\\)  donc \\(x\\) est accessible.</p> </li> <li> <p>R\u00e9ciproquement. On montre que si un sommet est \u00e0 une distance  \\(k \u2264 n\\) de \\(s_0\\), alors il est rouge \u00e0 la fin du BFS. </p> <ul> <li> <p>Vrai pour la distance \\(d = 0\\). \\(s_0\\) est accessible depuis \\(s\\) et il est rouge.  Cas de base OK.</p> </li> <li> <p>Si la propri\u00e9t\u00e9 est vraie pour tout sommet accesible \u00e0 la distance k de  \\(s_0\\), soit \\(x\\) \u00e0 la distance \\(k + 1\\) (s\u2019il n\u2019existe pas de sommet \u00e0 la distance  \\(k + 1\\), il n\u2019en existe pas non plus \u00e0 une distance sup\u00e9rieure et la propri\u00e9t\u00e9 est prouv\u00e9e).</p> </li> <li> <p>Alors le pr\u00e9d\u00e9cesseur \\(y\\) de \\(x\\) dans un PCC de \\(s_0\\) \u00e0 \\(x\\) est \u00e0 la distance \\(k\\)  de \\(s_0\\) (un sous-chemin de PCC est un PCC). Par HR, il devient rouge \u00e0  un moment.</p> </li> <li> <p>Donc si \\(x\\) est bleu au moment o\u00f9 \\(y\\) devient rouge, alors \\(y\\) le marque en vert et \\(x\\) finit par devenir rouge. Et si \\(x\\) est d\u00e9j\u00e0 marqu\u00e9 quand \\(y\\) devient rouge, alors \\(x\\) devient rouge. (Tout sommet qui entre dans la file en sort et devient rouge)         </p> </li> </ul> </li> </ul>"},{"location":"Graphes/Graphes/#parcours-en-profondeur-dabord","title":"Parcours en profondeur d'abord","text":""},{"location":"Graphes/Graphes/#presentation_1","title":"Pr\u00e9sentation","text":"<p>Principe : on explore le graphe \u00e0 partir d\u2019un sommet \\(x\\) en visitant l\u2019un  de ses sommets successeurs \\(y\\) et en poursuivant l\u2019exploration d\u2019abord  par les successeurs de ce dernier avant les autres successeurs de \\(x\\).  </p> <p>Ainsi l\u2019exploration s\u2019e\ufb00ectue en suivant le plus loin possible une  cha\u00eene issue de \\(x\\). Lorsque tous les successeurs d\u2019un sommet ont \u00e9t\u00e9  visit\u00e9s, on continu l\u2019exploration en remontant dans la cha\u00eene au  premier sommet ayant encore des successeurs non visit\u00e9s.  </p> <p>On g\u00e8re une pile des sommets verts (biblioth\u00e8que OCAML listes ou  stack, python : listes ou classe deque)  </p>"},{"location":"Graphes/Graphes/#algorithme_1","title":"Algorithme","text":"<p>On utilise une pile pour g\u00e9rer les sommets verts.</p> <pre><code>procedure Profondeur(G: graphe, P: pile)\n    Si P non vide\n        x := Peek P /*R\u00e9cup\u00e8re le sommet de la pile sans d\u00e9piler */ \n        tant qu'il existe un voisin bleu y de x faire\n            Empiler ce voisin; /*il devient vert*/ \n            Profondeur (G,P)\n        fin_faire\n        Depiler x\n        Colorier x en rouge\n\nColorier tous les sommets en bleu\nCr\u00e9er une pile P vide /* Pile des sommets verts */\ntant que des sommets bleus sont pr\u00e9sents faire\n    s := choisir un sommet bleu;\n    empiler s dans P; /*revient \u00e0 colorier s en vert*/ \n    Profondeur (G,P)\n</code></pre>"},{"location":"Graphes/Graphes/#en-pratique","title":"En pratique","text":"<p>Un m\u00eame n\u0153ud s appara\u00eet plusieurs fois au sommet de la pile. Il faut  donc g\u00e9rer un marqueur de progression dans sa liste de voisins pour  \u00e9viter de reprendre cette liste depuis le d\u00e9but \u00e0 chaque passage de \\(s\\)  au sommet de la pile.  </p> <p>Solution : consid\u00e9rer les listes de voisins comme des piles. On d\u00e9pile  jusqu\u2019\u00e0 trouver un sommet bleu. Les voisins d\u00e9pil\u00e9s ne reviennent  jamais dans la pile de voisins. Cela impose de faire une copie du graphe (\\(O(n)\\) si le graphe est un tableau de listes de voisins.)  </p>"},{"location":"Graphes/Graphes/#nombre-doperations-due-a-un-sommet","title":"Nombre d\u2019op\u00e9rations due \u00e0 un sommet","text":"<p>On analyse le nombre d\u2019op\u00e9rations engendr\u00e9es par la pr\u00e9sence d\u2019un  sommet donn\u00e9 \\(s\\) en haut de la pile. Il su\ufb03ra de sommer sur tous les  sommets pour obtenir la complexit\u00e9 totale. (Ajouter aussi le co\u00fbt  d\u2019initialisation en \\(O(n)\\)).</p> <ul> <li>Le sommet \\(s\\) entre toujours dans la pile (soit du fait de la boucle <code>tant que</code>, soit du fait de <code>Profondeur</code>). Le coloriage assure que le sommet  ne revient pas dans la pile verte quand il l\u2019a quitt\u00e9e.  </li> <li>Le sommet \\(s\\) appara\u00eet au plus \\(deg\\text{ }s^+ + 1\\) fois au sommet de la pile  (s\u2019en convaincre avec le graphe \\(x \u2192 y\\)).  </li> <li>A chaque apparition au sommet de la pile verte, il y a une recherche d\u2019un voisin bleu (on peut la rendre AU TOTAL en \\(O(deg^+ s)\\) pour tout l\u2019algo) ; un coloriage/empilement dans la pile verte parfois (au plus \\(deg^+ s\\) fois).  </li> <li>\\(s\\) est d\u00e9pil\u00e9 puis colori\u00e9 en rouge une seule fois.  </li> </ul> <p>La pr\u00e9sence de \\(s\\) en haut de la pile engendre donc un nombre  d\u2019op\u00e9rations (major\u00e9 par un nombre) proportionnel \u00e0 son nombre de  pr\u00e9sences au sommet, soit \\(1 + deg s^+\\) .  </p>"},{"location":"Graphes/Graphes/#complexite-totale","title":"Complexit\u00e9 totale","text":"<p>Pour un graphe \\(G = (V, E)\\) avec \\(|E| = p\\) et \\(|V| = n\\) </p> <ul> <li>On somme les nombres d\u2019op\u00e9rations occasionn\u00e9es par chaque sommet pour obtenir la complexit\u00e9 totale.  </li> <li>Le nombre total d\u2019op\u00e9ration est (major\u00e9 par un nombre) proportionnel  \u00e0  </li> </ul> \\[\\sum_{s\\in V}(1 + deg^+ s) = n + \\sum_{i\\in V}deg^+ s  = n + p = O(n+p)\\] <ul> <li>M\u00eame si on ajoute le co\u00fbt d\u2019initialisation en \\(O(n)\\) et la copie en \\(O(n+p)\\), l\u2019ensemble reste en  \\(O(n)\\) </li> </ul>"},{"location":"Graphes/Graphes/#observations","title":"Observations","text":"<p>Les invariants suivants sont maintenus  </p> <ul> <li>A tout moment, la pile d\u00e9crit un chemin entre \\(s\\) (la base) et le haut  de la pile.  </li> <li>Lorsqu\u2019on colorie un sommet \\(x\\) en vert, tous les sommets bleus  accessibles \u00e0 partir de \\(x\\) seront colori\u00e9s en rouges avant que \\(x\\) ne le  soit.  </li> <li>A la fin du parcours, l\u2019ensemble des sommets rouges est l\u2019ensemble  des sommets accessibles \u00e0 partir de \\(s\\) qui \u00e9taient bleus au moment  l\u2019entr\u00e9e de \\(s\\) dans la pile.  </li> </ul> <p>Animation du parcours en largeur d'abord :</p> <p></p> <p>A la fin on obtient :</p> <p></p>"},{"location":"Graphes/Graphes/#vocabulaire","title":"Vocabulaire","text":"<p>Soit \\(G_l = (V , L)\\) le graphe de liaison induit par le parcours en  profondeur d\u2019un graphe \\(G\\) . Un arc \\(u \u2192 v\\) est :  </p> <ul> <li>un arc de <code>liaison</code> si et seulement si \\(u \\rightarrow v \\in L\\) </li> <li>un arc <code>retour</code> si et seulement si \\(u\\) est un descendant de \\(v\\) dans \\(L\\).  </li> <li>un arc <code>avant</code> si et seulement si \\(v\\) est un descendant de \\(u\\) dans \\(L\\) et  \\(u \\rightarrow v \\notin L\\)   (on prend de l\u2019avance par rapport au cheminement normal  dans \\(L\\))  </li> <li>un arc couvrant sinon (tous les autres arcs).  </li> </ul>"},{"location":"Graphes/Graphes/#variante","title":"Variante","text":"<p>Certains auteurs, g\u00e8rent le parcours en profondeur comme le parcours  en largeur mais utilisent juste une pile et non une file.</p> <p>Dans ce type de parcours, un m\u00eame sommet n\u2019appara\u00eet qu\u2019une seule  fois au sommet de la pile verte.  </p> <p>D\u00e8s qu\u2019un sommet appara\u00eet au sommet de la pile, il est d\u00e9pil\u00e9 (une  fois pour toute) et on ajoute en une seule fois tous ses voisins bleus  au sommet de la pile. Un sommet devient alors rouge avant ses  successeurs.  </p> <p>L\u2019\u00e9criture du programme est alors plus simple, puisqu\u2019une m\u00eame liste  de voisins n\u2019est parcourue qu\u2019une fois pour toute (alors qu\u2019avec ma  version, on la parcourt \"par bouts\" en \\(y\\) revenant plusieurs fois).  </p> <p>En revanche, on perd une propri\u00e9t\u00e9 importante : la pile ne d\u00e9crit plus  exactement un chemin de la base au sommet mais est un simple  accumulateur de sommets rencontr\u00e9s.  </p> <pre><code>Profondeur2 (G: graphe, s: sommet)\n    Cr\u00e9er P : pile vide des sommets verts\n    Colorier s en vert et Empiler s \n    tant que P non vide faire\n        x := Depiler P /*x ne sera plus jamais au sommet*/ \n        pour chaque sommet adjacent y de x:\n            /* tous les voisins de x ajout\u00e9s en une seule fois */\n            si y est bleu alors\n                Colorier y en vert et Empiler y dans P\n        Colorier x en rouge /*x devient rouge avant tous ses voisins*/\n</code></pre> <p>A noter qu\u2019il n\u2019y a plus vraiment de raison d\u2019utiliser trois couleurs ; deux  su\ufb03sent.  </p>"},{"location":"Graphes/Graphes/#graphes-acyclique","title":"Graphes acyclique","text":""},{"location":"Graphes/Graphes/#generalites","title":"G\u00e9n\u00e9ralit\u00e9s","text":"<p>Graphe <code>acyclique</code>: un graphe qui ne contient pas de circuit/cycle.  </p> <p>Certain probl\u00e8mes n\u2019ont de solution que pour des graphes acycliques :  plus court chemin, ordonnancement...  </p> <p>Si un graphe est acyclique on peut concevoir des algorithmes qui  s\u2019arrangent pour traiter tous les pr\u00e9decesseurs d\u2019un sommet donn\u00e9  avant de traiter ce sommet (variante du parcours en profondeur).  </p>"},{"location":"Graphes/Graphes/#propietes","title":"Propi\u00e9t\u00e9s","text":""},{"location":"Graphes/Graphes/#cas-des-graphes-orientes","title":"Cas des graphes orient\u00e9s","text":"<p>Propri\u00e9t\u00e9s</p> <p>Un graphe contient un circuit si et seulement si lors du  parcours en profondeur l\u2019un des successeurs du sommet en haut de la  pile verte est d\u00e9j\u00e0 vert.  </p> <p>Exemple</p> <p><p></p></p> <p>\\(S_6\\) a pour successeur \\(S_1\\) qui est d\u00e9j\u00e0 vert \\(\\Rightarrow\\) un circuit.  </p> <p>Autre fa\u00e7on de dire que le graphe est acyclique : le graphe de liaison  induit par un parcours en profondeur d\u2019un graphe sans circuit ne  g\u00e9n\u00e8re aucun arc retour.  </p> <p><p></p></p> <p>Il y a des arcs retour (en vert) \\(\\Rightarrow\\) des circuits  </p> <p>L\u2019algorithme pour la d\u00e9tection de circuit dans un graphe est une variante  du parcours en profondeur : quand on examine les arcs issus du sommet de  la pile, il su\ufb03t de regarder si un arc ne pointe pas vers un n\u0153ud vert. On  s\u2019ar\u00eate d\u00e8s que c\u2019est le cas.  </p> <p>Preuve de la m\u00e9thode</p> <p>On montre que la pr\u00e9sence d\u2019un cycle est \u00e9quivalente \u00e0 l\u2019existence d\u2019un arc retour.  </p>"},{"location":"Graphes/Graphes/#sil-existe-un-arc-retour","title":"S'il existe un arc retour","text":"<ul> <li>Si la pile verte \\(P\\) a \\(r &gt; 1\\) sommets, le dernier sommet vert a \u00e9t\u00e9 ajout\u00e9 parce qu\u2019il existe un arc de  \\(P[\u22122]\\) \u00e0 \\(P[\u22121]\\) (notations Python).  </li> <li>Par r\u00e9currence, on obtient l\u2019existence d\u2019un chemin de  tout sommet dans la pile vers les sommets sup\u00e9rieurs.  </li> <li>Donc si on empile un sommet, et qu\u2019un de ses  successeurs est d\u00e9j\u00e0 vert (ce qui est la d\u00e9finition d\u2019un  arc retour), il y a un cycle.  </li> </ul>"},{"location":"Graphes/Graphes/#sil-existe-un-cycle-reciproque","title":"S'il existe un cycle (R\u00e9ciproque)","text":"<p>Supposons l\u2019existence d\u2019un cycle. On peut le consid\u00e9rer sans doublon  (sinon enlever des sommets juqu\u2019\u00e0 ce qu\u2019il ne contienne que des sommets  distincts).  Soit \\(x\\) le premier sommet du cycle \u00e0 \u00eatre empil\u00e9. Tous les autres sommets du cycle sont bleus.  </p> <ul> <li>Le second sommet du cycle sera vert avant que \\(x\\) devienne rouge  puisque c\u2019est un voisin de \\(x\\).  </li> <li>De proche en proche, on \u00e9tablit que \u00e0 un moment tous les sommets  du cycle sont dans la pile. Donc, le dernier sommet du cycle avant \\(x\\),  notons le \\(y\\) , devient vert alors que \\(x\\) est encore dans la pile. Comme il  y a un arc \\((y , x)\\), cet arc est un arc retour.  </li> </ul>"},{"location":"Graphes/Graphes/#tri-topologique","title":"Tri topologique","text":""},{"location":"Graphes/Graphes/#presentation_2","title":"Pr\u00e9sentation","text":"<p>Exemple de probl\u00e8me : \u00e9tant donn\u00e9 un ensemble de t\u00e2che \u00e0 effectuer avec des contraintes d'ant\u00e9riorot\u00e9, on veut construire une liste de ces t\u00e2ches respectant les contraintes</p> <p>Repr\u00e9sentation : \u00e0 l'aide d'un graphe orient\u00e9 o\u00f9 chaque sommet repr\u00e9sente une t\u00e2che et o\u00f9 chaque arc \\(x \\rightarrow y\\) signifie que la t\u00e2che \\(x\\) doit \u00eatre effectu\u00e9e avant la t\u00e2che \\(y\\). on dit que \\(x\\) est un pr\u00e9decesseur de \\(y\\), \\(y\\) est un successeur de \\(x\\).</p> <p>La r\u00e9solution de ce probl\u00e8me consiste \u00e0 effectuer un tri topologique des sommets du graphes, c'est \u00e0 dire \u00e0 construire une liste ordon\u00e9ee des sommets telle qu'aucun sommet du graphes n'appara\u00eet dans la liste avant l'un de ses pr\u00e9d\u00e9cesseurs.</p> <p>On peut repr\u00e9senter les sommets align\u00e9s de gauche \u00e0 droite sans qu'aucun arc n'aille de droite \u00e0 gauche</p> <p>D\u00e9finition: Tri topologique</p> <p>On appelle <code>tri topologique</code> d'un graphe orient\u00e9 \\(G = (V, E)\\) toute injection \\(r: S\\rightarrow \\mathbb{N}\\) telle que \\(\\forall x \\rightarrow y \\in A: r(x) \\le r(y)\\). On appelle \\(r(x)\\) le rang du sommet \\(x\\).</p> <p></p>"},{"location":"Graphes/Graphes/#tri-topologique-et-acyclicite","title":"Tri topologique et acyclicit\u00e9","text":"<p>Proposition</p> <p>Un graphe \\(G\\) orient\u00e9 est acyclique si et seulement si il existe un tri topologique de \\(G\\).</p> <p>Preuve</p>"},{"location":"Graphes/Graphes/#graphe-acyclique-rightarrow-tri-topologique","title":"Graphe acyclique \\(\\Rightarrow\\) tri topologique","text":"<p>Pour trier topologiquement un graphe acyclique orient\u00e9 contenant n sommets, on effectue un parcours en profondeur et on num\u00e9rote de mani\u00e8re d\u00e9croissante les sommets \u00e0 partir de \\(n\\) au fur et \u00e0 mesure qu\u2019ils deviennent rouges : \\(r(s) = n\\) si \\(s\\) est le premier rouge, \\(r(s) = 1\\) si \\(s\\) est le dernier. On montre que la m\u00e9thode est correcte.</p> <ul> <li>Supposons \\(G\\) acyclique. Si \\(r (x) &lt; r (y)\\), c\u2019est que y devient rouge avant x. On raisonne par l\u2019absurde en supposant qu\u2019il existe un arc (y , x).</li> <li>Au moment de l\u2019empilement de \\(y\\) (donc quand \\(y\\) devient vert), si \\(x\\) est bleu, alors \\(x\\) est empil\u00e9 apr\u00e8s \\(y\\) donc devient rouge avant, ce qui contredit \\(r (x) &lt; r (y)\\).</li> <li>Si au moment de l\u2019empilement de \\(y\\) , \\(x\\) est d\u00e9j\u00e0 rouge, alors \\(r (x) &gt; r (y)\\), ce qui est absurde.</li> <li>Donc au moment de l\u2019empilement de \\(y\\) , \\(x\\) est vert. Et comme il y a un arc \\((y , x)\\), cela r\u00e9v\u00e8le un circuit : absurde.</li> </ul>"},{"location":"Graphes/Graphes/#tri-topologique-rightarrow-graphe-acyclique","title":"Tri topologique \\(\\Rightarrow\\) graphe acyclique","text":"<p>Soit \\(G = (V , E )\\) un graphe orient\u00e9. Rappel : un tri toplogique \\(r\\) est une num\u00e9rotation injective des sommets telle que pour deux sommets \\(x, y\\) : \\((r(x) \\le r(y) \\Rightarrow y \\rightarrow x \\notin E)\\).</p> <ul> <li>On suppose qu\u2019existe un circuit \u00e9l\u00e9mentaire \\(C\\) et on prend \\(x\\) dans ce circuit tel que \\(r(x) = min(\\{ r(y)\\text{ | }y \\in C \\})\\).</li> <li>Soit \\(y\\) le pr\u00e9decesseur de \\(x\\) dans \\(C\\) . Comme \\(y \\rightarrow x \\in E\\), on a \\(r(y) &lt; r(x)\\). Contradiction avec \\(r(x) \\leq r(y)\\).</li> </ul>"},{"location":"Graphes/Graphes/#composantes-fortement-connexes-cfc","title":"Composantes fortement connexes (CFC)","text":""},{"location":"Graphes/Graphes/#observations_1","title":"Observations","text":"<p>Soit \\(G = (V, E)\\) un graphe orient\u00e9. On a vue qu\u2019une composante fortement connexe de \\(G\\) contenant un sommet \\(x\\) est l\u2019ensemble des sommets \\(y\\) tels que \\(y\\) est accessible \u00e0 partir de \\(x\\) et \\(x\\) est accessible \u00e0 partir de \\(y\\).</p> <p>Le parcours en profondeur d\u2019un graphe \u00e0 partir d\u2019un sommet \\(x\\) ayant comme r\u00e9sultat l\u2019ensemble des sommets accessibles \u00e0 partir de \\(x\\), on va utiliser ce parcours pour calculer la composante fortement connexe contenant \\(x\\).</p>"},{"location":"Graphes/Graphes/#principe","title":"Principe","text":"<p>D\u00e9finition: Graphe Transpos\u00e9</p> <p>Le graphe transpos\u00e9 \\(G^{-1}\\) d'un graphe \\(G\\) s'obtient en inversant chacun de ses arcs.</p> <p>Soit \\(G\\) un graphe orient\u00e9 et \\(x\\) un sommet.</p> <p>Parcourir en profondeur \\(G\\) \u00e0 partir du sommet \\(x\\) pour calculer l\u2019ensemble \\(A\\) des sommets accessibles \u00e0 partir de \\(x\\).</p> <p>Parcourir en profondeur le graphe transpos\u00e9 \\(G^{-1}\\) \u00e0 partir de \\(x\\) pour calculer l\u2019ensemble \\(B\\) des sommets dans \\(G\\) \u00e0 partir desquels \\(x\\) est accessible.</p> <p>L\u2019ensemble des sommets \\(A \\cap B\\) est la composante fortement connexe de \\(x\\) dans \\(G\\).</p> <p>L\u2019intersection des CFC de \\(x\\) dans \\(G\\) et \\(G^{-1}\\) peut s\u2019effectuer en \\(O((|A| + |B|)\\times ln(|A \\cap B|))\\) si on repr\u00e9sente les ensembles par des ABR \u00e9quilibr\u00e9s.</p>"},{"location":"Graphes/Graphes/#cfc-en-mpi","title":"CFC en MPI","text":"<p>On verra en MPI une meilleure m\u00e9thode : l'algorithme de Kosaraju-Sharir.</p> <p>Id\u00e9e : Le graphe des CFC est orient\u00e9 et acyclique et on le parcourt dans l'ordre inverse d'un de ses tris topologiques.</p> <p></p>"},{"location":"Graphes/pcc/","title":"Plus cours chemin","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"Graphes/pcc/#generalites","title":"G\u00e9n\u00e9ralit\u00e9s","text":""},{"location":"Graphes/pcc/#graphe-pondere","title":"Graphe pond\u00e9r\u00e9","text":"<p>D\u00e9finition : Graphe pond\u00e9r\u00e9</p> <p>On dit qu'un triplet \\(G = (V, E, p)\\) est un graphe pond\u00e9r\u00e9 si le couple \\((V,E)\\) est un graphe et si \\(p\\) est une fonction de \\(E\\) dans \\(\\mathbb{R}\\)</p> <p>On dit que \\(p\\) est la (fonction de) pond\u00e9ration. Souvent not\u00e9e \\(w\\) pour weight.</p> <p>Si \\(e \\in E\\), alors \\(p(e)\\) est le poids de \\(e\\) ou pond\u00e9ration de \\(e\\).</p> <p>Les graphes sont munis par d\u00e9faut de la fonction de pond\u00e9ration \\(p:E \\to \\mathbb{R}, e \\mapsto 1\\). Donc tout graphe est un graphe pond\u00e9r\u00e9 qui s'ignore.</p>"},{"location":"Graphes/pcc/#poids-dune-chaine","title":"Poids d'une cha\u00eene","text":"<p>D\u00e9finition : Poids d'une cha\u00eene</p> <p>Le poids d'une cha\u00eene (resp. chemin) d'un graphe pond\u00e9r\u00e9 non orient\u00e9 (resp. orient\u00e9) est la somme des poids des ar\u00eates(resp. arcs) de la cha\u00eene (resp. chemin).</p> <p>Si \\(c\\) est la cha\u00eene \\(x_1, \\dots, x_n\\) :</p> \\[p(c) = \\sum_{i=1}^{n-1} p(\\{x_i, x_{i+1}\\})\\] <p><pre><code>graph LR\nA(A) ---- 7 ---&gt; B(B)\nA --- 5 --&gt; C(C)\nA -- 2 --&gt; D\nC --- 6 --&gt; D(D)</code></pre> Figure - graphe \\(ABCD\\) avec les poids \\(7\\) \\(5\\) \\(-2\\) et \\(6\\) en mermaid</p> <p>\\(p(ACDA) = -2 +6 +5 = 9\\)</p> <p>\\(p(ADC) = -2+6 = 4 \\text{ et } p(AC)=5\\)</p> <p>Le plus court chemin de \\(A\\) \u00e0 \\(C\\) est \\(ADC\\)</p>"},{"location":"Graphes/pcc/#le-plus-court-chemin","title":"Le plus court chemin","text":"<p>Etant donn\u00e9 un graphe pond\u00e9r\u00e9, on recherche le plus court chemin d\u2019un sommet \u00e0 un autre (ou \u00e0 tous les autres, ou le plus court chemin entre tous les couples de sommets...)</p> <p>Exemple :</p> <p>Dans une carte routi\u00e8re de la France, les villes \u00e9tant des sommets, les routes \u00e9tant des arcs, chercher le (ou les) trajet(s) de Paris \u00e0 Marseille qui optimise(nt) l'un des crit\u00e8res suivants :</p> <ul> <li>le temps de trajet</li> <li>la distance parcourue</li> <li>le prix des p\u00e9ages</li> </ul>"},{"location":"Graphes/pcc/#recherche-de-plus-courts-chemins","title":"Recherche de plus courts chemins","text":"<p>Dans tout ce qui suit, les graphes sont consid\u00e9r\u00e9s comme orient\u00e9s. Si le graphe \\(G\\) est non orient\u00e9, on l'oriente en construisant le graphe orient\u00e9 tel que :</p> <ul> <li>\\(G'\\) a les m\u00eames sommets que \\(G\\)</li> <li>pour tout ar\u00eate \\(\\{x, y\\}\\) de \\(G\\), \\(G'\\) poss\u00e8de les arcs \\(\\{x, y\\}\\) et \\(\\{y, x\\}\\)</li> </ul> <p>On recherche pour tout couple de sommets \\((i, j)\\) le plus court chemin de \\(i\\) \u00e0 \\(j\\) et on calcule sa longueur \\(d(i, j)\\). Si \\(j\\) n'est pas accessible depuis \\(i\\), on note \\(d(i, j) = +\\infty\\).</p>"},{"location":"Graphes/pcc/#longueur-de-plus-courts-chemins","title":"Longueur de plus courts chemins","text":""},{"location":"Graphes/pcc/#cas-particuliers-des-graphes-orientes-non-ponderes","title":"Cas particuliers des graphes orient\u00e9s non pond\u00e9r\u00e9s","text":"<p>Si le graphe \\(G\\) est orient\u00e9 et non pond\u00e9r\u00e9, on consid\u00e8re sa pond\u00e9ration par d\u00e9faut.</p> <p>Lors du parcours en largeur les sommets sont explor\u00e9s par distance croissante au sommet source. Gr\u00e2ce \u00e0 cette propri\u00e9t\u00e9 on r\u00e9sout le probl\u00e8me de cheminement suivant : calculer les longueurs des plus courts chemins entre un sommet source et tous les sommets du graphe (voir TD).</p>"},{"location":"Graphes/pcc/#circuits-de-poids-negatif","title":"Circuits de poids n\u00e9gatif","text":"<p>Pour rechercher un \\(PCC\\)( \\(=\\) plus court chemin) dans un graphe, il faut s'assurer au pr\u00e9alable que celui-c ne poss\u00e8de pas de circuit de poids n\u00e9gatif. Cela ne veut pas dire que le graphe ne peut pas contenir d'arcs de poids n\u00e9gatif.</p> <pre><code>graph LR\nA(A) -- -1 --&gt; B(B)\nC(C) -- 1 --&gt; A\nB -- -2 --&gt; C\nC --3--&gt; D(D)</code></pre> \\[p(ABCA) = -2\\] \\[p(ABCD) = 0\\] \\[p(ABCABCD) = -2\\] \\[p(ABCABCABCD) = -4\\]"},{"location":"Graphes/pcc/#sous-chemin-du-plus-court-chemin","title":"Sous-chemin du plus court chemin","text":"<p>Si un \\(PCC\\) de \\(A\\) \u00e0 \\(C\\) passe par \\(B\\), alors le sous-chemin entre \\(A\\) et \\(B\\) est un chemin de poids minimum.</p> <p>En effet, s\u2019il existe un autre chemin plus court entre \\(A\\) et \\(B\\), il suffit de le mettre \u00e0 la place du premier pour obtenir un nouveau chemin de \\(A\\) \u00e0 \\(C\\) encore plus court.</p> <ul> <li>Ceci contredit le fait que le premier chemin avait un poids minimum.</li> <li>Ceci est un cas particulier du principe d\u2019optimalit\u00e9 de Bellman qui dit que l\u2019on peut d\u00e9duire une solution optimale d\u2019un probl\u00e8me en combinant des solutions optimales d\u2019une s\u00e9rie de sous-probl\u00e8mes.</li> </ul> <p>Pour les \\(PCC\\), on l\u2019utilise en calculant d\u2019abord les \\(PCC\\) passant par un sous-ensemble de sommets avant de s\u2019attaquer aux \\(PCC\\) passant par un ensemble de sommets plus gros.</p>"},{"location":"Graphes/pcc/#algorithme-de-floyd-warshall","title":"Algorithme de Floyd-Warshall","text":""},{"location":"Graphes/pcc/#presentation","title":"Pr\u00e9sentation","text":"<p>L'lagorithme de Floyd-Warshall (parfois appel\u00e9 algorithme de Roy-Floyd-Warshall car d\u00e9crit par Bernard Roy en 1959) est un algorithme pour d\u00e9terminer les distances des plus courts chemins entre toutes les paires de sommets dans un graphe orient\u00e9 et pond\u00e9r\u00e9, en temps cubique en le nombre de sommets.</p> <p>Il prend en entr\u00e9e un graphe orient\u00e9 et valu\u00e9, d\u00e9crit par une matrice d'adjacence donnant le poids d'un arc lorsqu'il existe et la valeur \\(+\\infty\\) sinon. Le graphe ne doit pas poss\u00e9der de circuit de poids strictement n\u00e9gatif.</p> <p>C'est un exemple de programmation dynamique.</p> <p>Notons \\(\\{1, 2, \\dots, n\\}\\) l'ensemble des sommets du graphe. On note aussi \\(W_{ij}^k\\) la valeur de l'arc allant de \\(i\\) \u00e0 \\(j\\) n'empruntant que des sommets interm\u00e9diaires dans \\(\\{1, 2, \\dots, k\\}\\) s'il en existe un, et \\(+\\infty\\) sinon.</p> <p>On note \\(W^k\\) la matrice des \\(W_{ij}^k\\)</p> <p>Pour \\(k=0\\), \\(W^0\\) est la matrice d\u2019adjacence par poids. Trouvons une relation de r\u00e9currence. On consid\u00e8re un chemin \\(C\\) entre \\(i\\) et \\(j\\) de poids minimal dont les sommets interm\u00e9diaires sont dans \\(\\{1, 2, \\dots, k\\}\\). De deux choses l\u2019une :</p> <ul> <li>soit \\(C\\) n\u2019emprunte pas le sommet \\(k\\) ; </li> <li>soit \\(C\\) emprunte exactement une fois le sommet \\(k\\) (car les circuits sont de poids positifs ou nuls) et \\(C\\) est donc la concat\u00e9nation de deux chemins, \\(C_{i,k}\\) entre \\(i\\) et \\(k\\) et \\(C_{k,j}\\) entre \\(k\\) et \\(j\\) respectivement, dont les sommets interm\u00e9diaires sont dans \\(\\{1, 2, \\dots, k-1\\}\\). Par principe de sous-optimalit\u00e9, si \\(C\\) est optimal, \\(C_{i,k}\\), \\(C_{k,j}\\) aussi.</li> </ul> <p>Cela nous donne la relation de r\u00e9currence \\(\\color{red}{W_{i,j}^k = \\min(W_{i,j}^{k-1}, W_{i,k}^{k-1} + W_{k,j}^{k-1})}\\), pour tous \\(i, j\\) et \\(k\\) dans \\(\\{1, 2, \\dots, n\\}\\). Ainsi on r\u00e9sout les sous-probl\u00e8mes par valeur de \\(k\\) croissante.</p>"},{"location":"Graphes/pcc/#pseudo-code","title":"Pseudo-code","text":""},{"location":"Graphes/pcc/#1er","title":"1er","text":"<p>Inconv\u00e9nients : on cr\u00e9e une matrice \u00e0 chaque it\u00e9ration. Co\u00fbteux en m\u00e9moire.</p> <pre><code>fonction FloydWarshall(G)\n    entree: un graphe orient\u00e9 pond\u00e9r\u00e9 G\n    sortie: la matrice des plus courts chemins W^n\n    W\u2070 \u27f5 matrice n*n d'adjacence pond\u00e9r\u00e9e\n    pour k allant de 1 \u00e0 n faire\n        cr\u00e9er une matrice W^k\n        pour i allant de 1 \u00e0 n faire\n            pour j allant de 1 \u00e0 n faire\n                W^k_{i,j} \u27f5 min(W^{k-1}_{i,j}, W^{k-1}_{i,k} + W^{k-1}{k,j})\n\n    renvoyer W^n\n</code></pre>"},{"location":"Graphes/pcc/#2nd","title":"2nd","text":"<p>Avantage : il n'y a plus qu'une matrice modifi\u00e9e \u00e0 chaque it\u00e9ration</p> <p>Complexit\u00e9 temporelle en \\(\\Theta(n^3)\\) (triple boucle toujours parcourue)</p> <p>Complexit\u00e9 en m\u00e9moire de l'ordre du nombre de coefficients, donc \\(\\Theta(n^2)\\)</p> <pre><code>fonction FloydWarshall(G)\n    entree: un graphe orient\u00e9 pond\u00e9r\u00e9 G\n    sortie: la matrice des plus courts chemins W^n\n    W &lt;- matrice n*n d'adjacence pond\u00e9r\u00e9e\n    pour k allant de 1 \u00e0 n faire\n        pour i allant de 1 \u00e0 n faire\n            pour j allant de 1 \u00e0 n faire\n                W_{i,j} \u27f5 min(W_{i,j}, W_{i,k} + W_{k,j})\n\n    renvoyer W\n</code></pre> Exemple <p>Graphe : <pre><code>graph LR\nA(1) -- -2 --&gt; C(3)\nB(2) -- 4 --&gt; A\nB -- 3 --&gt; C\nC -- 2 --&gt; D\nD -- -1 --&gt; B</code></pre></p> <p>Initialisation :</p> \\[\\begin{pmatrix} 0 &amp; +\\infty &amp; -2 &amp; +\\infty \\\\ 4 &amp; 0 &amp; 3 &amp; +\\infty \\\\ +\\infty &amp; +\\infty &amp; 0 &amp; 2 \\\\ +\\infty &amp; -1 &amp; +\\infty &amp; 0 \\end{pmatrix}\\] <p>Chemins :</p> \\[\\begin{pmatrix} 13 &amp; \\\\ 21 &amp; 23\\\\ 34 &amp; \\\\ 42 &amp; \\\\ \\end{pmatrix}\\] <p>Pas de circuit de poids n\u00e9gatif. On ne fera pas mieux que 0 pour aller de x \u00e0 x.</p> <p>Sommets interm\u00e9diaires dans \\(\\{1\\}\\):</p> \\[\\begin{pmatrix} 0 &amp; +\\infty &amp; -2 &amp; +\\infty \\\\ 4 &amp; 0 &amp; min(\\textbf{3}, \\textbf{4}, \\textbf{-2}) &amp; +\\infty \\\\ +\\infty &amp; +\\infty &amp; 0 &amp; 2 \\\\ +\\infty &amp; -1 &amp; +\\infty &amp; 0 \\end{pmatrix}\\] <p>Chemins :</p> \\[\\begin{pmatrix} 13 &amp; \\\\ 21 &amp; \\textbf{213}\\\\ 34 &amp; \\\\ 42 &amp; \\\\ \\end{pmatrix}\\] <p>Sommets interm\u00e9diaires dans \\(\\{1; 2\\}\\):</p> \\[\\begin{pmatrix} 0 &amp; +\\infty &amp; -2 &amp; +\\infty \\\\ 4 &amp; 0 &amp; 2 &amp; +\\infty \\\\ +\\infty &amp; +\\infty &amp; 0 &amp; 2 \\\\ min(+\\infty, \\textbf{-1+4}) &amp; -1 &amp; min(+\\infty, \\textbf{-1+2}) &amp; 0 \\end{pmatrix}\\] <p>Chemins :</p> \\[\\begin{pmatrix} 13 &amp; \\\\ 21 &amp; 213\\\\ 34 &amp; \\\\ 42 &amp; \\textbf{421} &amp; \\textbf{4213} \\\\ \\end{pmatrix}\\] <p>Sommets interm\u00e9diaires dans \\(\\{1; 2; 3\\}\\):</p> \\[\\begin{pmatrix} 0 &amp; +\\infty &amp; -2 &amp; min(+\\infty, \\textbf{-2+2}) \\\\ 4 &amp; 0 &amp; 2 &amp; min(+\\infty, \\textbf{2+2}) \\\\ +\\infty &amp; +\\infty &amp; 0 &amp; 2 \\\\ 3 &amp; -1 &amp; 1 &amp; 0\\\\ \\end{pmatrix}\\] <p>Chemins : </p> \\[\\begin{pmatrix} 13 &amp; \\textbf{134} &amp; \\\\ 21 &amp; 213 &amp; \\textbf{2134}\\\\ 34 &amp; &amp; \\\\ 42 &amp; 421 &amp; 4213 \\\\ \\end{pmatrix}\\] <p>Sommets interm\u00e9diaires dans \\(\\{1; 2; 3; 4\\}\\):</p> \\[\\begin{pmatrix} 0 &amp; min(+\\infty, \\textbf{0-1}) &amp; -2 &amp; 0 \\\\ 4 &amp; 0 &amp; 2 &amp; 4 \\\\ min(+\\infty, \\textbf{3+2}) &amp; min(\\infty, \\textbf{-1+2}) &amp; 0 &amp; 2 \\\\ 3 &amp; -1 &amp; 1 &amp; 0\\\\ \\end{pmatrix}\\] <p>Chemins :</p> \\[\\begin{pmatrix} 13 &amp; 134 &amp; \\textbf{1342}\\\\ 21 &amp; 213 &amp; 2134\\\\ 34 &amp; \\textbf{342} &amp; \\textbf{3421} \\\\ 42 &amp; 421 &amp; 4213 \\\\ \\end{pmatrix}\\] <p>k=4 : On s'arr\u00eate l\u00e0</p>"},{"location":"Graphes/pcc/#floyd-warshall-fermeture-transitive","title":"Floyd-Warshall : Fermeture transitive","text":"<p>Le probl\u00e8me de la fermeture transitive dans un graphe non pond\u00e9r\u00e9 \\(G =(V,E)\\) consiste \u00e0 d\u00e9terminer si deux sommets \\(a\\) et \\(b\\) peuvent \u00eatre reli\u00e9s par un chemin allant de \\(a\\) \u00e0 \\(b\\).</p> <p>Pour cela, on utilise la matrice d'adjacence boul\u00e9enne \\(W\\) dans laquelle \\(W_{i,j}\\) vaut \\(\\textbf{true}\\) si il existe un chemin allant de \\(i\\) \u00e0 \\(j\\) et \\(\\textbf{false}\\) sinon.</p> <p>La relation de r\u00e9currence devient :</p> \\[W_{i,j}^k \\leftarrow W_{i,j}^{k-1} \\lor (W_{i,k}^{k-1} \\land W_{k,j}^{k-1})\\] <p>On ne cherche pas la longueur d'un chemin mais seulement s'il en existe un.</p> <p>Correction de Floyd-Warshall lorsque G ne contient pas de cycle de poids strictement n\u00e9gatif</p> <p>Invariant : \\(W^k_{i,j}\\) est \u00e9gal au poids d'un chemin minimal reliant \\(v_i\\) \u00e0 \\(v_j\\) et ne passant que par des sommets interm\u00e9diaires de la liste \\(v_1, \\dots, v_k\\). </p> <p>Cas de base : Vrai si \\(k = 0\\) car \\(W^k_{i,j}\\) est le poids du chemin minimal qui relie \\(v_i\\) \u00e0 \\(v_j\\) sans passer par aucun sommet interm\u00e9diaire. OK</p> <p>Si \\(k &lt; n\\), on suppose l\u2019invariant r\u00e9alis\u00e9 et on consid\u00e8re \\(C = v_i \\rightsquigarrow v_j\\)  un \\(PCC\\) ne passant que par les sommets interm\u00e9diaire \\(v_1, \\dots, v_{k+1}\\). </p> <ul> <li>Si \\(C\\) ne passe pas par \\(v_{k+1}\\), alors, par HR, son poids est \\(W^{k+1}_{i,j} = W^k_{i,j}\\). </li> <li>S\u2019il passe par \\(v_{k+1}\\), alors il n\u2019y passe qu\u2019une fois (pas de circuit de poids n\u00e9gatif). Il se d\u00e9compose en \\(C_1 = v_i \\rightsquigarrow v_{k+1}\\) et \\(C_2 = v_{k+1} \\rightsquigarrow v_j\\) qui sont des chemins ne passant que par des sommets dans \\(v_1, \\dots, v_{k}\\) . Par principe d\u2019optimalit\u00e9, ces chemins sont les meilleurs ne passant que par \\(v_1, \\dots, v_{k}, v_{k+1}\\). Donc, par HR, leurs poids sont \\(W^k_{i,k+1}\\) et \\(W^k_{k+1,j}\\). Le poids de \\(C\\) est donc \\(W^k_{i,k+1} + W^k_{k+1,j}\\).</li> <li>Finalement, \\(min(w^k_{i,j}, W^k_{i,k+1} + W^k_{j+1,j})\\) est le poids minimal d'un chemin reliant \\(v_i\\) \u00e0 \\(v_j\\) et ne passant que par les sommets interm\u00e9diaire \\(v_1, \\dots, v_{k+1}\\). </li> </ul> <p>Si \\(k=n\\), \\(W\\) contient les longueurs de tous les \\(PCC\\). </p>"},{"location":"Graphes/pcc/#algorithme-de-dijkstra","title":"Algorithme de Dijkstra","text":""},{"location":"Graphes/pcc/#presentation_1","title":"Pr\u00e9sentation","text":"<p>Calcule, dans un graphe orient\u00e9 pond\u00e9r\u00e9 par des r\u00e9els positifs, les plus courts chemins \u00e0 partir d'une source unique en direction de tous les autres sommets.</p> <p>D\u00fb \u00e0 l'informaticien n\u00e9erlandais Edsger Dijkstra (par ailleurs prix Turing), publi\u00e9 en 1959.</p> <p>Comme les arcs sont de poids positifs, on peut supprimer les boucles : passer par une boucle ne raccourcira jamais un chemin. Dans la suite, nos graphes sont sans boucle.</p>"},{"location":"Graphes/pcc/#necessite-de-la-valuation-positive","title":"N\u00e9cessit\u00e9 de la valuation positive","text":"<p>On serait tent\u00e9, si un graphe poss\u00e8de des valuations positives, d\u2019ajouter une m\u00eame constante \u00e0 chaque valuation pour les rendre toutes positives afin d\u2019appliquer l\u2019algorithme de Dijkstra.</p> <p>Malheureusement cette approche permet certes de trouver les PCC dans le nouveau graphe mais le chemin suivi peut tr\u00e8s bien ne pas \u00eatre le meilleur dans l\u2019ancien.</p> <p>Consid\u00e9rons  <pre><code>graph LR\nA(x) --2--&gt; B(y)\nB -- -4 --&gt; C(z)\nA -- 1 --&gt; C</code></pre> Le \\(PCC\\) de \\(x\\) \u00e0 \\(z\\) passe par \\(y\\).</p> <p>Ajoutons 4 \u00e0 toutes les valuations <pre><code>graph LR\nA(x) --6--&gt; B(y)\nB -- 0 --&gt; C(z)\nA -- 5 --&gt; C</code></pre> Le \\(PCC\\) de \\(x\\) \u00e0 \\(z\\) passe par l'arc \\(\\{x,z\\}\\).</p>"},{"location":"Graphes/pcc/#principe","title":"Principe","text":"<p>\\(G\\) a pour ensemble de sommets \\([\\![ 1, n ]\\!]\\)</p> <p>On cherche les \\(PCC\\) depuis la source (ou entr\u00e9e) \\(e\\) vers tous les autres sommets.</p> <p>Principe :</p> <ul> <li>A chaque tour, on choisit parmi tous les sommets verts celui dont la distance \u00e0 l'enr\u00e9e est la plus petite(le plus court chemin). Ce sommet devient rouge.</li> <li>Tout voisin bleu du sommet choisi est ajout\u00e9 \u00e0 l'ensemble des sommets verts (en ce sens c'est un parcours en largeur). Les informations concernant les distances \u00e0 la source des voisins du sommet qui vient de devenir rouge sont mises \u00e0 jour.</li> </ul> <p>C'est un algorithme glouton dont le r\u00e9sultat est optimal. Nous avons vu qu'il existe des algos gloutons non optimaux(par exemple pour la coloration).</p> <p>L'ensemble des sommets verts est not\u00e9 \\(F\\) car il est souvent impl\u00e9ment\u00e9 avec un file de priorit\u00e9. Graphe \\(G = (S,A)\\)</p> <pre><code>F := {e} /*sommets en cours de traitement (=verts)*/\nE := \u2205 /*sommets trait\u00e9s = sommets rouges*/\nD := tableau des distances minimales (d_e = 0, k \u2260 e \u21d2 d_k = +\u221e)\ntant que F \u2260 \u2205 faire\n    choisir k \u2208 F avec d_k minimal\n    F := F \\ {k}\n    E := E \u222a {k} /*k devient rouge*/\n    pour tout voisin v de k non rouge faire\n        si v \u2209 F /*si v est bleu*/\n            F := F \u222a {v} /*v devient vert*/\n        fin si\n        si d_k + w(k \u27f6 v) &lt; d_v\n            /*passer par k pour atteindre v est plus rentable*/\n            d_v := d_k + w(k \u27f6 v) /*maj tab. des distances*/\n        fin si\n    fin faire\nfin faire\n</code></pre>"},{"location":"Graphes/pcc/#variant","title":"Variant","text":"<p>Pour un graphe \\(G (S, A)\\), on note \\(B=S \\setminus (F \\cup E)\\) l'ensemble des sommets bleus.</p> <ul> <li>Variant : \\(|F| + |B|\\) (cardinal de l'ensemble de sommets verts ou bleus). Quantit\u00e9 enti\u00e8re positive.</li> <li> <p>C'est une quantit\u00e9 d\u00e9croissante strictement \u00e0 la fin de chaque tour de boucle car :</p> <ul> <li>on retire toujours un sommet de \\(F\\) (si ce n'est pas possible, \\(F=\\emptyset\\) et l'algorithme s'arr\u00eate).</li> <li>tout sommet ajout\u00e9 \u00e0 \\(F\\) est retir\u00e9 de \\(B\\).</li> <li>ainsi, l'ensemble de  s sommets verts ou bleus comporte un \u00e9l\u00e9ment de moins \u00e0 la fin d'un tour par rapport au tour pr\u00e9c\u00e9dent.</li> </ul> </li> </ul> <p>Exemple</p> <p>On g\u00e8re en plus un tableau \\(P\\) (pr\u00e9d\u00e9cesseur) qui garde en m\u00e9moire la derni\u00e8re \u00e9tape sur le chemin de la source au sommet consid\u00e9r\u00e9.</p> <p><p></p></p> \\[  \\begin{array}{c|c|c|c} \\text{F} &amp; \\text{E} &amp; \\text{T} &amp; \\text{P} \\\\ \\hline \\{1\\} &amp; \\emptyset &amp; [\\![0; \\infty; \\infty; \\infty ; \\infty ]\\!] &amp; [\\![ 1,-1,-1,-1,-1]\\!] \\\\ \\{2; 5\\} &amp; \\{1\\} &amp; [\\![0; 12; \\infty; \\infty ; 5 ]\\!] &amp; [\\![ 1,1,-1,-1,1]\\!] \\\\ \\{2;3;4\\} &amp; \\{1;5\\} &amp; [\\![0; 6; 9; 7 ; 5 ]\\!] &amp; [\\![ 1,5,5,5,1]\\!] \\\\ \\{3;4\\} &amp; \\{1;5;2\\} &amp; [\\![0; 6; 8; 7 ; 5 ]\\!] &amp; [\\![ 1,5,2,5,1]\\!] \\\\ \\{3\\} &amp; \\{1;5;2;4\\} &amp; [\\![0; 6; 8; 7 ; 5 ]\\!] &amp; [\\![ 1,5,2,5,1]\\!] \\\\ \\emptyset &amp; \\{1;5;2;4;3\\} &amp; [\\![0; 6; 8; 7 ; 5 ]\\!] &amp; [\\![ 1,5,2,5,1]\\!] \\\\ \\end{array} \\] <p>\\(PCC\\) pour aller de 1 \u00e0 3 :</p> <ul> <li>On a \\(T = [\\![0; 6; 8; 7 ; 5 ]\\!]\\) et \\(P = [\\![ 1,5,2,5,1]\\!]\\).</li> <li>pr\u00e9decesseur de \\(3\\) : \\(P[3] = 2\\).</li> <li>pr\u00e9decesseur de \\(2\\) : \\(P[2] = 5\\).</li> <li>pr\u00e9decesseur de \\(5\\) : \\(P[5] = 1\\).</li> <li>Donc \\(1523\\) avec un co\u00fbt de 8.</li> </ul>"},{"location":"Graphes/pcc/#correction","title":"Correction","text":"<p>Pour un graphe \\(G\\) d'ensemble de sommets \\(S\\), notons \\(D\\) le tableau des distances et \\(\\delta(e,u)\\) la longueur d'un \\(PCC\\) de \\(e\\) \u00e0 \\(u\\), \\(w(a, b)\\) le poids de l'arc \\(a \\rightarrow b\\).</p> <p>Th\u00e9or\u00e8me</p> <p>A la fin de l'Algorithme de Dijkstra, on a \\(d_u = \\delta(e, u)\\) pour tout sommet \\(u \\in S\\).</p> <p>Notations</p> <p>On note \\(F^k; E^k, d_u^k\\) les valeurs de \\(F, E, d_u\\) \u00e0 la fin de l'it\u00e9ration \\(k\\).</p> <p>\\(F^k\\) est l'ensemble des sommets verts \u00e0 la fin de l'it\u00e9ration \\(k\\), \\(E^k\\) l'ensemble des sommets rouges et \\(S \\setminus (F^k \\cup E^k)\\) l'ensemble des sommets bleus.</p> <p>Un sommet \\(u\\) est bleu \u00e0 la fin de l'\u00e9tape \\(k\\) si et seulement si \\(d_u = +\\infty\\) si et seulement si \\(u\\) n'est voisin d'aucun sommet rouge \u00e0 la fin de l'\u00e9tape \\(k\\).</p> <p>Pour tout sommet \\(u \\in S\\), \\(d_u &lt; +\\infty\\) documente un chemin de \\(e\\) \u00e0 \\(u\\) n'empruntant que des sommets verts ou rouges.</p> <p>Rappel</p> <p>A la fin du parcours, les sommets accessibles depuis \\(e\\) sont dans \\(E\\)</p> <p>Invariant de boucle :</p> <ol> <li>Sommets rouges : \\(\\forall u \\in E^k, d_u^k = \\delta(e, u)\\) (point 1)</li> <li>Sommet \\(v\\) vert ou bleu diff\u00e9rents de \\(e\\) : \\(d_v^k = min(\\{d_u^k + w(u, v) | u \\in E^k\\})\\) ce qui revient par le point 1 \u00e0 \\(d_v^k = min(\\{\\delta(e, u) + w(u, v) | u \\in E^k\\})\\) (point 2)</li> </ol> <p>Remarque</p> <p>La distance \\(d^k_v\\) est donc le poids minimal d'un chemin vert-rouge de \\(e\\) \u00e0 \\(v\\) dont l'avant dernier sommet est rouge.</p> <p>Pour un sommet bleu \\(v\\) \u00e0 l'\u00e9tape k, les \\(w(u, v)\\) pour \\(u\\) rouge \u00e9tant infinis(car \\(v\\) n'est pas voisin d'un rouge), on retrouve que \\(d_v^k = +\\infty\\).</p> <p>Cas de base :</p> <ul> <li> <p>Au tour 0 (avant la boucle) :</p> <ul> <li>L'ensemble des sommets rouge est vide, donc pour un sommet \\(v \\neq e\\) le minimum des sommes \\(\\delta(u,v) + w(u,v)\\) pour les u rouges est infini. Or \\(d_v^0 = +\\infty\\) : Point 2 OK.</li> <li>Le point 1 est vrai car il n'y a pas de sommet rouge.</li> </ul> </li> <li> <p>A la fin du 1er tour de boucle \\(e\\) est rouge, \\(d_e^1 = 0 = \\delta(e, e)\\) (Point 1 OK) et \\(d_v^1 = w(e,v)\\) pour tout \\(v \\neq e\\) donc \\(d_v^1 = min(\\{\\delta(e, u) + w(e,v) | u \\in E^1\\})\\) (Point 2 OK) puisque seul \\(e\\) est rouge.</p> </li> </ul> <p>H\u00e9r\u00e9dit\u00e9 (pour le point 1) :</p> <p>Soit \\(u\\) un sommet rouge \u00e0 la fin de l'\u00e9tape \\(k+1(k \\geq 1)\\).</p> <ul> <li>On a \\(d_u^{k+1} = d_u^k\\) (pas de changement dans le tableau des distances).</li> <li>Comme \\(u\\) est rouge, il est accessible, donc \\(d_u^{k+1}\\) est fini, donc le chemin qui le document n'emprunte que des sommets verts ou rouges.</li> <li>Si \\(u \\notin E^{k+1}\\setminus E^k\\), c'est \u00e0 dire si \\(u\\) n'est pas le sommet qu'on vient de rendre rouge, alors \\(u in E^k\\) et par HR \\(d_u^k = \\delta(e, u)\\) (Point 1 OK).</li> <li> <p>Si \\(u\\) entre dans \\(E^{k+1}\\) alors au d\u00e9but du passage \\(k+1\\), \\(u\\) est vert (\\(u \\in F^k\\)) et \\(d_u^k \\leq d_s^k\\) pour tout sommet vert \\(s\\) (car \\(u\\) est choisi).</p> <ul> <li>Soit \\(\\color{red}{e \\rightsquigarrow \\textit{u} \\text{ un PCC et } \\textit{v} \\text{ son premier sommet non rouge}}\\) (\\(u=v\\) possible). Les sous chemins \\(e \\rightsquigarrow v\\) et \\(v \\rightsquigarrow u\\) sont des PCC par principe d'optimalit\u00e9. Comme les poids des arcs sont positifs (condition Dijkstra), il vient que \\(\\color{red}{\\delta(e, u) \\geq \\delta(e, v)}\\).</li> <li>\\(\\color{red}{\\text{Le pr\u00e9d\u00e9cesseur } \\textit{r} \\text{ de } \\textit{v} \\text{ dans } e \\rightsquigarrow v \\text{ est rouge et diff\u00e9rent de u}}\\) \\(\\color{red}{\\text{ donc } d_r^k = \\delta(e, r) \\text{par HR.}}\\)</li> <li>\\(\\color{red}{\\text{Comme } \\textit{v} \\text{ n'est pas rouge, il v\u00e9rifie le point 2}}\\) donc </li> </ul> \\[ \\begin{align}\\nonumber     d_v^k &amp; \\space\\space\\space\\space\\space\\space = \\space\\space\\space\\space min(\\{\\delta(e,x) + w(x,v) | x \\in E^k\\})\\text{ par HR.(2)}\\\\ \\nonumber     &amp;\\underbrace{=}_{e\\rightsquigarrow r \\rightarrow v \\text{ PCC}} \\delta(e, r) + w(r, v) = \\delta(e,v)\\\\ \\end{align} \\\\ \\color{red}\\text{Ainsi } d^k_v = \\delta(e,v) \\] <ul> <li>\\(\\color{red}{\\text{On a } \\delta(e,u) \\geq \\delta(e,v)}\\). Et \\(d^k_v \\geq d^k_u\\) car \\(u\\) est choisi. Or, \\(d_u^k\\) est le poids d'un chemin de \\(e\\) \u00e0 \\(u\\) donc plus grand que \\(\\delta(e,u)\\) alors</li> </ul> \\[     \\delta(e,u) \\geq \\delta(e,v) = d^k_v \\geq d^k_u \\geq \\delta(e,u) \\textbf{ Point 1 OK} \\] </li> </ul> <p>H\u00e9r\u00e9dit\u00e9 (pour le point 2) :</p> <p>Soit \\(v\\) un sommet vert ou bleu \u00e0 la fin de l'\u00e9tape \\(k+1\\) \\(\\color{red}{\\text{non voisin}}\\) de l'\u00e9l\u00e9ment \\(u\\) qui entre dans \\(E^{k+1}\\).</p> <ul> <li>Alors \\(d_v^k = d^{k+1}_v\\) car \\(d^k_u + w(u,v) = +\\infty\\)</li> <li> <p>On a :</p> \\[ \\begin{align}     D^{k+1}_v &amp;= d^k_v&amp; \\\\ \\nonumber     &amp;= min(\\{\\delta(e, x) + w(x, v) | x \\in \\underbrace{E^{k+1}}_{E^{k+1}\\backslash\\{u\\}}\\})&amp;\\\\ \\nonumber     &amp;= min(\\{\\delta(x,k) + w(x, v) | x \\in E^k\\}\\cup\\{\\underbrace{\\delta(e,u)+w(u,v)}_{=+\\infty}\\}) &amp;\\\\ \\nonumber     &amp;= min(\\{\\delta(e,x) + w(x, v) | x \\in E^{k+1}\\})\\color{red}{\\text{ : Point 2 OK}} \\nonumber \\end{align} \\] </li> </ul> <p>Soit \\(v\\) vert ou bleu \u00e0 la fin de l'\u00e9tape \\(k+1\\) et \\(\\color{red}{\\text{voisin}}\\) de l'\u00e9l\u00e9ment rouge \\(u\\) entrant dans \\(E^{k+1}\\).</p> <ul> <li> <p>Le sommet \\(v\\) est vert ou bleu \u00e0 l'\u00e9tape \\(k\\) mais vert \u00e0 l'\u00e9tape \\(k+1\\).</p> <ul> <li>\\(d_v^k = min(\\{\\delta(e, x) + w(x, v) | x \\in E^k\\})\\) par HR.2</li> <li>\\(d_v^{k+1} = min(d^k_v, \\underbrace{d_u^k}_{=\\delta(e,u)\\text{ par HR.1}} + w(u,v))\\) par algo Dijkstra</li> </ul> </li> <li> <p>On a donc encore</p> \\[     d^{k+1}_v = min(\\{\\delta(e, x) + w(x, v) | x \\in \\underbrace{E^{k+1}}_{E^k\\cup\\{u\\}}\\}) \\textbf{ Point 2 OK }\\text{dans ce cas} \\] </li> </ul>"},{"location":"Graphes/pcc/#complexite-pour-une-source-e","title":"Complexit\u00e9 pour une source e","text":""},{"location":"Graphes/pcc/#force-brute-pour-un-graphe-de-n-sommets-et-p-arcs","title":"Force brute pour un graphe de n sommets et p arcs","text":"<pre><code>F := {e}; E := \u2205; D := tableau des distances minimales;\ntant que F non vide faire\n    Choisir k dans F avec d_k minimal /*explorer D en O(n)*/\n    F := F\\{k}; E := E\u222a{k}; /*MAJ en O(1) si E,F tableaux*/\n    pour tout voisin r de k non rouge faire\n        si r \u2209 F faire /* cas r bleu*/\n            F := F\u222a{r}; /*O(1)*/\n        si d_k + w(k \u27f6 r) &lt; d_r faire\n            d_r := d_k + w(k \u27f6 r); /*maj tableau des distances en O(1)*/\n</code></pre> <p>Au plus \\(n\\) transferts de \\(F\\) vers \\(E\\) (ligne L4). Pour chacun recherche (ligne L3) du plus petit \u00e9l\u00e9ment vert dans le tableau des distances : \\(O(n)\\)</p> <p>(L5 \u00e0 L9) Co\u00fbt des v\u00e9rifications et mises \u00e0 jour pour un sommet \\(k\\) : \\(O (deg^{+} k )\\). Au total, complexit\u00e9 en multiple de : \\(n + \\sum_{k = 0}^{n-1} (n + deg^{+} k) = n + n^2 + p = O(n^2)\\text{ (Rappel : }p = O(n\u00b2))\\)</p>"},{"location":"Graphes/pcc/#avec-file-de-priorite-pour-un-graphe-de-n-sommets-et-p-arcs","title":"Avec file de priorit\u00e9 pour un graphe de n sommets et p arcs","text":"<p>Puisqu\u2019on g\u00e8re un ensemble \\(F\\) des sommets verts et un tableau \\(D\\) des distances \u00e0 la source, on peut les fusionner en une seule file de priorit\u00e9 \\(T\\) d\u2019\u00e9l\u00e9ments \\((s ,d (e,s ))\\).</p> <p>On implante les files de priorit\u00e9 comme des tas. On consid\u00e8re donc un tas-min (fils plus grands que p\u00e8re). Cr\u00e9ation par descente en \\(O (n)\\). On g\u00e8re en interne \\(\\color{red}{\\text{un tableau des positions dans le tas}}\\) pour obtenir en \\(O (1)\\) la position d'un sommet dans \\(T\\) en vue d'une MAJ.</p> <pre><code>E := \u2205; /*sommets rouges*/\nT := tas-min des couples (sommet, distance depuis e); /*O(n)*/\ntant que T \u2260 \u2205 :\n    retirer le sommet (k, d(e,k)) du tas T /*O(ln n)*/\n    E := E\u222a{k};\n    pour tout voisin r de k non trait\u00e9 :\n        /*nb passages : deg^+ k*/\n        si d(e,k)+w(k \u27f6 r) &lt; d(e,r): /*O(1)*/\n            MAJ T avec d(e,r) := d(e,k)+w(k \u27f6 r) /*O(ln n)*/\n</code></pre> <ul> <li>Complexit\u00e9 de chaque acc\u00e8s/maj dans la file major\u00e9 en \\(O (\\log n)\\). La file de priorit\u00e9 contient au plus \\(n\\) \u00e9l\u00e9ments.</li> <li>Par passage dans la boucle <code>while</code> : choix puis suppression du sommet \\(k\\) le plus prioritaire : \\(O(\\log n)\\). Pour ses \\(deg^{+} k\\) voisins, au plus \\(deg^{+} k\\) maj de cl\u00e9s. Donc co\u00fbt pour \\(k\\) en \\(O((1+deg^{+}k)\\log n)\\). Co\u00fbt total </li> </ul> \\[ \\underbrace{n}_{\\text{cr\u00e9ation du tas}} + \\sum_{e=0}^{n-1} (deg^{+} k + 1) \\log n = \\newline n + n \\log n + \\log n \\sum_{e=0}^{n-1} (deg^{+} k) \\leq n \\log n + p \\log n \\] <ul> <li>Complexit\u00e9 en \\(O((n + p) \\log n)\\)</li> <li>Si \\(p \\log n = O(n^2)\\), c'est \u00e0 dire si \\(p = O(\\frac{n^2}{\\log n})\\), la complexit\u00e9 avec file de priorit\u00e9s est au moins aussi bonne qu'en force brute.</li> <li>Si le graphe est creux (peu d'ar\u00eates), \\(p=O(n)\\), et donc la complexit\u00e9 avec file de priorit\u00e9 est \\(O(n \\log n)\\).</li> <li>Mais si le graphe est dense (par exemple complet) il y a un nombre d'arc ou d'ar\u00eates en \\(p=O(n^2)\\), et donc la complexit\u00e9 avec file de priorit\u00e9 est \\(O(n^2 \\log n)\\). Dans ce cas, l'impl\u00e9mentation par file de priorit\u00e9 n'est pas int\u00e9ressante.</li> </ul>"},{"location":"Linux/Linux/","title":"Linux","text":"<p>Danger</p> <p>Ce cours n'a pas \u00e9t\u00e9 enti\u00e8rement reverifi\u00e9 apr\u00e8s le passage du programme. Pensez \u00e0 supprimer ce message si vous avez reverifi\u00e9 ce cours</p> <p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Syst\u00e8me d\u2019exploitation  Pr\u00e9sentation de Linux  Syst\u00e8me de fichiers  Vue logique  Les principaux r\u00e9pertoires syst\u00e8mes  Le shell bash  </p>"},{"location":"Linux/Linux/#avant-propos","title":"Avant-propos","text":"<p>Ces transparents constituent une toute petite introduction forc\u00e9ment non  exhaustive au syst\u00e8me Linux. Ils sont pr\u00e9sent\u00e9s pour faciliter le quotidien  des \u00e9tudiants de MP2I dans l\u2019\u00e9laboration de leurs programmes en cours  d\u2019ann\u00e9e. On y donne notamment des pr\u00e9cisions sur les principaux r\u00e9pertoires sous Linux les commandes de survie dans le shell bash. On n\u2019y trouve pas d\u2019explication sur ce qu\u2019est un disque logique ni sur la  notion d\u2019inode. Un futur document traitera des droits et redirections.  </p>"},{"location":"Linux/Linux/#credits","title":"Cr\u00e9dits","text":"<p>Un historique de Linux Un cours sur Linux tr\u00e8s complet : Linux France et un autre : Telecom  Paris Des pr\u00e9cisions sur l\u2019architecture des fichiers sous Linux ici et la  nomenclature des syst\u00e8mes de fichiers l\u00e0. Un cours du MIT  </p>"},{"location":"Linux/Linux/#_1","title":"Linux","text":""},{"location":"Linux/Linux/#presentation","title":"Pr\u00e9sentation","text":"<p>Figure \u2013 Le syst\u00e8me d\u2019exploitation est un interm\u00e9diaire entre les logiciels d\u2019application et le mat\u00e9riel (WIKIPEDIA).</p> <p>Un syst\u00e8me d\u2019exploitation (en anglais operating system (OS) ) est un  ensemble de programmes qui dirige l\u2019utilisation des ressources d\u2019un  ordinateur par des logiciels applicatifs.  L\u2019OS fournit aux programmes utilisateurs un acc\u00e8s unifi\u00e9 aux  ressources mat\u00e9rielles et logicielles (p\u00e9riph\u00e9riques, m\u00e9moire, autres  programmes). Il o\ufb00re un ensemble de fonctions  \"primitives\" permettant d\u2019interagir avec le mat\u00e9riel.  </p>"},{"location":"Linux/Linux/#composants-logiciels-dun-os","title":"Composants logiciels d\u2019un OS","text":"<p>On trouve notamment : l\u2019ordonnanceur : d\u00e9cide quel programme s\u2019ex\u00e9cute \u00e0 un moment  donn\u00e9 sur le processeur ; le gestionnaire de m\u00e9moire, qui r\u00e9partit la m\u00e9moire vive entre les  di\ufb00\u00e9rents programmes en cours d\u2019ex\u00e9cution ; les di\ufb00\u00e9rents syst\u00e8mes de fichiers qui d\u00e9finissent la mani\u00e8re de stocker  les fichiers sur les supports physiques (disque dur, cl\u00e9 USB, disque  optique etc.) ; la pile r\u00e9seau qui impl\u00e9mente des protocoles de communication  comme TCP/IP ; les pilotes de p\u00e9riph\u00e9riques (driver) qui g\u00e8rent les p\u00e9riph\u00e9riques  mat\u00e9riels (souris, clavier, carte 3D etc.)  </p>"},{"location":"Linux/Linux/#standard-posix","title":"Standard POSIX","text":"<p>La palette des services o\ufb00erts et la mani\u00e8re de s\u2019en servir di\ufb00\u00e8rent  d\u2019un syst\u00e8me d\u2019exploitation \u00e0 l\u2019autre. Le standard industriel POSIX du IEEE d\u00e9finit une suite d\u2019appels  syst\u00e8mes standard. POSIX est largement inspir\u00e9 de UNIX. Un logiciel applicatif qui e\ufb00ectue des appels syst\u00e8me selon POSIX  pourra \u00eatre utilis\u00e9 sur tous les syst\u00e8mes d\u2019exploitation conformes \u00e0 ce  standard. Tous les syst\u00e8mes de type LINUX sont compatibles POSIX de m\u00eame  que Android, macOS, iOS mais pas Windows : alors que les premiers  d\u00e9rivent de UNIX, Windows d\u00e9rive de MS-DOS dont la philosophie  est di\ufb00\u00e9rente.  </p>"},{"location":"Linux/Linux/#extension-des-noms-de-fichiers","title":"Extension des noms de fichiers","text":"<p>Dans les syst\u00e8mes POSIX, l\u2019extension du nom de ficheir (tous les  caract\u00e8res \u00e0 droite du \"\u00b7\" dans le nom du fichier) n\u2019a pas de  signification particuli\u00e8re pour le syst\u00e8me. Mais elle est pratique pour l\u2019utilisateur car il voit bien \u00e0 quel type de  fichier il a \u00e0 faire. Un fichier ex\u00e9cutable n\u2019a pas n\u00e9c\u00e9ssairement un nom se terminant par  .exe  L\u2019utilisation de l\u2019extension pour d\u00e9terminer le type de fichier est une  caract\u00e9ristique de Windows  </p>"},{"location":"Linux/Linux/#_2","title":"Linux","text":""},{"location":"Linux/Linux/#historique-pi","title":"Historique (PI)","text":"<p>Linux ou GNU/Linux : famille de syst\u00e8mes d\u2019exploitation open source  de type Unix fond\u00e9 sur le noyau Linux, cr\u00e9\u00e9 en 1991 par Linus  Torvalds. GNU : projet informatique cr\u00e9\u00e9 en janvier 1984 par Richard  Stallman pour d\u00e9velopper le syst\u00e8me d\u2019exploitation GNU. Chaque  brique du projet est un logiciel libre utilisable en tant que tel mais  dont l\u2019objectif est de s\u2019inscrire dans une logique coh\u00e9rente.  GNU/Linux c\u2019est donc le noyau Linux plus les composantes de GNU. Linux \u00e9quipe une faible part des ordinateurs PC mais beaucoup de  serveurs, t\u00e9l\u00e9phones portables, syst\u00e8mes embarqu\u00e9s ou encore  superordinateurs. Android : syst\u00e8me d\u2019exploitation pour t\u00e9l\u00e9phones portables. Utilise le  noyau Linux mais pas GNU. Equipe 85 % des tablettes tactiles et  smartphones.  </p>"},{"location":"Linux/Linux/#logiciel-libre-pi","title":"Logiciel libre (PI)","text":"<p>Distributions Linux (Ubuntu, Debian, Linux Mint, CentOS ...) :  syst\u00e8mes d\u2019exploitation libres.  Les 4 libert\u00e9s d\u2019un logiciels libres telles que d\u00e9finies par la Free  Software Foundation. On peut : utiliser le logiciel sans restriction,  \u00e9tudier le logiciel  le modifier pour l\u2019adapter \u00e0 ses besoins  le redistribuer sous certaines conditions pr\u00e9cises le non respect de ces r\u00e8gles peut conduire \u00e0 des condamnations.  Certaines licences sont con\u00e7ues selon le principe du copyleft : une  \u0153uvre d\u00e9riv\u00e9e d\u2019un logiciel sous copyleft doit \u00e0 son tour \u00eatre libre.  Licence GNU GPL : logiciel libre + copyleft. Le noyau Linux utilise  cette licence.  Un logiciel libre n\u2019est pas n\u00e9cessairement gratuit, et inversement un  logiciel gratuit n\u2019est pas forc\u00e9ment libre.  </p>"},{"location":"Linux/Linux/#caracteristiques-pi","title":"Caract\u00e9ristiques (PI)","text":"<p>Linux est multi-t\u00e2ches : plusieurs processus peuvent s\u2019ex\u00e9cuter  \"simultan\u00e9ment\". Linux est multi-utilisateur : Chaque personne utilisant le syst\u00e8me  dispose d\u2019un compte, qui peut \u00eatre vu comme une certaine zone qui  lui est allou\u00e9e, accessible par un nom et un mot de passe. Un  m\u00e9canisme de droits un peu contraignant emp\u00eache un utilisateur  d\u2019acc\u00e9der \u00e0 des donn\u00e9es dont il n\u2019a pas les droits. Les droits peuvent \u00eatre modifi\u00e9s. Un utilisateur sp\u00e9cial a tous les droits le super-utilisateur ou  administrateur (super user en anglais).  </p>"},{"location":"Linux/Linux/#utilisateur","title":"Utilisateur","text":"<p>Chaque utilisateur poss\u00e8de un identifiant de connexion (login). On lui  associe un mot de passe. L\u2019ensemble des donn\u00e9es de l\u2019utilisateur (identifiant, mot de passe et  autres m\u00e9tadonn\u00e9es), ainsi que ses fichiers personnels constituent le  compte de l\u2019utilisateur. L\u2019ensemble des interractions de l\u2019utilisateur authentifi\u00e9 avec le  syst\u00e8me est appel\u00e9 une session. Quand l\u2019utilisateur se d\u00e9connecte, on  dit qu\u2019il ferme sa session.  </p> <p>A l\u2019identifiant de connexion correspond un num\u00e9ro d\u2019utilisateur  nomm\u00e9 UID (User IDentifier). L\u2019OS n\u2019utilise que l\u2019UID, l\u2019identifiant  n\u2019est l\u00e0 que par soucis de convivialit\u00e9. Les utilisateurs peuvent \u00eatre r\u00e9unis en groupes. Ces derniers ont un  nom symbolique et un identifiant num\u00e9rique GID (Group IDentifier). Chaque utilisateur a un groupe principal et \u00e9ventuellement des  groupes secondaires. La commande id a\ufb03che les identifiants  num\u00e9riques et les groupes de l\u2019utilisateur courant.  $ id  uid =1000( ivan ) gid =1000( ivan ) groupes =1000( ivan ) ,  4( adm ) ,24( cdrom ) ,27( sudo ) ,30( dip ) ,46( plugdev ) ,  111( lxd ) ,116( lpadmin ) ,131( libvirtd ) ,132( sambashare )  </p>"},{"location":"Linux/Linux/#noyau","title":"Noyau","text":"<p>Noyau de syst\u00e8me d\u2019exploitation (ou noyau, ou kernel en anglais) :  partie fondamentale de certains syst\u00e8mes d\u2019exploitation. G\u00e8re les  ressources de l\u2019ordinateur et permet aux di\ufb00\u00e9rents composants (  mat\u00e9riels et logiciels) de communiquer entre eux.  Le noyau assure : la communication entre les logiciels et le mat\u00e9riel  la gestion des divers logiciels (t\u00e2ches) d\u2019une machine (lancement des  programmes, ordonnancement...)  la gestion du mat\u00e9riel (m\u00e9moire, processeur, p\u00e9riph\u00e9rique, stockage...). Le noyau o\ufb00re ses fonctions (l\u2019acc\u00e8s aux ressources qu\u2019il g\u00e8re) au  travers des appels syst\u00e8me. Il transmet ou interpr\u00e8te les informations  du mat\u00e9riel via des interruptions (appell\u00e9es les entr\u00e9es/sorties).  </p>"},{"location":"Linux/Linux/#processus","title":"Processus \u2665","text":"<p>Processus : programme en cours d\u2019ex\u00e9cution par un ordinateur.  R\u00e9guli\u00e8rement, il a besoin d\u2019acc\u00e9der \u00e0 des ressources prot\u00e9g\u00e9es (comme  une \u00e9criture en m\u00e9moire). Le noyau prend alors le relai du processus pour  rendre le service demand\u00e9 et lui rend le contr\u00f4le lorsque les actions voulues  ont \u00e9t\u00e9 r\u00e9alis\u00e9es.  </p> <p>Syst\u00e8me d\u2019exploitation  Pr\u00e9sentation de Linux  Syst\u00e8me de fichiers  Vue logique  Les principaux r\u00e9pertoires syst\u00e8mes  Le shell bash  </p>"},{"location":"Linux/Linux/#_3","title":"Linux","text":""},{"location":"Linux/Linux/#systeme-de-fichier","title":"Syst\u00e8me de fichier","text":"<p>Syst\u00e8me de fichier : ensemble de conventions et structures permettant de stocker des donn\u00e9es sur un support physique \u2665 Chaque syst\u00e8me de fichier impl\u00e9mente (\u00e0 sa fa\u00e7on) les primitives de manipulation de fichiers g\u00e9n\u00e9riques o\ufb00ertes par le syst\u00e8me d\u2019exploitation :</p> <p>Cr\u00e9ation d\u2019un fichier de nom donn\u00e9 ;  Ouverture d\u2019un fichier en lecture ou \u00e9criture ;  Lecture ou \u00e9criture de portion d\u2019un fichier ;  Suppression d\u2019un fichier ;  Copie ou renommage d\u2019un fichier.  </p>"},{"location":"Linux/Linux/#systemes-de-fichier","title":"Syst\u00e8mes de fichier","text":"<p>Chaque syst\u00e8me de fichier poss\u00e8de ses propres caract\u00e9ristiques et  objectifs. Certains (Samba ou NFS) sont par exemple destin\u00e9s \u00e0  exposer \u00e0 l\u2019utilisateur des fichiers et r\u00e9pertoires se trouvant  physiquement sur une/des machine(s) distante(s). Quelques exemples : Syst\u00e8me de fichier  FAT OS  MSDOS  Windows 95/98 FAT32 (File Allocation Table 32bits)  Windows NT  MAC OS  Linux NTFS (New Technology File System) standard pour les ordinateurs sous Windows depuis VISTA.  HFS+ (High Performance File System)  ext4 (Extended File System)  </p>"},{"location":"Linux/Linux/#systeme-de-fichier_1","title":"Syst\u00e8me de fichier","text":"<p>Fichier : suite d\u2019octets constituant un ensemble coh\u00e9rent (en principe)  d\u2019information. Sous Linux, tout est fichier (m\u00eame le clavier est  consid\u00e9r\u00e9 comme un fichier). R\u00e8gles de nommage Linux : 255 caract\u00e8res au plus, principalement  des lettres et des chi\ufb00res mais . -  \u02dc + % sont aussi autoris\u00e9s.  Les espaces ne sont pas interdits, mais je les d\u00e9conseille de m\u00eame que  les accents.  </p>"},{"location":"Linux/Linux/#repertoires-ou-dossiers","title":"R\u00e9pertoires ou dossiers","text":"<p>Si le syst\u00e8me de fichier \u00e9tait une commode, les r\u00e9pertoires seraient  des tiroirs contenant des fichiers ou des sous-tiroirs.  </p> <p>Un r\u00e9pertoire est un fichier dans lequel se trouve la liste de son \"contenu\" sous la forme (nom du fichier, num\u00e9ro d\u2019inode) \u2665 Dans un r\u00e9pertoire on trouve deux fichiers particuliers not\u00e9s \".\" (r\u00e9pertoire courant) et \"..\" (r\u00e9pertoire parent). \u2665 Le syst\u00e8me de fichier est repr\u00e9sent\u00e9 par un arbre dont la racine est le r\u00e9pertoire root not\u00e9 \"/\" \u2665.</p> <p>Pratique personnelle de nommage pour les r\u00e9pertoires et fichiers  persos : la premi\u00e8re lettre des noms de r\u00e9pertoires en majuscules, celle  des autres fichiers en minuscule : UnNomDeRepertoire , unNomDeFichier .  </p>"},{"location":"Linux/Linux/#exemple-darborescence-de-fichiers","title":"Exemple d\u2019arborescence de fichiers","text":"<p>Figure \u2013 Le syst\u00e8me de fichiers Linux (d\u2019apr\u00e8s malekal)</p>"},{"location":"Linux/Linux/#exemple-personnel","title":"Exemple personnel","text":"<p>Figure \u2013 Une image de mon r\u00e9pertoire home donn\u00e9e par la commande tree</p> <p>L\u2019option -d pour ne lister que les r\u00e9pertoires, l\u2019option -L pour indiquer  la profondeur de r\u00e9cursion.  </p>"},{"location":"Linux/Linux/#_4","title":"Linux","text":""},{"location":"Linux/Linux/#principaux-repertoires","title":"Principaux r\u00e9pertoires","text":"<p>D\u00e9finition</p> <p>/ C\u2019est la racine de l\u2019arborescence \u2665</p> <p>D\u00e9finition</p> <p>/bin stocke les ex\u00e9cutables et binaires essentiels lors du</p> <p>D\u00e9finition</p> <p>/sbin stocke les ex\u00e9cutables et binaires essentiels lors du d\u00e9marrage</p> <p>mais r\u00e9serv\u00e9es au superuser (administrateur syst\u00e8me). \u2665</p> <p>D\u00e9finition</p> <p>/boot stocke les fichiers de d\u00e9marrage Linux \u2665</p> <p>D\u00e9finition</p> <p>/dev (pour devices) les fichiers li\u00e9s aux p\u00e9riph\u00e9riques.</p> <p>D\u00e9finition</p> <p>/etc Les fichiers de configuration de Linux et des applications. \u2665</p> <p>D\u00e9finition</p> <p>/home comptes des utilisateurs. \u2665</p> <p>D\u00e9finition</p> <p>/lib Les librairies et biblioth\u00e8ques partag\u00e9s pour le</p> <p>fonctionnement de l\u2019OS et des applications</p> <p>d\u00e9marrage. Commandes utilisables ensuite par les utilisateurs (ex : cat et ls ). \u2665</p>"},{"location":"Linux/Linux/#les-principaux-repertoires","title":"Les principaux r\u00e9pertoires","text":"<p>D\u00e9finition</p> <p>/usr r\u00e9pertoire des applications partag\u00e9es par di\ufb00\u00e9rentes machines</p> <p>ou utilisateurs. Les programmes dans /usr ne sont pas n\u00e9cessaires au d\u00e9marrage. \u2665</p> <p>D\u00e9finition</p> <p>/media points de montages des m\u00e9dias amovibles (cl\u00e9s USB...)\u2665</p> <p>D\u00e9finition</p> <p>/proc R\u00e9pertoire virtuel avec les informations syst\u00e8me (l\u2019\u00e9tat du</p> <p>syst\u00e8me, noyau Linux, etc) bas\u00e9 sur procfs (process file system)</p> <p>D\u00e9finition</p> <p>/root dossier personnel de l\u2019utilisateur root</p> <p>D\u00e9finition</p> <p>/var Contient des donn\u00e9es mises \u00e0 jour par di\ufb00\u00e9rents programmes</p> <p>durant le fonctionnement du syst\u00e8me (fichiers journaux (log), des fichiers de donn\u00e9es (spool) ou des fichiers de blocage (lock)) \u2665</p> <p>D\u00e9finition</p> <p>/tmp les fichiers temporaires. \u2665</p>"},{"location":"Linux/Linux/#le-repertoire-usr","title":"le r\u00e9pertoire /usr","text":"<p>D\u00e9finition</p> <p>/usr/bin Commandes utilisables par tous les utilisateurs, et non</p> <p>D\u00e9finition</p> <p>n\u00e9cessaires lors du d\u00e9marrage du syst\u00e8me.</p> <p>/usr/sbin Commandes r\u00e9serv\u00e9es au super-utilisateur , et non n\u00e9cessaires lors du d\u00e9marrage du syst\u00e8me. /usr/lib le dossier des librairies utilis\u00e9es par les applications /usr/local applications install\u00e9es localement par l\u2019admnistrateur</p> <p>D\u00e9finition</p> <p>/usr/src Les sources des applications que l\u2019on peut compiler</p> <p>D\u00e9finition</p> <p>/usr/share le dossier avec les fichiers qui peuvent \u00eatre partag\u00e9s avec</p> <p>D\u00e9finition</p> <p>toutes les architectures (i386 -INTEL-, amd64 -AMD-, etc).</p> <p>/usr/local/bin c\u2019est ici que peuvent \u00eatre plac\u00e9s les programmes persos \u00e0</p> <p>D\u00e9finition</p> <p>...</p> <p>Donn\u00e9es des applications des utilisateurs. syst\u00e8me. partager avec d\u2019autres utilisateurs (il faut quand m\u00eame  demander les droits au superuser).  </p>"},{"location":"Linux/Linux/#le-repertoire-var","title":"le r\u00e9pertoire /var","text":"<p>D\u00e9finition</p> <p>/var Le r\u00e9pertoire /usr/ \u00e9tant en lecture seule, tous les</p> <p>D\u00e9finition</p> <p>/var/lock Fichiers de blocage, pour interdire par exemple deux</p> <p>utilisations simultan\u00e9es d\u2019un p\u00e9riph\u00e9rique.</p> <p>D\u00e9finition</p> <p>/var/run Des fichiers li\u00e9s aux applications en cours de fonctionnement.</p> <p>D\u00e9finition</p> <p>/var/log les journaux et logs du syst\u00e8me et des applications</p> <p>D\u00e9finition</p> <p>/var/cache dossiers et fichiers de cache. Par exemple apt peut y stocker</p> <p>les packages pour installer ou mettre \u00e0 jour le syst\u00e8me et les applications.</p> <p>D\u00e9finition</p> <p>/var/spool Pour stocker les fichiers de donn\u00e9es des programmes.</p> <p>programmes qui ont besoin d\u2019\u00e9crire des fichiers journaux  (log), des fichiers de donn\u00e9es (spool) ou des fichiers de  blocage (lock) devraient les \u00e9crire dans /var. Par exemple, on peut y trouver le PID de l\u2019application.  </p>"},{"location":"Linux/Linux/#le-repertoire-etc","title":"le r\u00e9pertoire /etc","text":"<p>D\u00e9finition</p> <p>/etc/init.d et /etc/default : les fichiers li\u00e9s aux daemons Linux</p> <p>D\u00e9finition</p> <p>/etc/password, /etc/group, /etc/shadow : les fichiers de configuration des</p> <p>D\u00e9finition</p> <p>/etc/hosts : le fichier HOSTS de Linux (liens entre adresses IP et</p> <p>D\u00e9finition</p> <p>/etc/sudoers et /etc/sudoers.d : la configuration de sudo.</p> <p>D\u00e9finition</p> <p>/etc/sysctl.conf et /etc/sysctl.d les fichiers de configuration de d\u00e9marrage</p> <p>D\u00e9finition</p> <p>...</p> <p>stocke les fichiers de configurations du syst\u00e8me ainsi que des applications.  Un sous-r\u00e9pertoire par application utilisateurs Linux. litt\u00e9rales) du noyau Linux.  </p>"},{"location":"Linux/Linux/#des-fichiers-sensibles","title":"Des fichiers sensibles","text":"<p>D\u00e9finition</p> <p>/etc/passwd : fichier des utilisateurs et leurs mots de pass. Suppression de</p> <p>D\u00e9finition</p> <p>/etc/fstab Liste des partitions utilis\u00e9es par le syst\u00e8me et selon quelle</p> <p>D\u00e9finition</p> <p>/boot/vmlinuz Se situe g\u00e9n\u00e9ralement, soit sous la racine (/), soit sous</p> <p>D\u00e9finition</p> <p>...</p> <p>Quelques fichiers particuli\u00e8rement importants, sur lesquels repose une  grande partie de la stabilit\u00e9 du syst\u00e8me, voire de son simple  fonctionnement ce r\u00e9pertoire =\u21d2 impossible d\u2019utiliser le syst\u00e8me. m\u00e9thode il les utilise. /boot. En fait, il s\u2019agit du syst\u00e8me lui-m\u00eame ! Ultra sensible !  </p>"},{"location":"Linux/Linux/#_5","title":"Linux","text":""},{"location":"Linux/Linux/#avertissement","title":"Avertissement","text":"<p>On ne donne ici que quelques indications sur le shell bash :  des principes g\u00e9n\u00e9raux d\u2019\u00e9critures des commandes quelques commandes forc\u00e9ment incompl\u00e8tes pas d\u2019instruction de programmation pour les scripts bash : on a  assez \u00e0 faire avec le langage C et OCAML.  </p>"},{"location":"Linux/Linux/#terminal-et-console","title":"Terminal et console","text":"<p>D\u00e9finition</p> <p>Terminal</p> <p>D\u00e9finition</p> <p>shell : interpr\u00e9teur de commande ; programme lanc\u00e9 juste apr\u00e8s la</p> <p>D\u00e9finition</p> <p>Console : combinaison d\u2019un terminal et d\u2019un shell.</p> <p>Ouverture d\u2019un terminal sous Ubuntu : Ctr+Alt+T.</p> <p>: environnement dans lequel on \u00e9crit et qui donne le retour  des commandes. Il peut \u00eatre fourni par les serveur graphique et disposer  de fen\u00eatres, menus, et autres boutons ;  ou sans fen\u00eatre, comme lorsque on fait Ctrl+Alt+F3  (entrer Ctrl+Alt+F7 ou Ctrl+Alt+F2 pour retourner au  serveur graphique).  Peut tr\u00e8s bien \u00eatre constitu\u00e9 d\u2019une imprimante avec un  clavier comme un t\u00e9l\u00e9scripteur. proc\u00e9dure de login et qui traite les commandes pass\u00e9es. Le  shell le plus r\u00e9pandu sous Linux est le bash (Bourne again  shell).  </p>"},{"location":"Linux/Linux/#un-terminal","title":"Un terminal","text":"<p>Figure \u2013 Un terminal dans lequel on n\u2019a encore rien \u00e9crit</p> <p>Ouverture avec Ctrl + Alt + T  Avant le prompt $ : nom d\u2019utilisateur @ nom de machine puis  r\u00e9pertoire courant  \u02dc d\u00e9signe le r\u00e9pertoire racine de mon compte personnel.  </p>"},{"location":"Linux/Linux/#syntaxe-generale-des-commandes","title":"Syntaxe g\u00e9n\u00e9rale des commandes","text":"<p>D\u00e9finition</p> <p>nom nom de la commande</p> <p>D\u00e9finition</p> <p>options repr\u00e9sente une ou plusieurs options</p> <p>D\u00e9finition</p> <p>argument1 est le 1er argument</p> <p>nom [-options] [argument1...] Explications : les options sont \u00e9crite le plus souvent sous la forme d\u2019un caract\u00e8re  accol\u00e9 \u00e0 un tiret ( ls -l ) .  si param\u00e8tre demand\u00e9, il est s\u00e9par\u00e9 par un espace :  gcc essai.c -o sortie (2 param\u00e8tres : essai.c et sortie )  les crochets indiquent un \u00e9l\u00e9ment facultatif les points de suspension indiquent la possibilit\u00e9 de r\u00e9p\u00e9ter un  argument, par exemple ls /etc /usr/bin  s\u00e9paration par un espace ou une tabulation  </p>"},{"location":"Linux/Linux/#commandes-internes-vs-externes","title":"Commandes internes vs externes","text":"<p>Une commande externe est un fichier pr\u00e9sent dans l\u2019arborescence.  Exemple : Quand un utilisateur ex\u00e9cute la commande ls , le shell  demande au noyau Linux d\u2019ex\u00e9cuter le fichier /bin/ls $file / bin / ls  / bin / ls : ELF 64 - bit LSB shared object , x86 -64 ,  version 1 ( SYSV ) , dynamically linked , [...] Une commande interne est int\u00e9gr\u00e9e au processus shell. Elle n\u2019a  aucune correspondance avec un fichier sur le disque. L\u2019acc\u00e8s \u00e0 une  commande interne est plus rapide que pour une externe.  La commande type indique si une commande est interne ou externe. $ type ls  ls est un alias vers &lt;&lt; ls -- color = auto &gt;&gt;  $ type cd  cd est une primitive du shell certaines commande ont une version externe et une interne.  </p>"},{"location":"Linux/Linux/#la-commande-man","title":"la commande man","text":"<p>Pour conna\u00eetre le mode d\u2019emploi d\u2019une commande, taper man nomDeLaCommande (ex : man ls pour conna\u00eetre le manuel de ls ). Entrer q pour quitter. \u2665 Consulter la documentation Ubuntu Le manuel est d\u00e9compos\u00e9 en plusieurs sections</p> <p>Programmes ex\u00e9cutables ou commandes de l\u2019interpr\u00e9teur de commandes (shell) ;  Appels syst\u00e8me (Fonctions fournies par le noyau) ;   Appels de biblioth\u00e8que (fonctions fournies par des biblioth\u00e8ques) ;   Fichiers sp\u00e9ciaux (situ\u00e9s g\u00e9n\u00e9ralement dans /dev) ;   Formats des fichiers et conventions (Par exemple /etc/passwd) ;...  </p> <p>Parfois deux pages de manuel ont le m\u00eame nom comme printf (en section 1 et 3). Entrer man 1 printf ou man 3 printf pour  sp\u00e9cifier. Entrer q pour quitter le manuel.  </p>"},{"location":"Linux/Linux/#chemins-absolus-et-relatifs","title":"Chemins absolus et relatifs \u2665","text":"<p>Un \u00e9l\u00e9ment de l\u2019arborescence est rep\u00e9r\u00e9 par son nom (par exemple  nom.jpg ) pr\u00e9c\u00e9d\u00e9 de : son chemin absolu depuis la racine (ex :  /home/sue/Pictures/family/nom.jpg )  son chemin relatif depuis le r\u00e9pertoire courant. Par exemple, si je suis  dans pets : ../../family/nom.jpg / : s\u00e9pare les noms de fichiers \u02dc : r\u00e9pertoire racine du Home  </p>"},{"location":"Linux/Linux/#commentaire","title":"Commentaire","text":"<pre><code># kalin\n</code></pre> <p>Les commentaires ne sont pas interpr\u00e9t\u00e9s : La commande kalin n\u2019existe pas, elle soul\u00e8ve une erreur : $ kalin  La commande &lt;&lt; kalin &gt; &gt; n \u2019 a pas \u00e9 t \u00e9 trouv \u00e9e , ... Le caract\u00e8re # n\u2019est pas interpr\u00e9t\u00e9. On peut \u00e9crire kalin sans  erreur : $ $  </p>"},{"location":"Linux/Linux/#contenu-dun-repertoire","title":"Contenu d\u2019un r\u00e9pertoire \u2665","text":"<p>La commande ls donne le contenu d\u2019un r\u00e9pertoire : sans argument : les entr\u00e9es du r\u00e9pertoire courant ls  avec argument : les entr\u00e9es rep\u00e9r\u00e9es par le (ou les) argument(s) :  ls myFile, ls myRep, ls /etc /usr/bin pour a\ufb03cher les fichiers cach\u00e9s ls -a (indique notamment  .bashrc si je suis en \u02dc )  pour pour tous les attributs (type, droits, liens physiques, propri\u00e9taire,  groupe, taille, date, nom) ls -l  ls -al au lieu de ls -a -l .  $   \u2212            \u2212\u2212\u2212\u2212\u2212       \u2212\u2212\u2212\u2212\u2212       </p> <p>Dans l\u2019ordre : droits, nombres d\u2019alias, username, groupname, taille  (par d\u00e9faut en octet), date de derni\u00e8re modif., nom de fichier.  ls -i a\ufb03che le num\u00e9ro d\u2019inode.  </p>"},{"location":"Linux/Linux/#affichage-dune-chaine-de-caractere","title":"A\ufb03chage d\u2019une cha\u00eene de caract\u00e8re","text":"<pre><code># afficher coucou\n</code></pre> <p>La commande echo a\ufb03che une ligne de texte (Le caract\u00e8re # indique le d\u00e9but d\u2019un commentaire $ echo \u2019 coucou \u2019 coucou le choix des guillements est important : \"\u2019\" (touche 4),  \"\u201d\" (touche 3) et \"\u2018\" (ALT GR + 7) n\u2019ont pas le m\u00eame sens. Pour a\ufb03cher le contenu d\u2019une variable d\u2019environnement : $ echo $LANG  fr_FR . UTF -8  </p>"},{"location":"Linux/Linux/#les-metacaracteres","title":"Les m\u00e9tacaract\u00e8res","text":"<p>Les m\u00e9tacaract\u00e8res du shell permettent : de construire des cha\u00eenes de caract\u00e8res g\u00e9n\u00e9riques de modifier l\u2019interpr\u00e9tation d\u2019une commande  </p>"},{"location":"Linux/Linux/#metacaracteres-de-construction","title":"M\u00e9tacaract\u00e8res de construction","text":"<p>Prioritaires : *, ?  </p> <p>*** d\u00e9signe une cha\u00eene de caract\u00e8res quelconque \u2665 ? d\u00e9signe un caract\u00e8re quelconque \u2665**</p> <p>[...] d\u00e9signe les caract\u00e8res entre crochets, d\u00e9finis par \u00e9num\u00e9ration  ou par un intervalle : [Aa] d\u00e9signe les caract\u00e8res A ou a, [0-9a-zA-Z] d\u00e9signe un caract\u00e8re alphanum\u00e9rique quelconque. [!0-9] d\u00e9signe l\u2019ensemble des caract\u00e8res sauf les chi\ufb00res.  </p> <p>Voici le contenu du r\u00e9pertoire courant : $ ls  alain Ali tata titi toto tutu zut ls t[ao]t[ao] retourne tata et toto , ls ??? retourne les noms de 3 lettres donc zut et Ali  ls A retourne les noms qui commencent par A donc Ali  ls t??o retourne les noms de 4 lettres qui terminent par o et  commencent par t donc toto ls [!b-z] d\u00e9signe les noms qui ne commencent pas par une lettre  entre b et z donc alain et Ali .  </p>"},{"location":"Linux/Linux/#metacaracteres-de-modification-pi","title":"M\u00e9tacaract\u00e8res de modification (PI)","text":"<p>; s\u00e9pare deux commandes sur une m\u00eame ligne  Les guillemets verticaux simples \u2019 (touche 4) d\u00e9limitent une cha\u00eene  de caract\u00e8res contenant des espaces (\u00e0 l\u2019int\u00e9rieur, tous les  m\u00e9tacaract\u00e8res perdent leur signification) ;  Les guillemets verticaux doubles \u201d (touche 3) d\u00e9limitent une cha\u00eene  de caract\u00e8res contenant des espaces (\u00e0 l\u2019int\u00e9rieur, tous les  m\u00e9tacaract\u00e8res perdent leur signification, \u00e0 l\u2019exception des  m\u00e9tacaract\u00e8res \u2018 et $) ;  Les guillemets obliques gauche-droite \u2018 (ALT GR + 7)  \"capturent\" la sortie standard pour former un nouvel argument ou  une nouvelle commande ;  \\ annule la signification du m\u00e9tacaract\u00e8re qui suit : c\u2019est un  caract\u00e8re dit d\u2019\u00e9chappement.  le &amp; \u00e0 la fin d\u2019une commande permet de lancer celle-ci en t\u00e2che de  fond, donc sans bloquer le terminal.  </p> <pre><code># est - ce un dossier ?\n# afficher la r \u00e9 ponse du test pr \u00e9 c \u00e9 dent\n</code></pre> <p>M\u00e9tacaract\u00e8res de modification (PI)  Parenth\u00e8ses (...) : les parenth\u00e8ses encadrent une suite de commandes qui sont  ex\u00e9cut\u00e9es par un shell secondaire. En particulier, les assignements  n\u2019ont pas d\u2019e\ufb00et en dehors des parenth\u00e8ses. {...} : les accolades encadrent une suite de commandes qui sont  ex\u00e9cut\u00e9es par le shell principal. En particulier, les assignements ont un  e\ufb00et en dehors des accolades.  [...] : les crochets sont utilis\u00e9s pour les instructions  conditionnelles. Ils encadrent une expression \u00e0 valeur boul\u00e9enne.  $ [ -d presentationLinux . tex ] $ echo $ ? 1 On obtient 0 si le fichier existe et est un r\u00e9pertoire, 1 sinon. ...  </p> <p>Utiliser le r\u00e9sultat d\u2019une commande comme argument  d\u2019une autre (PI) Pour info. Les \u2018 (ALT GR + 7) entourant une commande permettent  d\u2019utiliser le r\u00e9sultat de cette commande comme argument(s) dans la ligne  de commande. $ echo \" Nous (cid:32) sommes (cid:32) le \" \u2018 date +% d /% m /% y \u2018  Nous sommes le 27/08/21 A\ufb03che la date du jour avec un format choisi. $ echo \" 2 (cid:32) + (cid:32) 2 (cid:32) = \" \u2018 expr 2 + 2 \u2018  2 + 2 = 4  </p>"},{"location":"Linux/Linux/#positionnementrecherche-dans-larborescence","title":"Positionnement/recherche dans l\u2019arborescence \u2665","text":"<p>D\u00e9finition</p> <p>pwd a\ufb03che le nom absolu du r\u00e9pertoire de travail</p> <p>D\u00e9finition</p> <p>cd change le r\u00e9pertoire de travail.</p> <p>D\u00e9finition</p> <p>ls liste les entr\u00e9es d\u2019un r\u00e9pertoire (d\u00e9j\u00e0 vu) ls .</p> <p>D\u00e9finition</p> <p>find pour chercher r\u00e9cursivement un ou plusieurs fichiers dans une</p> <p>arborescence. Beaucoup d\u2019options (consulter le manuel).</p> <p>Avec argument : se rend \u00e0 la destination indiqu\u00e9e.  cd ../Rep1 ;  sans argument : retourne au r\u00e9pertoire de connexion du  user. cd  </p>"},{"location":"Linux/Linux/#rechercher","title":"Rechercher","text":"<p>find cherche r\u00e9cursivement dans l\u2019arborescence \u00e0 partir du point indiqu\u00e9. find /usr -name \"ls*\" cherche les fichiers dont le nom commence par ls dans le r\u00e9pertoire /usr et ses sous-r\u00e9pertoires. Il y en a beaucoup ! \u2665 L\u2019option -type permet de ne chercher que les fichiers ( f ) ou les</p> <p>find /var/log/ -type d -name \"sm\" : r\u00e9pertoires ( d ).  chercher les r\u00e9pertoires dont le nom contient sm  recherche par taille :  find  fichiers dont la taille est comprise entre 20 Mo et 40Mo.  Recherche par utilisateur : find /tmp -user adrien cherche dans /T\u00e9l\u00e9chargements -size +20M -size -40M cherche les /tmp les fichiers dont le propri\u00e9taire est adrien .  Beaucoup d\u2019autres options : par date de cr\u00e9ation, date de derni\u00e8re  modification, par type de permissions, recherche de fichiers vides etc...  </p>"},{"location":"Linux/Linux/#consulter-le-contenu-dun-fichier-texte","title":"Consulter le contenu d\u2019un fichier texte \u2665","text":"<p>Commandes de base : cat monfichier , more monfichier : a\ufb03chage simple et page  par page ; head monfichier , head -n monfichier : a\ufb03chage des n  premi\u00e8res lignes ; tail monfichier , tail -n monfichier : a\ufb03chage des n  derni\u00e8res lignes ; wc monfichier : a\ufb03chage du nombre de lignes, de mots, de  caract\u00e8res. Options -l , -w et -c pour les nombres de lignes, de  mots et de caract\u00e8res. cat toto titi : a\ufb03che le contenu de titi \u00e0 la suite de celui de  toto ( cat pour concat\u00e8ne).  </p>"},{"location":"Linux/Linux/#historique","title":"Historique \u2665","text":"<p>D\u00e9finition</p> <p>! ! rappelle la derni\u00e8re commande</p> <p>!n rappelle la commande num\u00e9ro n</p> <p>D\u00e9finition</p> <p>!chaine rappelle la derni\u00e8re commande commen\u00e7ant par chaine</p> <p>Le shell bash enregistre toutes les commandes tap\u00e9es et permet de  les rappeler pour les r\u00e9-ex\u00e9cuter soit telles quelles, soit modifi\u00e9es. La commande history permet de lister le contenu de l\u2019historique des commandes, de fa\u00e7on num\u00e9rot\u00e9e. Le caract\u00e8re ! permet de  rappeler une commande. On peut aussi utiliser les \ufb02\u00e8ches haut et bas pour naviguer dans  l\u2019historique des commandes.  </p>"},{"location":"Linux/Linux/#taille-du-contenu-dun-repertoire","title":"Taille du contenu d\u2019un r\u00e9pertoire","text":"<p>du -h -d 1 monRepertoire : taille des fichiers et sous-r\u00e9pertoires.  (du pour Disk User)) L\u2019option -h force un a\ufb03chage \"human readable\" (par exemple, 1k,  236M, 2G).  L\u2019option -d a\ufb03che la taille totale du r\u00e9pertoire explor\u00e9 et pas  seulement la taille de ses constituants. Et le param\u00e8tre 1 indique la  profondeur de l\u2019exploration (ici, on s\u2019arr\u00eate aux fils, avec 2 comme  param\u00e8tre , ce serait aux petits-fils) La commande ncdu nomDuRepertoire , plus conviviale, permet de  conna\u00eetre la place prise par les fichiers et dossiers en navigant dans  l\u2019arborescence. Par exemple ncdu /home indique les tailles des  di\ufb00\u00e9rents r\u00e9pertoires utilisateurs.  </p>"},{"location":"Linux/Linux/#creer-et-supprimer","title":"Cr\u00e9er et supprimer","text":"<p>Cr\u00e9er un r\u00e9pertoire vide : mkdir Rep1 Supprimer un r\u00e9petoire vide : rmdir Rep1 Cr\u00e9er un fichier vide : touch file1  Supprimer un fichier rm file1 , supprimer tous les fichiers du  r\u00e9pertoire rm * Cr\u00e9er un chemin complet mkdir -p R1/R2 cr\u00e9e dans la foul\u00e9e R1 puis son sous-r\u00e9pertoire R2 .  </p>"},{"location":"Linux/Linux/#copier-cp-et-deplacer-mv","title":"Copier ( cp ) et d\u00e9placer ( mv ) \u2665","text":"<p>Situation : un r\u00e9pertoire parent P poss\u00e8de deux sous-r\u00e9pertoires Rep1 et  Rep2. Dans Rep1 on trouve le fichier file1. Copier le fichier file1 du r\u00e9pertoire Rep1 dans le r\u00e9pertoire Rep2  sans changer le nom : cp Rep1/file1 Rep2/  Copier le fichier file1 du r\u00e9pertoire Rep1 dans le r\u00e9pertoire Rep2 en  changeant le nom : cp Rep1/file1 Rep2/file2  Je suis dans Rep1. Changer le nom du fichier file1 en restant dans  le m\u00eame r\u00e9pertoire : mv file1 file2 .  Je suis dans Rep1. d\u00e9placer le fichier file1 sans changer son nom  mv file1 ../Rep2/ .  Je suis dans le r\u00e9pertoire parent de P. Je veux copier r\u00e9cursivement P  et tout ce qu\u2019il contient (donc aussi les sous-r\u00e9pertoires) dans un  nouveau r\u00e9pertoire P2 : cp -r P1 P2  </p> <pre><code># Creer r \u00e9 pertoire Asup\n# aller au r \u00e9 pertoire Asup\n# pas de contenu\n# cr \u00e9 er le fichier vide asup\n# afficher fichiers cach \u00e9 s\n# supprimer asup\n# plus de contenu\n</code></pre> <p>Cr\u00e9er, remplir, vider, supprimer un r\u00e9pertoire  Exemple $ mkdir Asup  $ cd Asup $ ls  $ touch asup $ ls - al total 8  drwxrwxr - x 2 ivan ivan 4096 ao ^u t  drwxrwxr - x 3 ivan ivan 4096 ao ^u t  0 ao ^u t  -rw - rw -r - - 1 ivan ivan 19 15:28 .  19 15:28 ..  19 15:28 asup $ rm asup $ ls </p> <pre><code># revenir au p \u00e8 re\n# supprime rep Asup\n# creer un r \u00e9 pertoire et son fils\n# supprimer un r \u00e9 pertoire et son fils\n</code></pre> <p>Cr\u00e9er, remplir, vider, supprimer un r\u00e9pertoire  Exemple $ cd .. $ rmdir Asup  Les r\u00e9pertoires Nouveau et son fils AutreNouveau sont cr\u00e9\u00e9s  simultann\u00e9ment puis supprim\u00e9s de m\u00eame $ mkdir -p Nouveau / AutreNouveau $ rmdir -p Nouveau / AutreNouveau </p>"},{"location":"Linux/Linux/#explorer-un-fichier","title":"Explorer un fichier","text":"<p>grep a\ufb03che les lignes v\u00e9rifiant un pattern.  Contenu d\u2019un fichier myfile t o t o  t o t  t o t o o  a t o t o  t i t i grep \"toto\" myfile cherche le mot \"toto\" dans myfile grep -c \"toto\" myfile cherche le nombre d\u2019occurences du mot  \"toto\" dans myfile.  Option grep -n \"toto\" pour a\ufb03cher les num\u00e9ros de lignes.  Le joker * n\u2019a pas ici la m\u00eame signification que le m\u00e9tacaract\u00e8re du  shell ! grep \"toto*\" myfile cherche les lignes contenant au moins  un tot suivi par 0, 1 ou plusieurs lettres \"o\" (renvoie toto, tot,  totoo et atoto)       </p>"},{"location":"Linux/Linux/#explorer-un-fichier-suite","title":"Explorer un fichier (suite)","text":"<p>grep a\ufb03che les lignes v\u00e9rifiant un pattern.  Contenu d\u2019un fichier myfile t o t o  t o t  t o t o o  a t o t o  t i t i grep \"toto$\" myfile : les lignes qui terminent par toto grep \"^toto\" : les lignes qui commencent par toto grep -v \"toto\" myfile :les lignes ne contenant pas toto  </p>"},{"location":"Linux/Linux/#montage-et-demontage","title":"Montage et d\u00e9montage","text":"<p>L\u2019arborescence de fichier de Linux inclut tous les p\u00e9riph\u00e9riques  externes. Le syst\u00e8me d\u2019exploitation d\u2019un ordinateur basique est install\u00e9 sur le  disque dur. L\u2019utilisateur peut d\u00e9cider d\u2019ins\u00e9rer un p\u00e9riph\u00e9rique externe  (ex : une cl\u00e9 USB). Les p\u00e9riph\u00e9riques de stockage sont associ\u00e9s \u00e0 un r\u00e9pertoire particulier.  Par exemple le disque dur principal sur lequel l\u2019OS est install\u00e9 est  associ\u00e9 au r\u00e9pertoire /  L\u2019utilisateur peut choisir de monter temporairement un syst\u00e8me de  fichier par ses propres moyens gr\u00e2ce \u00e0 la commande mount . En  g\u00e9n\u00e9ral le montage se fait dans le r\u00e9pertoire /mnt.  Les op\u00e9rations de montage manuel n\u00e9cessitent g\u00e9n\u00e9ralement les droits  du superuser.  </p> <p></p> <p>Figure \u2013 Un bouton pour \"\u00e9jecter\" la cl\u00e9</p> <p>Les m\u00e9dias amovibles (comme une cl\u00e9 USB) sont, sous Ubuntu,  mont\u00e9s automatiquement (i.e. appel automatique de mount ) dans  le r\u00e9pertoire /media.  Par exemple si l\u2019utilisateur toto ins\u00e8re une cl\u00e9 USB, son arborescence  de fichier est visible dans un r\u00e9pertoire comme /media/toto/CLE.  Tous les fichiers de la cl\u00e9s sont disponibles dans ce r\u00e9pertoire.  Et les cr\u00e9ations/modifications/suppressions de fichier dans ce  r\u00e9pertoire sont r\u00e9percut\u00e9es sur la cl\u00e9.  Pour d\u00e9monter un m\u00e9dia amovible, il y a en g\u00e9n\u00e9ral une interface  graphique.  </p> <p>Pour d\u00e9monter manuellement un syst\u00e8me de fichier, on utilise la  commande umount .  Cette commande requiert en g\u00e9n\u00e9ral les droits du superuser.  </p> <pre><code>|\n</code></pre> <p>Tube  L\u2019op\u00e9rateur  On peut rediriger la sortie d\u2019une commande vers l\u2019entr\u00e9e d\u2019une autre. L\u2019op\u00e9rateur \"|\" r\u00e9alise cette op\u00e9ration.  R\u00e9cup\u00e9rer la liste des sous-r\u00e9pertoires : on utilise ls -al qui donne toutes les indications sur les fichiers du  r\u00e9pertoire courant.  Les lignes qui commencent par un d correspondent \u00e0 un r\u00e9pertoire.  Pour les r\u00e9cup\u00e9rer, on envoie la sortie de ls sur l\u2019entr\u00e9e de grep ,  auquel on demande de filtrer les lignes qui commencent par d :  ivan @ fixe :~/.../ TD$ ls - al | grep \" ^ d \"  drwxrwxr - x 28 ivan ivan  drwxr - xr - x 17 ivan ivan  3 ivan ivan  drwxrwxr - x  3 ivan ivan  drwxrwxr - x  drwxrwxr - x  2 ivan ivan  .... 4096 oct .  4096 d \u00e9 c .  4096 sept . 21 10:45 ABR_tas  4096 sept . 21 10:45 Arbres  4096 sept . 21 10:45 BDD 5 10:48 .  30 18:06 ..  </p>"},{"location":"Logique/logique/","title":"Logique","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"Logique/logique/#credits","title":"Cr\u00e9dits","text":"<p>Wikipedia, Mansuy, Becirspahic.  </p>"},{"location":"Logique/logique/#introduction","title":"Introduction","text":""},{"location":"Logique/logique/#proposition","title":"Proposition","text":"<p>Notion affin\u00e9e au cours des si\u00e8cles.  </p> <p>Une proposition est une construction syntaxique pens\u00e9e parler de  v\u00e9rit\u00e9. La d\u00e9finition pr\u00e9cise de ce concept est l\u2019un des objectifs du  calcul des propositions.  </p> <p>\"Pourvu que je n\u2019attrape pas le Coronavirus !\" exprime un souhait  et pas un fait. Il n\u2019est pas mod\u00e9lis\u00e9 par une proposition.  </p> <p>Il n\u2019y a pas de quantification en calcul des propositions. Ainsi \"M.  Noyer marche sur les eaux\" est exprimable comme une proposition  mais pas \"tous les marseillais marchent sur les eaux\" ni \"il existe  un marseillais qui marche sur les eaux\" (d\u2019ailleurs c\u2019est M. Noyer !)  </p> <p>Le calcul des propositions est la premi\u00e8re \u00e9tape dans la d\u00e9finition de  la logique et du raisonnement. Etape suivante : calcul des pr\u00e9dicats.  </p>"},{"location":"Logique/logique/#contenu-des-propositions","title":"Contenu des propositions","text":"<p>Une proposition donne une information \u00e9valuable sur quelque chose.  </p> <p>Exemple</p> <p>2 + 2 = 4 ou \"la maison de Pierre est rose\" ou \"si a \u2264 b  et f(a)f(b) &lt; 0 alors il existe \\(c\\in \\left [ a,b \\right ]\\) tel que f(c) = 0\".  </p> <p>L\u2019id\u00e9e est qu\u2019on puisse attribuer une valeur de v\u00e9rit\u00e9 \u00e0 toute  proposition. Par exemple 2 + 2 = 4 a pour valeur Vrai, la seconde phrase est  v\u00e9rifiable en se rendant chez Pierre, la derni\u00e8re d\u00e9pend du type et de  la continuit\u00e9 de f .  </p> <p>Contre-exemple</p> <p>\"\u00c0 quelle heure finit le cours ?\" ou \"Travaille  davantage !\". Ces phrases n\u2019apportent pas d\u2019information.  Il est di\ufb03cile de leur attribuer une valeur.</p> <p>Les valeurs attribu\u00e9es aux propositions sont en g\u00e9n\u00e9ral 0 ou 1, True  ou False, Vrai ou Faux.  </p>"},{"location":"Logique/logique/#logique-classique","title":"Logique classique","text":"<p>C\u2019est celle du cours de maths en CPGE.  </p> <p>Quand le cardinal de l\u2019ensemble des valeurs possibles que peuvent  prendre les propositions est 2, on parle de logique classique ou  boul\u00e9enne.  </p> <p>Il existe d\u2019autres logiques. Elles sont parfois tri-valu\u00e9es. Par exemple  Vrai, Faux, Je ne sais pas.</p> <p>Pourquoi faudrait-il d\u2019autres logiques ? \\(\\color{red} \\text {En logique classique \"je suis ici ou ailleurs\" (= tiers exclu) est toujours vrai.}\\) Cependant \"si \\(x\\in \\mathbb{Q}\\) alors machin  sinon truc\" n\u2019est exploitable que si on poss\u00e8de un test  d\u2019appartenance \u00e0 \\(\\mathbb{Q}\\) en temps fini, ce qui n\u2019est pas le cas. Les  logiciens intuitionnistes refusent le tiers exclu.  </p>"},{"location":"Logique/logique/#tiers-exclu","title":"Tiers exclu","text":"<p>Le principe du tiers exclu a \u00e9t\u00e9 introduit par Aristote comme  cons\u00e9quence du principe de non-contradiction. Le principe de  non-contradiction stipule que pour toute proposition P on ne peut  pas avoir P et \\(\\neg P\\) (non P) en m\u00eame temps.  </p> <p>La proposition \\(\\neg (P \\wedge  \\neg P)\\) (toujours vraie dans toute les logiques)  \u00e9quivaut s\u00e9mantiquement (par utilisation de r\u00e8gle de De Morgan) \u00e0  \\(\\neg P \\vee  \\neg \\neg P\\). On retrouve le tiers exclu SI ON ACCEPTE que \\(\\neg \\neg P\\) et P sont  s\u00e9mantiquement \u00e9quivalents.  </p>"},{"location":"Logique/logique/#dautres-mathematiques","title":"D\u2019autres math\u00e9matiques","text":"<p>La logique intuitionniste qui engendre les math\u00e9matiques  constructives, admet le principe de non-contradiction mais r\u00e9fute celui  du tiers exclu.  </p> <p>Pour un constructiviste, le raisonnement \"si \\(a \\in A\\) alors bla sinon  bli\" n\u2019a de sens que s\u2019il existe un test pour d\u00e9terminer l\u2019appartenance  \u00e0 \\(A\\).  Les constructivistes r\u00e9futent aussi l\u2019axiome du choix qui dit en  substance que \"dans un ensemble infini, je peux choisir un  \u00e9l\u00e9ment\", au motif que \"je ne peux pas choisir si je ne sais pas  comment choisir\".</p> <p>La plupart des th\u00e9or\u00e8mes de CPGE sont adaptables en  math\u00e9matiques constructives (parfois, les \u00e9nonc\u00e9s sont les m\u00eames,  d\u2019autre fois, il faut adapter). En revanche l\u2019affirmation \"tout K-espace vectoriel admet une base \" n\u2019est pas constructive (oui pour la dimension finie mais pas en dimension quelconque)  </p> <p>Une preuve de math\u00e9matiques constructives est bien adapt\u00e9e \u00e0  l\u2019informatique en ce sens qu\u2019elle est pratiquement donn\u00e9e sous forme  d\u2019algorithme.  </p>"},{"location":"Logique/logique/#structure-dapres-wikipedia","title":"Structure (d\u2019apr\u00e8s Wikipedia)","text":"<p>Dans les th\u00e9ories de la logique math\u00e9matique, on consid\u00e8re deux  points de vue dits syntaxique et s\u00e9mantique, c\u2019est le cas en calcul des  propositions.  </p> <ul> <li>Aspect syntaxique : la forme. Il s\u2019agit de d\u00e9finir le langage du calcul des  propositions par les r\u00e8gles d\u2019\u00e9criture des propositions. On d\u00e9crit donc  ce qu\u2019EST une proposition.  </li> <li>Aspect s\u00e9mantique : le fond. Il s\u2019agit de donner un sens aux symboles  repr\u00e9sentant les connecteurs logiques en fonction de la valeur de v\u00e9rit\u00e9  des propositions de base. On d\u00e9crit donc ce que SIGNIFIE une  proposition. En CPGE, ce sens est donn\u00e9 par des tables de v\u00e9rit\u00e9. .  L\u2019aspect s\u00e9mantique est d\u00e9crit de deux fa\u00e7ons  <ul> <li>Soit en munissant d\u2019 une interpr\u00e9tation (un sens) les connecteurs logique. On peut alors d\u00e9finir inductivement une interpr\u00e9tation pour toute proposition complexe.</li> <li>Soit par d\u00e9duction : On se donne des r\u00e8gles purement syntaxiques qui permettent de d \u0301eduire une proposition d\u2019un ensemble d\u2019autres : les r\u00e8gles d\u2019inf\u00e9rence (Par exemple : calcul des s\u00e9quents ou d\u00e9duction naturelle). On ne se pr\u00e9occupe donc pas du sens, juste de la d\u00e9ductibilit\u00e9.</li> </ul> </li> </ul>"},{"location":"Logique/logique/#semantique-vs-deduction","title":"S\u00e9mantique VS d\u00e9duction","text":"<p>D\u00e9finition: Une interpr\u00e9tation</p> <p>La fonction \"qui donne du sens\" est appel\u00e9 une interpr\u00e9tation.</p> <p>On construit un arbre d\u2019inf\u00e9rence et on dit qu\u2019une formule est  prouvable si toutes les feuilles de l\u2019arbre sont des axiomes.  On appelle th\u00e9or\u00e8me une proposition prouvable.  </p> <p>En calcul des propositions, tout ce qui est vrai est prouvable et  r\u00e9ciproquement.  </p> <p>Si on reste en logique du 1er ordre (en ajoutant quantificateurs,  termes et pr\u00e9dicats au cours de 1ere ann\u00e9e) alors ce qui est vrai est  prouvable et r\u00e9ciproquement.  </p>"},{"location":"Logique/logique/#pour-avoir-mal-a-la-tete","title":"Pour avoir mal \u00e0 la t\u00eate","text":"<p>La logique du 1er ordre (telle qu\u2019enseign\u00e9e en MP2I/MPI) est  coh\u00e9rente : on ne peut pas d\u00e9montrer \u00e0 la fois une formule et son  contraire ; ce qui revient \u00e0 dire qu\u2019on ne peut pas d\u00e9montrer le faux.</p> <p>Le calcul des pr\u00e9dicats est complet : ce qui est vrai est prouvable et  r\u00e9ciproquement.  </p> <p>Aucun syst\u00e8me logique coh\u00e9rent (comme la d\u00e9duction naturelle ou le  calcul des s\u00e9quents) ne peut d\u00e9montrer tous les r\u00e9sultats de  l\u2019arithm\u00e9tique. Quel que soit le syst\u00e8me, s\u2019il est assez riche pour  exprimer l\u2019arithm\u00e9tique, on peut trouver un \u00e9nonc\u00e9 valide qui ne sera  pas d\u00e9montrable dans ce syst\u00e8me.  </p> <p>Aucun syst\u00e8me logique coh\u00e9rent assez riche pour exprimer  l\u2019arithm\u00e9tique ne peut d\u00e9montrer sa propre coh\u00e9rence. Par exemple,  les math\u00e9matiques ens\u00e9eign\u00e9es en CPGE ne peuvent pas \u00e9tablir la  preuve qu\u2019elles sont sans contradiction.  </p>"},{"location":"Logique/logique/#syntaxe","title":"Syntaxe","text":""},{"location":"Logique/logique/#lalphabet","title":"L\u2019alphabet","text":"<p>D\u00e9finition</p> <p>On consid\u00e8re un alphabet \\(\\Sigma\\) constitu\u00e9 :</p> <ul> <li>de symboles Vrai et Faux not\u00e9s V et F,  </li> <li>de variables propositionnelles en nombre d\u00e9nombrable not\u00e9es dans ce cours en lettres romaines a, b, \\(\\dotsb\\) , \\(a_1\\), \\(\\dotsb\\) , \\(z_{32}\\), \\(\\dotsb\\)</li> <li>de deux symboles de parenth\u00e8ses \"(,)\" (ouvrante et fermante).  </li> <li>d\u2019un connecteur unaire \\(\\neg\\)  dit de n\u00e9gation  </li> <li>de trois connecteurs binaires not\u00e9s \\(\\vee , \\wedge , \\rightarrow\\) et appel\u00e9s connecteurs  logiques de disjonction, conjonction et d\u2019implication.  </li> </ul> <p>Remarque</p> <ul> <li>On dit aussi op\u00e9rateur pour \"connecteur\"  </li> <li>Dans certains cours, on ajoute aussi l\u2019op\u00e9rateur \\(\\Leftrightarrow\\) et le XOR. Dans certains autres, seulement \\(\\neg , \\vee , \\wedge\\) , voire m\u00eame \\(\\neg , \\wedge\\) .</li> <li>Le NAND (A NAND B vaut \\(\\neg (A \\wedge  B)\\)) est universel.  </li> </ul>"},{"location":"Logique/logique/#ensemble-des-propositions","title":"Ensemble des propositions","text":"<p>D\u00e9finition</p> <p>On appelle langage des propositions le langage d\u00e9fini inductivement par : - les constantes et les variables propositionnelles sont dans le langage, - si A est dans le langage, alors (A) aussi, - si A est dans le langage \\((\\neg A)\\) aussi,  - si A, B sont dans le langage alors \\((A \\vee  B)\\), \\((A \\wedge  B)\\) et \\((A \\rightarrow B)\\) aussi.  </p>"},{"location":"Logique/logique/#representation-arborescente","title":"Repr\u00e9sentation arborescente","text":"<p>\\((((\\neg a) \\vee  b) \\wedge  (\\neg c))\\) se repr\u00e9sente sous la forme d\u2019un arbre binaire (dit  arbre syntaxique) :</p> <p></p> <p>Remarque</p> <p>Puisque les propositions sont construites comme des arbres binaires, il est naturel de parler de leur taille et de leur hauteur.</p>"},{"location":"Logique/logique/#simplification-de-lecriture","title":"Simplification de l\u2019\u00e9criture","text":"<p>On ne note pas les parenth\u00e8ses autour de la racine.  </p> <p>On convient (souvent, mais je ne trouve pas \u00e7a si commode) que  l\u2019op\u00e9rateur de n\u00e9gation \\(\\neg\\)  a priorit\u00e9 sur les autres, que la conjonction  et la disjonction ont priorit\u00e9 sur l\u2019implication, et enfin que la  conjonction a priorit\u00e9 sur la disjonction.  C\u2019est tr\u00e8s classique !  </p> <p>Remarque</p> <p>C'est \u00e0 dire : \\(\\neg \\gg \\wedge \\gg \\vee \\gg \\text{ } \\rightarrow\\)</p> <p>Pour passer des \u00e9critures sans parenth\u00e8ses aux \u00e9critures avec  parenth\u00e8ses, une r\u00e8gle simple : plus l\u2019op\u00e9rateur est prioritaire, plus il a  de parenth\u00e8ses autour de lui.  </p>"},{"location":"Logique/logique/#priorites-en-python","title":"Priorit\u00e9s en Python","text":"<p>Figure \u2013 R\u00e8gles de priorit\u00e9 de la plus haute (en haut) \u00e0 la plus basse (en bas). Les op\u00e9rateurs de m\u00eame niveau sont \u00e9valu\u00e9s de gauche \u00e0 droite</p> <p>Exercice</p> <p>Remettre des parenth\u00e8ses  </p> <ul> <li>\\(\\neg a \\vee  b \\wedge  c\\) </li> <li>\\(((\\neg a) \\vee  (b \\wedge  c))\\) </li> <li>\\(\\neg a \\wedge  b \\vee  c\\) </li> <li>\\((((\\neg a) \\wedge  b) \\vee  c)\\) </li> <li>\\(a \\vee  \\neg b \\wedge  c \\rightarrow  a \\wedge  c\\) </li> <li>\\([(a \\vee  ((\\neg b) \\wedge  c)) \\rightarrow  (a \\wedge  c)]\\) </li> </ul>"},{"location":"Logique/logique/#semantique","title":"S\u00e9mantique","text":""},{"location":"Logique/logique/#contexte","title":"Contexte","text":"<p>D\u00e9finition: Un contexte</p> <p>Un contexte (ou une distribution de v\u00e9rit\u00e9) sur un ensemble de variables propositionnelles V est une application de V dans l\u2019ensemble des boul\u00e9ens B.</p> <p>Remarque</p> <ul> <li>Si |V| = n, alors il y a 2n distributions de v\u00e9rit\u00e9.</li> <li>L\u2019ensemble des boul\u00e9ens peut \u00eatre repr\u00e9sent\u00e9 de diff\u00e9rentes fa\u00e7ons.</li> <li>Dans ce cours, on pose B = {0, 1}, et on identifie B avec l\u2019anneau \\(\\mathbb{Z}/2\\mathbb{Z}\\) (donc 1 + 1 = 0 en particulier.)</li> <li>La multiplication est l\u2019interpr\u00e9tation de la conjonction, 0 celle de F, 1  celle de V, l\u2019addition celle du XOR.  </li> </ul>"},{"location":"Logique/logique/#interpretation","title":"Interpr\u00e9tation","text":"<p>D\u00e9finition: Une \u00e9valuation / interpr\u00e9tation</p> <p>Soit \u00b5 un contexte sur un ensemble de variables V \u00e0 valeur dans B = Z/2Z. On appelle \u00e9valuation (ou encore interpr\u00e9tation) associ\u00e9e \u00e0 \\(\\mu\\) l\u2019application not\u00e9e \\(\\varepsilon_\\mu\\) d\u00e9finie sur  l\u2019ensemble des propositions par :</p> <ul> <li>\\(\\varepsilon_\\mu(V ) = 1, \\varepsilon_\\mu(F ) = 0\\)</li> <li>pour toute variable \\(v \\in V, \\varepsilon_\\mu(v ) = \\mu(v )\\)</li> <li>pour toute expression \\(p, \\varepsilon_\\mu(\\neg p) = 1 \u2212 \\varepsilon_\\mu(p)\\)</li> <li>pour toutes expressions \\(p1\\) et \\(p2\\) : </li> </ul> \\[\\begin{align}     \\varepsilon_\\mu(p_1 \\wedge p_2) &amp;= \\varepsilon_\\mu(p_1)\\varepsilon_\\mu(p_2)\\\\     \\varepsilon_\\mu(p_1 \\vee p_2) &amp;= \\varepsilon_\\mu(p_1) + \\varepsilon_\\mu(p_2) \u2212 \\varepsilon_\\mu(p_1)\\varepsilon_\\mu(p_2)\\\\      \\varepsilon_\\mu(p_1 \\rightarrow p_2) &amp;= 1 \u2212 \\varepsilon_\\mu(p_1) + \\varepsilon_\\mu(p_2)\\varepsilon_\\mu(p_1). \\end{align}\\] <p>Remarque</p> <p>Observer l\u2019analogie avec les fonctions caract\u00e9ristiques.</p>"},{"location":"Logique/logique/#implication","title":"Implication","text":"<ul> <li>Comme on va le voir a \\(\\rightarrow\\) b est s\u00e9mantiquement \u00e9quivalent \u00e0  \\(\\neg\\)a \\(\\vee\\) b, c\u2019est \u00e0 dire que les deux propositions ont la m\u00eame valeur de  v\u00e9rit\u00e9 pour toute interpr\u00e9tation.</li> <li>L\u2019interpr\u00e9tation de l\u2019implication donn\u00e9e au transparent pr\u00e9c\u00e9dent  s\u2019obtient par calcul :  </li> </ul> \\[ \\begin{align} \\varepsilon_\\mu((\\neg p_1) \\vee  p_2)     &amp;=  \\varepsilon_\\mu(\\neg p_1) + \\varepsilon_\\mu(p_2) \u2212 \\varepsilon_\\mu(\\neg p_1)\\varepsilon_\\mu(p_2)  \\\\     &amp;= (1 \u2212 \\varepsilon_\\mu(p_1)) + \\varepsilon_\\mu(p_2) \u2212 (1 \u2212 \\varepsilon_\\mu(p_1))\\varepsilon_\\mu(p_2)  \\\\     &amp;= 1 \u2212 \\varepsilon_\\mu(p_1) + \\varepsilon_\\mu(p_2) \u2212 \\varepsilon_\\mu(p_2) + \\varepsilon_\\mu(p_1)\\varepsilon_\\mu(p_2)  \\\\     &amp;= 1 \u2212 \\varepsilon_\\mu(p_1) + \\varepsilon_\\mu(p_2)\\varepsilon_\\mu(p_1)  \\\\     &amp;=\\varepsilon_\\mu(p_1 \\rightarrow  p_2) \\end{align} \\]"},{"location":"Logique/logique/#tables-de-verite","title":"Tables de v\u00e9rit\u00e9","text":""},{"location":"Logique/logique/#equivalence-semantique","title":"Equivalence s\u00e9mantique","text":"<p>D\u00e9finition: S\u00e9mantiquement \u00e9quivalent</p> <p>Deux propositions p, q sont dites s\u00e9mantiquement \u00e9quivalentes si elles ont m\u00eame table de v\u00e9rit\u00e9. Ceci revient \u00e0 dire que pour tout contexte \\(\\mu\\), si \\(\\varepsilon_\\mu\\) de l\u2019une vaut 1, alors pour l\u2019autre aussi.On note p \\(\\equiv\\) q.</p> <p>D\u00e9finition: Tautologie</p> <p>On dit qu\u2019une proposition p est une tautologie lorsque p \\(\\equiv\\) V (c\u2019est \u00e0 dire que la derni\u00e8re colonne de sa table de v\u00e9rit\u00e9 ne contient que des 1).</p> <p>Remarque</p> <ul> <li>Par exemple \\(a \\wedge V\\) est s\u00e9mantiquement \u00e9quivalente \u00e0 \\(a\\).  </li> <li>Montrer que le tiers exclu \\(a \\vee \\neg a\\) est une tautologie.  </li> <li>Certains auteurs parlent d\u2019\u00e9quivalence logique.  </li> </ul>"},{"location":"Logique/logique/#xor","title":"XOR","text":"<p>Exercice</p> <p>D\u00e9finir l\u2019op\u00e9rateur XOR au moyen des op\u00e9rateurs usuels</p> <p>La table du XOR (=OU du cantinier)</p> \\[\\begin{array}{c|c|c} a &amp; b &amp; a \\oplus b\\\\ \\hline 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 1 \\\\ 0 &amp; 0 &amp; 0 \\end{array}\\]"},{"location":"Logique/logique/#priorites","title":"Priorit\u00e9s","text":"<ul> <li>Les op\u00e9rateurs \\(\\wedge\\)  et \\(\\vee\\)  sont associatifs : en cons\u00e9quence on peut \u00e9crire  ((a \\(\\vee\\)  b) \\(\\vee\\)  (c \\(\\vee\\)  d)) comme a \\(\\vee\\)  b \\(\\vee\\)  c \\(\\vee\\)  d</li> <li>\\(\\rightarrow\\)  n\u2019est pas associatif : a \\(\\rightarrow\\)  (b \\(\\rightarrow\\)  c) n\u2019est pas s\u00e9mantiquement  \u00e9quivalent \u00e0 (a \\(\\rightarrow\\)  b) \\(\\rightarrow\\)  c</li> <li>Exercice : montrer ces assertions par des tables de v\u00e9rit\u00e9.  </li> <li>L\u2019implication n\u2019est pas associative mais par convention  A \\(\\rightarrow\\)  B \\(\\rightarrow\\)  C \\(\\rightarrow\\)  D se lit A \\(\\rightarrow\\)  (B \\(\\rightarrow\\)  (C \\(\\rightarrow\\)  D)).</li> </ul> <p>Observer l\u2019analogie avec une fonction f de type <code>a-&gt;b-&gt;c-&gt;d</code> en  Ocaml : f x est de type <code>b-&gt;c-&gt;d</code>.  </p>"},{"location":"Logique/logique/#dautres-operateurs","title":"D\u2019autres op\u00e9rateurs","text":"<p>Exercice</p> <ul> <li>Montrer qu\u2019on peut se passer de l\u2019op\u00e9rateur d\u2019implication.  </li> <li>On d\u00e9finit l\u2019op\u00e9rateur binaire NOR ainsi : NOR(a, b) a la table de  \\(\\neg (a \\vee  b)\\). Montrer que NOR(a, b) est s\u00e9mantiquement \u00e9quivalent \u00e0  \\(\\neg a \\wedge\\neg\\) b (seconde loi de De Morgan).  </li> <li>L\u2019op\u00e9rateur binaire NAND est d\u00e9fini ainsi : NAND(a, b) a la table de \\(\\neg (a \\wedge  b)\\). Montrer que NAND(a, b) est s\u00e9mantiquement \u00e9quivalent \u00e0  \\(\\neg a \\vee  \\neg b\\) (premi\u00e8re loi de De Morgan).</li> <li>L\u2019op\u00e9rateur binaire \\(\\Leftrightarrow\\) est d\u00e9fini ainsi : \\(a \\Leftrightarrow  b\\) a la table de  \\((a \\rightarrow b) \\wedge  (b \\rightarrow   a)\\). Montrer que \\(a\\) XOR \\(b\\) est s\u00e9mantquement  \u00e9quivalent \u00e0 \\(\\neg (a \\Leftrightarrow  b)\\).  </li> </ul> Calcul \u00e0 partir de l\u2019arbre syntaxique <p>\\((a \\vee n) \\rightarrow ((\\neg c)\\vee (b \\wedge V)), \\mu(a) = 1; \\mu(b) = \\mu(c) = 0\\). Commencer par les feuilles et remonter aux p\u00e8res.</p> <p><p></p></p> <p><p></p></p> <p><p></p></p> <p><p></p></p> <p><p></p></p>"},{"location":"Logique/logique/#satisfiabilite","title":"Satisfiabilit\u00e9","text":""},{"location":"Logique/logique/#tautologie","title":"Tautologie","text":""},{"location":"Logique/logique/#tautologie-proposition-satisfiable","title":"Tautologie, proposition satisfiable","text":"<p>D\u00e9finition: Tautologie, mod\u00e8le et antilogie</p> <ul> <li>On appelle tautologie toute expression \u00e9valu\u00e9e \u00e0 1 dans tout contexte.</li> <li>Une proposition p est dite satisfiable si il existe un contexte \\(\\mu\\) tel que  \\(\\varepsilon_\\mu(p) = 1\\). On dit que \\(\\mu\\) est un mod\u00e8le de p et on note \\(\\mu \\models p\\).  </li> <li>Une proposition qui n\u2019est pas satisfiable est apell\u00e9e une antilogie. On  dit aussi que l\u2019expression est insatisfiable.  </li> </ul> <p>Exemples</p> <ul> <li>Le tiers exclu \\(a \\vee  \\neg a\\) est une tautologie, \\((a \\wedge  b) \\rightarrow  b\\) aussi.  </li> <li>\\(a \\rightarrow  b\\) est satisfiable mais n\u2019est pas une tautologie.  </li> <li>\\(a \\wedge  \\neg a\\) est insatisfiable.  </li> <li>Montrer que \\((\\neg A \\rightarrow  A) \\rightarrow  A\\) est une tautologie  </li> </ul>"},{"location":"Logique/logique/#notation","title":"Notation","text":"<ul> <li>Pour indiquer qu\u2019une proposition a est s\u00e9mantiquement \u00e9quivalente \u00e0  une proposition b, il n\u2019est pas su\ufb03sant d\u2019\u00e9crire \\(a \\Leftrightarrow b\\).</li> <li>En effet \\(a \\Leftrightarrow b\\) est juste une proposition. Celle-ci peut \u00eatre  satisfiable ou non (peut-\u00eatre m\u00eame pas, comme \\(V \\Leftrightarrow F\\) ).  </li> <li>La bonne fa_on d\u2019indiquer cette \u00e9quivalence est de d\u00e9clarer  \"\\(a \\Leftrightarrow b\\) est une tautologie\".</li> <li>Les math\u00e9maticiens sont parfois paresseux : il leur arrive d\u2019\u00e9crire  \"\\(a \\Leftrightarrow b\\)\" au lieu de \"\\(a \\Leftrightarrow b\\) est vraie (ce qui signifie vraie  pour tout contexte)\".  </li> <li>On \u00e9crit \\(a \\equiv b\\) pour indiquer que \\(a \\Leftrightarrow b\\) est une tautologie.  </li> <li>Attention, \"\\(\\equiv\\)\" n\u2019est pas un op\u00e9rateur (il n\u2019appartient pas au  langage) mais un m\u00e9ta-op\u00e9rateur.  </li> </ul> <p>A ce propos, un principe empirique est que, pour exprimer des id\u00e9es  sur un langage, il faut souvent \"sortir\" du langage.  </p>"},{"location":"Logique/logique/#notion-de-consequence","title":"Notion de cons\u00e9quence","text":"<p>D\u00e9finition: Cons\u00e9quence</p> <p>On consid\u00e8re une expression logique p et \\(\\chi\\) un ensemble d\u2019expressions logiques. On dit que p est une cons\u00e9quence de \\(\\chi\\) si toute interpr\u00e9tation qui satisfait toutes les formules de l\u2019ensemble \\(\\chi\\) satisfait p. Si c\u2019est le cas, on note : \\(\\chi \\models p\\).</p> <p>Notation</p> <p>Si \\(\\chi = \\left \\{  h_1, \\dotsb , h_n \\right \\}\\), on \u00e9crit aussi \\(h_1, \\dotsb , h_n \\models p\\).  Si \\(\\chi = \\left \\{h \\right \\}\\), on \u00e9crit \\(h \\models p\\)  Par convention, \\(\\models p\\) indique que p est une tautologie.  </p>"},{"location":"Logique/logique/#proprietes-de-leftrightarrow","title":"Propri\u00e9t\u00e9s de \\(\\Leftrightarrow\\)","text":"<p>Pour toutes propositions \\(p_1, p_2, p_3\\), les propositions suivantes sont des  tautologies :</p> <p>Propori\u00e9t\u00e9 de \\(\\Leftrightarrow\\)</p> <ul> <li>R\u00e9flexivit\u00e9 \\(p_1 \\Leftrightarrow p_1\\)</li> <li>Sym\u00e9trie \\((p_1 \\Leftrightarrow p_2) \\Leftrightarrow (p_2 \\Leftrightarrow p_1)\\)</li> <li>Transitivit\u00e9 \\(((p_1 \\Leftrightarrow p_2) \\wedge  (p_2 \\Leftrightarrow p_3)) \\Leftrightarrow (p_1 \\Leftrightarrow p_3)\\)</li> </ul>"},{"location":"Logique/logique/#proprietes-de-wedge","title":"Propri\u00e9t\u00e9s de \\(\\wedge\\)","text":"<p>Pour toutes propositions \\(p_1, p_2, p_3\\), les propositions suivantes sont des tautologies :</p> <p>Propori\u00e9t\u00e9 de \\(\\wedge\\)</p> <ul> <li>El\u00e9ment neutre \\((p_1 \\wedge  V ) \\Leftrightarrow p_1\\)</li> <li>El\u00e9ment absorbant \\((p_1 \\wedge  F )\\Leftrightarrow F\\)</li> <li>Commutativit\u00e9 \\((p_1 \\wedge  p_2) \\Leftrightarrow (p_2 \\wedge  p_1)\\)</li> <li>Associativit\u00e9 \\((p_1 \\wedge  (p_2 \\wedge  p_3))\\Leftrightarrow ((p_1 \\wedge  p_2) \\wedge  p_3)\\)</li> <li>Idempotence \\((p_1 \\wedge  p_1) \\Leftrightarrow p_1\\)</li> </ul>"},{"location":"Logique/logique/#proprietes-de-vee","title":"Propri\u00e9t\u00e9s de \\(\\vee\\)","text":"<p>Pour toutes propositions \\(p_1, p_2, p_3\\), les propositions suivantes sont des tautologies :</p> <p>Propri\u00e9t\u00e9s de \\(\\vee\\)</p> <ul> <li>El\u00e9ment neutre \\((p_1 \\vee  F ) \\Leftrightarrow p_1\\)</li> <li>El\u00e9ment absorbant \\((p_1 \\vee  V ) \\Leftrightarrow V\\)</li> <li>Commutativit\u00e9 \\((p_1 \\vee  p_2) \\Leftrightarrow (p_2 \\vee  p_1)\\)</li> <li>Associativit\u00e9 \\((p_1 \\vee  (p_2 \\vee  p_3)) \\Leftrightarrow ((p_1 \\vee  p_2) \\vee  p_3)\\)</li> <li>Idempotence \\((p_1 \\vee  p_1) \\Leftrightarrow p_1\\)</li> </ul>"},{"location":"Logique/logique/#relations-entre-vee-et-wedge","title":"Relations entre \\(\\vee\\)  et \\(\\wedge\\)","text":"<p>Pour toutes propositions \\(p_1, p_2, p_3\\), les propositions suivantes sont des tautologies :</p> <ul> <li>Subsomption \\((p_1 \\vee  (p_1 \\wedge  p_2)) \\Leftrightarrow p_1\\)</li> <li>Subsomption \\((p_1 \\wedge  (p_1 \\vee  p_2)) \\Leftrightarrow p_1\\)</li> <li>Distributivit\u00e9 \\((p_1 \\wedge  (p_2 \\vee  p_3)) \\Leftrightarrow (p_1 \\wedge  p_2) \\vee  (p_1 \\wedge  p_3)\\)</li> <li>Distributivit\u00e9 \\((p_1 \\vee  (p_2 \\wedge  p_3)) \\Leftrightarrow (p_1 \\vee  p_2) \\wedge  (p_1 \\vee  p_3)\\)</li> <li>Premi\u00e8re loi de De Morgan \\(\\neg (p_1 \\wedge  p)_2 \\Leftrightarrow (\\neg p_1) \\vee  (\\neg p_2)\\)</li> <li>Seconde loi de De Morgan \\(\\neg (p_1 \\vee  p_2) \\Leftrightarrow (\\neg p_1) \\wedge  (\\neg p_2)\\)</li> </ul>"},{"location":"Logique/logique/#proprietes-de-rightarrow","title":"Propri\u00e9t\u00e9s de \\(\\rightarrow\\)","text":"<p>Pour toutes propositions \\(p_1, p_2, p_3\\), les propositions suivantes sont des tautologies :</p> <p>Propri\u00e9t\u00e9s de \\(\\rightarrow\\)</p> <ul> <li>Modus ponens \\((p_1 \\wedge  (p _1\\rightarrow  p_2)) \\rightarrow  p_2\\)</li> <li>Double implication \\(((p_1 \\rightarrow  p_2) \\wedge  (p_2 \\rightarrow  p_1)) \\Leftrightarrow (p_1 \\Leftrightarrow p_2)\\)</li> </ul>"},{"location":"Logique/logique/#raisonnement-en-mathematiques","title":"Raisonnement en math\u00e9matiques","text":"<p>Pour toutes propositions \\(p_1, p_2\\), les propositions suivantes sont des tautologies :</p> <ul> <li>Disjonction de cas \\(((p_1 \\rightarrow  p_2) \\wedge  (\\neg p_1 \\rightarrow  p_2)) \\Leftrightarrow p_2\\)</li> <li>Contraposition \\((p_1 \\rightarrow  p_2) \\Leftrightarrow (\\neg p_2 \\rightarrow  \\neg p_1)\\)</li> <li>Raisonnement par l\u2019absurde \\((\\neg p_1 \\rightarrow  F ) \\Leftrightarrow p_1\\)</li> </ul> <p>Exercice</p> <p>Montrer qu\u2019on a bien des tautologies en consruisant des tables de v\u00e9rit\u00e9.</p>"},{"location":"Logique/logique/#formes-normales","title":"Formes normales","text":""},{"location":"Logique/logique/#ecriture-simplifiee","title":"Ecriture simplifi\u00e9e","text":"<p>Pour travailler avec une proposition p, il est souvent utile de  consid\u00e9rer une expression s\u00e9mantiquement \u00e9quivalente \u00e0 p mais plus  simple :  </p> <ul> <li>Ce peut \u00eatre une version standardis\u00e9e, dite normale (Analogie :  \\(\\frac{6}{4}\\) a pour forme normale \\(\\frac{3}{2}\\) )</li> <li>ou encore une version avec moins de connecteurs : F pour \\(a \\wedge  (\\neg a)\\) (Analogie : 6 pour 1 + 2 + 3).  </li> </ul>"},{"location":"Logique/logique/#litteraux","title":"Litt\u00e9raux","text":"<p>D\u00e9finition: Litt\u00e9ral</p> <p>On appelle litt\u00e9ral toute proposition de la forme v ou \\(\\neg\\)v o\u00f9 v est une variable propositionnelle.</p> <p>D\u00e9finition: Conjonction et disjonction</p> <p>On appelle conjonction (resp. disjonction) des propositions \\(p_1, \\dotsb , p_n\\) (n \\(\\geq\\) 1), la proposition \\(p_1 \\wedge  p_2 \\dotsb \\wedge  p_n\\) (resp. \\(p_1 \\vee  p_2 \\dotsb \\vee  p_n\\))</p> <p>Remarque</p> <p>Par convention :</p> <ul> <li>Une conjonction de 0 proposition est V  </li> <li>Une disjonction de 0 proposition est F  </li> <li>Tout litt\u00e9ral est \u00e0 la fois une conjonction et une disjonction.  </li> </ul>"},{"location":"Logique/logique/#clauses-monomes","title":"Clauses, Mon\u00f4mes","text":"<p>D\u00e9finition: Clause</p> <p>On appelle clause toute disjonction de litt\u00e9raux. F , disjonction de z\u00e9ro litt\u00e9ral, est appel\u00e9 la clause vide. (Moyen mn\u00e9motechnique : claUse \\(\\leftrightarrow \\cup  \\leftrightarrow \\vee\\) )</p> <p>D\u00e9finition: Mon\u00f4me</p> <p>On appelle mon\u00f4me toute conjonction de litt\u00e9raux. V , conjonction de z\u00e9ro litt\u00e9ral, est appel\u00e9 le mon\u00f4me vide. (Moyen mn\u00e9motechnique : mon\u00f4me \\(\\leftrightarrow \\wedge\\))</p> <p>D\u00e9finition: Forme normale conjonctive</p> <p>On appelle forme normale conjonctive (FNC) toute conjonction de clauses et forme normale disjonctive (FND) toute disjonction de mon\u00f4mes.</p>"},{"location":"Logique/logique/#forme-normale-conjonctivedisjonctive","title":"forme normale conjonctive/disjonctive","text":"<p>Proposition</p> <p>Toute proposition est s\u00e9mantiquement \u00e9quivalente \u00e0 une forme normale conjonctive (resp. forme normale disjonctive).</p> <p>Remarque</p> <ul> <li>Fait : On n\u2019a besoin que des 3 op\u00e9rateurs \\(\\neg , \\vee , \\wedge\\)</li> <li>Convertir une proposition en forme normale conjonctive requiert  l\u2019utilisation de r\u00e8gles de transformation logiques, comme l\u2019\u00e9limination de double n\u00e9gations, les lois de De Morgan, et la loi de distributivit\u00e9.</li> <li>Principe : ramener la n\u00e9gation \"au contact\" des variables (de Morgan), \"remonter\" les \\(\\wedge\\) (distibutivit\u00e9) et supprimer les \\(\\neg \\neg\\). Par exemple, si \\(v_1, v_2, v_3, v_4\\) sont des variables :</li> </ul> \\[\\begin{align} \\underset{\\textsf{F. ni conjonctive ni disjonctive}}{\\underbrace{\\neg(v_1\\wedge (v_2\\vee \\neg v_3)) \\vee v_4}} &amp;\\equiv \\neg v_1 \\vee \\neg(v_2 \\vee \\neg v_3) \\vee v_4 \\\\  &amp;\\equiv \\neg v_1 \\vee (\\neg v_2 \\wedge \\neg \\neg v_3) \\vee v_4 \\\\ &amp;\\equiv (\\neg v_1 \\vee \\neg v_2 \\vee v_4) \\wedge (\\neg v_1 \\vee v_3 \\vee v_4) \\end{align}\\] <ul> <li>Les formes normales conjonctives ou disjonctives de litt\u00e9raux ne sont  en g\u00e9n\u00e9ral pas uniques !  </li> </ul> <p>Exemples</p> <p>Les propositions suivantes, dans lesquelles \\(a, b, c, d, e, f\\) sont des litt\u00e9raux,  sont des formes conjonctives :  </p> <ul> <li>\\(a \\wedge  b\\)</li> <li>\\(a \\vee  b\\) (oui car c\u2019est une clause - il y a z\u00e9ro conjonction-)  </li> <li>\\(a\\) </li> <li>\\((a \\vee  b) \\wedge  c\\)</li> <li>\\((a \\vee  \\neg b \\vee  \\neg c) \\wedge  (\\neg d \\vee  e \\vee  f )\\) </li> </ul> <p>Contre exemples</p> <p>Les propositions suivantes, dans lesquelles \\(a, b, c, d, e, f\\) sont des variables,  ne sont pas des formes conjonctives :  </p> <ul> <li>\\(\\neg (a \\wedge  b)\\) : la n\u00e9gation \\(\\neg\\)  est devant la proposition \\((a \\wedge  b)\\) qui n\u2019est  pas atomique (ce n\u2019est pas un litt\u00e9ral)  </li> <li>\\(a \\wedge  (b \\vee  (c \\wedge  d))\\) : un \\(\\wedge\\) est imbriqu\u00e9 dans un \\(\\vee\\) .  </li> </ul>"},{"location":"Logique/logique/#reecriture","title":"R\u00e9\u00e9criture","text":"<p>Pour obtenir une FNC \u00e0 partir d\u2019une propositioon p :</p> <ul> <li>Supprimer les constantes : V est remplac\u00e9 par \\(v \\vee \\neg v\\) ; F par \\(v \\wedge \\neg v\\) o\u00f9 \\(v\\) est une variable.</li> <li>Supprimer les implications : on exprime la proposition uniquement avec des \\(\\neg, \\vee, \\wedge\\)</li> <li>On descend \\(\\neg\\) par les lois de De Morgan au contact des variables. -On applique la distributivit\u00e9 pour faire descendre les \\(\\vee\\) et remonter les \\(\\wedge\\).</li> </ul>"},{"location":"Logique/logique/#uniquement-des-neg-et-des-wedge","title":"Uniquement des \\(\\neg\\)  et des \\(\\wedge\\)","text":"<p>Toute proposition peut \"s\u2019exprimer\" sans constante : V est remplac\u00e9 par \\(v \\vee \\neg v\\) ; F par \\(v \\wedge  \\neg v\\) o\u00f9 \\(v\\) est une variable.  </p> <p>Tous les op\u00e9rateurs peuvent se d\u00e9finir avec \\(\\neg , \\wedge , \\vee\\)  uniquement.  </p> <p>Une disjonction \\(a \\vee  b\\) peut s\u2019exprimer comme la n\u00e9gation d\u2019une  conjonction \\(\\neg (\\neg a \\wedge  \\neg b)\\) </p> <p>En appliquant ces r\u00e8gles, on obtient que toute proposition est  s\u00e9mantiquement \u00e9quivalente \u00e0 une expression ne contenant que des  variables et les connecteurs \\(\\neg , \\wedge\\) . Ceci nous sert au transparent  suivant.  </p> <p>Preuve d\u2019existence d\u2019une forme normale conjonctive</p> <p>R\u00e9currence sur la taille de la proposition p. </p> <p>HR : p est \u00e9quivalente \u00e0 FNC.</p> <ul> <li>Si p est un litt\u00e9ral : ok.</li> <li> <p>Si p = \\(\\neg\\)q, on applique l\u2019hypoth\u00e8se de r\u00e9currence \u00e0 q qui s\u2019\u00e9crit donc  \\(c_1 \\wedge  \\dotsb \\wedge  c_n\\) o\u00f9 les \\(c_i\\) sont des clauses.</p> <ul> <li>Par les lois de De Morgan, chaque clause \\(c_i\\) s\u2019\u00e9crit comme un \\(\\neg m_i\\) o\u00f9  \\(m_1\\) est un mon\u00f4me mi =  \\(\\bigwedge_{k_i=1}^{n_i} l_{i,k_i}\\)(les \\(l_{i,k_i}\\) sont des litt\u00e9raux).</li> <li>Alors par De Morgan (encore) : \\(p \\equiv \\neg (\\neg m_1 \\wedge  \\dotsb \\wedge  \\neg m_n) \\equiv (\\neg \\neg m_1) \\vee  \\dotsb \\vee  (\\neg \\neg m_n) \\equiv m_1 \\vee  \\dotsb \\vee  m_n\\). </li> <li>On a bien ce qu\u2019on veut : $$ p \\equiv \\bigvee_{i=1}^n (\\bigwedge_{k_i=1}^{n_i} l_{i,k_i})  \\underset{\\textsf{distributivit\u00e9}}{\\underbrace{\\equiv}}~~\\overbrace{\\underset {\\underset {k_n \\in [![1~,~n_n]!]}{\\vdots}}{\\bigwedge_{k_1 \\in [![1~;~ n_1]!]}}\\underset{\\textsf{clause}}{l_{1,k_1 \\vee \\dotsb \\vee l_{n,k_n}}}}^{\\textsf{conjonction de clauses}} $$</li> </ul> </li> <li> <p>Si \\(p = f_1 \\wedge  f_2,\\) par HR \\(f_1 \\equiv p_1 \\wedge  \\dotsb \\wedge  p_n\\) et \\(f_2 \\equiv q_1 \\wedge  \\dotsb \\wedge  q_n\\) o\u00f9 les  \\(p_k , q_r\\) sont des clauses. $$ p \\underset{\\textsf{assoc. de}~\\wedge}{\\underbrace{\\equiv}}  \\underset{\\textsf{conjonction de clauses}}{\\underbrace{p_1 \\wedge  \\dotsb \\wedge  p_{n_1} \\wedge  q_1 \\wedge  \\dotsb \\wedge  q_{n_2}}} $$ Ce qu\u2019on veut.  </p> </li> <li> <p>Si p = \\(f_1 \\vee f_2\\) alors, par HR, p est \u00e9quivalent \u00e0 une formule de la forme \\((p_1 \\wedge \\dotsb \\wedge p_{n_1} ) \\vee (q_1 \\wedge \\dotsb \\wedge q_{n_2} )\\) o\u00f9 les \\(p_i ,q_j\\) sont des clauses. Et par distributivit\u00e9 : \\(p \\equiv \\underset{(k_1,k_2)\\in [\\![1,n_1]\\!] \\times [\\![1, n_2]\\!] }{\\bigwedge} ~(p_{k_1} \\vee q_{k_2 }) : \\textsf{OK}\\)</p> </li> </ul>"},{"location":"Logique/logique/#forme-normale-disjonctive","title":"Forme normale disjonctive","text":"<ul> <li>On sait que toute proposition peut s\u2019exprimer comme conjonction de  clause.</li> </ul> <ul> <li>Soit p une proposition, alors \\(\\neg\\)p s\u2019\u00e9crit sous la forme \\(\\neg p \\equiv c_1 \\wedge  \\dotsb \\wedge  c_n\\) avec \\(c_i = l_{i,1} \\vee  \\dotsb \\vee  l_{i,n_i}\\) .  </li> <li>Donc \\(p \\equiv \\neg \\neg p \\equiv \\neg c_1 \\vee  \\dotsb \\vee  \\neg c_n\\) par De Morgan.  </li> <li>Or chaque \\(\\neg c_i\\) est \u00e9quivalent s\u00e9mantiquement \u00e0 une conjonction de  litt\u00e9raux (par De Morgan) : \\(\\neg c_i \\equiv \\neg l_{i,1} \\wedge  \\dotsb \\wedge  \\neg l_{i,n_i}\\).</li> </ul> <ul> <li>Donc toute proposition peut s\u2019\u00e9crire comme disjonction de mon\u00f4mes.  </li> <li>PB : ces r\u00e9\u00e9critures ne sont pas uniques.  </li> </ul>"},{"location":"Logique/logique/#explosion-combinatoire","title":"Explosion combinatoire","text":"<p>Consid\u00e9rons la proposition en forme disjonctive :  \\((\\textsf{x}_1 \\wedge  \\textsf{y}_1) \\vee  (\\textsf{x}_2 \\wedge  \\textsf{y}_2) \\vee  \\dotsb \\vee  (\\textsf{x}_n \\wedge  \\textsf{y}_n)\\) de taille lin\u00e9aire  </p> <p>Par distributivit\u00e9, sa FNC, de taille 2n, est de la forme :  </p> \\[ \\begin{align} (\\textsf{x}_1 \\vee  \\textsf{x}_2 \\vee  \\dotsb \\vee  \\textsf{x}_{n-1} \\vee  \\textsf{x}_n) \\wedge  (\\textsf{x}_1 \\vee  \\textsf{x}_2 \\vee  \\dotsb \\vee  \\textsf{x}_{n-1} \\vee  \\textsf{y}_n) \\wedge  \\dotsb \\\\ \\dotsb \\wedge  (\\textsf{x}_1 \\vee  \\textsf{x}_2 \\vee  \\dotsb \\vee  \\textsf{x}_k \\vee  \\textsf{y}_{k+1} \\vee  \\dotsb \\vee  \\textsf{y}_{n-1} \\vee  \\textsf{y}_n) \\wedge  \\dotsb \\\\ \\wedge (\\textsf{x}_1 \\vee  \\textsf{y}_2 \\vee  \\dotsb \\vee  \\textsf{y}_{n-1} \\vee  \\textsf{y}_n) \\wedge  (\\textsf{y}_1 \\vee  \\textsf{y}_ 2\\vee  \\dotsb \\vee  \\textsf{y}_{n-1} \\vee  \\textsf{y}_n) \\end{align} \\]"},{"location":"Logique/logique/#mintermes-maxtermes","title":"Mintermes, maxtermes","text":"<p>D\u00e9finition: Minterme / Maxterme</p> <p>Soient \\(v_1, \\dotsb , v_n\\) des variables distinctes.</p> <ul> <li>On appelle minterme de \\(v_1, \\dotsb , v_n\\), tout mon\u00f4me o\u00f9 chaque variable  \\(v_i\\) appara\u00eet exactement une fois (et il n\u2019y a pas d\u2019autre variable).  </li> <li>On appelle mAxterme de \\(v_1, \\dotsb , v_n\\), une clAuse o\u00f9 chaque variable \\(v_i\\)  appara\u00eet exactement une fois (et il n\u2019y a pas d\u2019autre variable).  </li> </ul> <p>Remarque</p> <p>Les 4 (\u00e0 l\u2019ordre pr\u00e8s) maxtermes de \\(v_1\\) et \\(v_2\\) sont \\(v_1 \\vee  v_2, v_1 \\vee  \\neg v_2, \\neg v_1 \\vee  v_2, \\neg v_1 \\vee  \\neg v_2\\). On confond les maxtermes \\(v_1 \\vee  v_2\\) et \\(v_2 \\vee  v_1\\).  </p>"},{"location":"Logique/logique/#forme-normale-conjonctive","title":"Forme normale conjonctive","text":"<p>D\u00e9finition: Forme normale conjonctive/disjonctive compl\u00e8te</p> <p>On dit qu\u2019une proposition est en forme normale conjonctive compl\u00e8te (i.e. avec maxtermes) (FNCC), si elle s\u2019\u00e9crit comme une conjonction de maxtermes tous distincts.</p> <p>On dit qu\u2019une proposition est en forme normale disjonctive compl\u00e8te (i.e. avec mintremes) (FNDC), si elle s\u2019\u00e9crit comme une disjonction de mintermes tous distincts.</p> <p>Remarque</p> <p>Mettre une proposition sous FNCC, c\u2019est donner une expression en  FNCC s\u00e9mantiquement \u00e9quivalente \u00e0 cette proposition.</p> <p>\\((v_1 \\vee  \\neg v_2 \\vee  v_3) \\wedge  (v_1 \\vee  v_2 \\vee  \\neg v_3)\\) est une FNCC sur les variables  \\(v_1, v_2, v_3\\) mais pas \\((v_1\\vee  \\neg v_2 \\vee  v_3) \\wedge  \\neg (v_1 \\vee  v_2 \\vee  \\neg v_3)\\) car la n\u00e9gation  n\u2019est pas au contact des variables. \\((v_1 \\vee v_2 \\vee \\neg v_3 ) \\wedge (v_1 \\vee v_3 )\\) non plus car il manque une variable. </p> <p>Utilisation : d\u00e9monstration automatique de th\u00e9or\u00e8mes ou PB SAT.      </p>"},{"location":"Logique/logique/#forme-normale-conjonctive_1","title":"Forme normale conjonctive","text":"<p>Proposition</p> <p>Toute proposition est s\u00e9mantiquement \u00e9quivalente \u00e0 une FNCC (resp.  FNDC) unique \u00e0 l\u2019ordre des maxtermes (resp. mintermes) pr\u00e8s (et \u00e0 ordre  des litt\u00e9raux pr\u00e8s dans chaque maxterme -resp. minterme-).  </p> <p>Remarque</p> <p>Dans ce qui suit on dit que deux FNDC sont \u00e9gales si elles ont les m\u00eames mintermes (les mintermes sont donn\u00e9s \u00e0 l\u2019ordre des litt\u00e9raux pr\u00e8s).</p>"},{"location":"Logique/logique/#existence-de-la-fndc","title":"Existence de la FNDC","text":"<p>D\u00e9monstration</p> <ul> <li>On construit la table de v\u00e9rit\u00e9 de la proposition : il y a \\(2^n\\) lignes  correspondants aux valeurs de v\u00e9rit\u00e9 des n variables de p.  </li> <li>Chaque ligne satisfaisant l\u2019expression (1 dans la derni\u00e8re colonne)  donne un minterme. Toutes les variables sont pr\u00e9sentes et une variable v y appara\u00eet positivement (v) si sa valeur de v\u00e9rit\u00e9 dans la  ligne est 1, n\u00e9gativement (\\(\\neg\\)v ) sinon.  </li> <li>On consid\u00e8re la disjonction de tous les mintermes ainsi obtenus. C\u2019est  une expression q en FNDC.  </li> <li>Soit \\(\\mu\\) un contexte. Si \\(\\varepsilon_\\mu(p) = 1\\), alors le minterme associ\u00e9 \u00e0 \\(\\mu\\) est  vrai pour \\(\\mu\\) donc \\(\\varepsilon_\\mu(q) = 1\\).  </li> <li>Si \\(\\varepsilon_\\mu(p) = 0\\), alors q ne contient pas le minterme associ\u00e9 \u00e0 \\(\\mu\\). Ainsi,  pour tout minterme m de q, on a \\(\\varepsilon_\\mu(m)=0\\) et donc \\(\\varepsilon_\\mu(q) = 0\\). </li> <li>\\(\\color{red}{\\textsf{Donc p et q prennent bien la m\u00eame valeur pour tout contexte.}}\\) </li> </ul>"},{"location":"Logique/logique/#unicite-de-la-fndc-a-lordre-pres","title":"Unicit\u00e9 de la FNDC \u00e0 l\u2019ordre pr\u00e8s","text":"<p>Soient \\(p \\equiv q\\) deux FNDC. Elles ont donc m\u00eame table. Si \\(p \\neq q\\) et \\(p, q\\) ne poss\u00e8dent qu\u2019un minterme :  </p> <ul> <li>Si p, q ont deux litt\u00e9raux \\(l, l'\\) de la m\u00eame variable v distincts, l\u2019un des  litt\u00e9raux vaut \\(\\neg\\)v l\u2019autre v . Autrement dit \\(l \\equiv \\neg l'\\)</li> <li>Comme p est une conjonction, il n\u2019y a qu\u2019un seul contexte c (i.e. une  seule ligne) dans lequel p vaut 1.</li> <li>Alors \\(l\\) vaut aussi 1 dans ce contexte (p \u00e9tant une conjonction).</li> <li>Donc \\(l'\\) vaut 0 dans c. Et donc q vaut 0 dans c. p et q ne peuvent avoir m\u00eame table.</li> <li>De ce qui pr\u00e9c\u00e8de, on d\u00e9duit aussi que des mintermes (ayant les m\u00eames  variables) distincts ne valent jamais 1 en m\u00eame temps.  </li> </ul> <p>On a vu que si \\(p \\neq q\\) et p, q ne poss\u00e8dent qu\u2019un minterme, leurs tables sont diff\u00e9rentes. On en d\u00e9duit que des mintermes distincts ne valent jamais 1 en m\u00eame temps.</p> <p>Si p et q sont des disjonctions de mintermes, et si un minterme m de p ne se retrouve pas dans q :  </p> <ul> <li>Lorsque m vaut 1, p aussi (comme disjonction). Tous les autres  mintermes valent 0 (puisque un seul minterme vaut 1 pour un contexte  donn\u00e9), ceux de p comme ceux de q.  </li> <li>Alors dans ce contexte, comme disjonction de 0, q vaut 0.  </li> <li>Et donc p et q ne peuvent avoir m\u00eame table.  </li> </ul>"},{"location":"Logique/logique/#fncc","title":"FNCC","text":"<p>Soit une expression p \u00e0 n variables,</p> <p>Existence</p> <ul> <li>\\(\\neg p\\) a une FNDC \\(c_1 \\vee \\dotsb \\vee  c_n\\) o\u00f9 les \\(c_i\\) sont des mintermes.</li> <li>Donc p se r\u00e9\u00e9crit comme \\((\\neg c_1) \\wedge  \\dotsb \\wedge (\\neg c_n)\\). Or les n\u00e9gations de mintermes se r\u00e9\u00e9crivent en maxtermes (par De Morgan).</li> <li>Et donc p se r\u00e9\u00e9crit en une FNCC. Voil\u00e0 pour  l\u2019existence.</li> </ul> <p>Unicit\u00e9</p> <p>Si p avait deux FNCC distinctes, par De Morgan \\(\\neg p\\) aurait deux FNDC distinctes. Or il y a une seule FNDC possible pour une formule.</p>"},{"location":"Logique/logique/#probleme-sat","title":"Probl\u00e8me SAT","text":""},{"location":"Logique/logique/#probleme-sat-et-n-sat","title":"Probl\u00e8me SAT et n-SAT","text":""},{"location":"Logique/logique/#presentation-du-probleme-2-sat","title":"Pr\u00e9sentation du probl\u00e8me 2-SAT","text":"<ul> <li>Le probl\u00e8me SAT qui consiste \u00e0 d\u00e9terminer si une proposition est  satisfiable ou non est en g\u00e9n\u00e9ral de complexit\u00e9 exponentielle en le  nombre de variables.  </li> <li>Le probl\u00e8me CNF-SAT est la restriction du probl\u00e8me SAT aux formes  normales conjonctives.  </li> <li>Le probl\u00e8me n-SAT est la restriction du probl\u00e8me SAT aux formes  normales conjonctives avec au plus n litt\u00e9raux par clause.  </li> <li>Le probl\u00e8me 2-SAT consiste \u00e0 d\u00e9terminer si une forme conjonctive  dont les clauses ont seulement deux litt\u00e9raux est satisfiable.  Il admet des solutions polyn\u00f4miales.  </li> </ul>"},{"location":"Logique/logique/#probleme-sat_1","title":"Probl\u00e8me SAT","text":"<ul> <li>Comment tester qu\u2019une proposition est satisfiable ? Il s\u2019agit du  probl\u00e8me dit SAT.  </li> <li>Comment tester qu\u2019une proposition p est une tautologie ? Si on sait  r\u00e9soudre le probl\u00e8me SAT, il su\ufb03t de montrer que \\(\\neg\\) p est insatisfiable.  </li> <li>Pour le probl\u00e8me SAT, on peut simplement calculer sa table. Mais on  a alors une complexit\u00e9 en O(2n), si n est le nombre de variables.  </li> <li>Des algorithmes plus e\ufb03caces (en pratique, c\u2019est \u00e0 dire sauf cas  pathologiques) existent (DPLL) et passent par une mise sous FNC.  Mais dans le pire des cas ce passage \u00e0 la FNC est lui-m\u00eame de  complexit\u00e9 exponentielle.  </li> </ul>"},{"location":"Logique/logique/#probleme-2-sat","title":"Probl\u00e8me 2-SAT","text":""},{"location":"Logique/logique/#2-sat","title":"2-SAT","text":"<p>Cette section est laiss\u00e9e pour info mais sera trait\u00e9e en seconde ann\u00e9e.  </p>"},{"location":"Logique/logique/#probleme-2-sat-aspvall-plass-tarjan","title":"Probl\u00e8me 2-SAT (Aspvall-Plass-Tarjan)","text":"<p>Soit p une proposition mise sous forme conjonctive avec des 2-clauses</p> <ul> <li>On construit un graphe orient\u00e9 :  </li> <li>Ses sommets sont tous les litt\u00e9raux form\u00e9s avec les variables  apparaissant dans la proposition.</li> <li>Les arcs sont des couples de litt\u00e9raux de la forme \\((a, \\neg b)\\) ou \\((\\neg a, b)\\)  mais pas tous ...</li> <li>Pour deux litt\u00e9raux \\(a, b\\), l\u2019arc \\((\\neg a, b)\\) est pr\u00e9sent si et seulement si la  disjonction \\(a \\vee b\\) est dans p. Et dans ce cas \\((a, \\neg b)\\) est pr\u00e9sent aussi.</li> <li>Ceci correspond \u00e0 \\(a \\vee  b \\equiv (\\neg a \\rightarrow  b) \\wedge  (\\neg b \\rightarrow  a)\\) </li> <li>Une fois ce graphe construit, on examine la composante fortement  connexe de toute variable v de p. Si \\(\\neg\\)v est dedans, il y a un chemin  d\u2019implications \\(v \\rightarrow  \\dotsb \\rightarrow  \\neg v\\) et un autre \\(\\neg v \\rightarrow  \\dotsb \\rightarrow  v\\).  </li> <li>Alors \\(v \\Leftrightarrow \\neg v\\) est une cons\u00e9quence de \\(p : p \\models v \\Leftrightarrow \\neg v\\) (ce qui  signifie que tout mod\u00e8le satisfaisant p, satisfait \\(v \\Leftrightarrow \\neg v\\) ). Donc si  p est satisfiable, \\(v \\Leftrightarrow \\neg v\\) aussi : ABSURDE.  </li> <li>Donc si \\(v\\) et \\(\\neg v\\) sont dans la m\u00eame composante connexe, p n\u2019est pas  satisfiable (Aspvall-Plass-Tarjan).  </li> </ul> <p>Exemple (Mansuy)</p> <p>p = \\((v_1 \\vee  v_2) \\wedge  (\\neg v_1 \\vee  v_3) \\wedge  (v_1 \\vee  \\neg v_2) \\wedge  (\\neg v_2 \\vee  v_3) \\wedge  (\\neg v_1 \\vee  \\neg v_3)\\) donne le graphe  </p> <p><p></p></p> <ul> <li>\\(\\neg v_1\\) acc\u00e8de \u00e0 \\(v_1\\) via \\(v_2\\) et</li> <li>\\(v_1\\) acc\u00e8de \u00e0 \\(\\neg v_1\\) via \\(\\neg v_3\\) </li> <li>Donc \\(v_1\\) et \\(\\neg v_1\\) sont dans la m\u00eame composante connexe.</li> <li>Par suite p n\u2019est pas satisfiable.  </li> </ul>"},{"location":"Logique/logique/#probleme-sat_2","title":"Probl\u00e8me SAT","text":"<ul> <li>Le probl\u00e8me SAT est le probl\u00e8me algorithmique qui consiste, \u00e9tant  donn\u00e9e une formule \u00e0 d\u00e9cider en FNC si elle valide ou non.  </li> <li>Le probl\u00e8me est NP-complet, m\u00eame pour le cas particulier 3-SAT o\u00f9 on n\u2019autorise que les clauses d\u2019au plus trois litt\u00e9raux.</li> <li>Un probl\u00e8me P NP-complet v\u00e9rifie :  </li> <li>Il est possible de v\u00e9rifier une solution de P e\ufb03cacement (en temps  polynomial) : on me donne un candidat solution, et je peux v\u00e9rifier en  temps polynomial ce qu\u2019il en est. La classe des probl\u00e8mes v\u00e9rifiant  cette propri\u00e9t\u00e9 est not\u00e9e NP.</li> <li>tous les probl\u00e8mes de la classe NP se ram\u00e8nent \u00e0 P via une r\u00e9duction  polynomiale. Cela signifie que le probl\u00e8me est au moins aussi di\ufb03cile  que tous les autres probl\u00e8mes de la classe NP (aspect \"complet\").  Appliqu\u00e9 \u00e0 la satisfiabilit\u00e9, cela signifie que si on me donne un  probl\u00e8me de la classe NP, je peux le transformer en temps polynomial  en un probl\u00e8me de satisfiabilit\u00e9.</li> <li>Bien s\u00fbr, un probl\u00e8me de la classe P (polynomial) v\u00e9rifie la premi\u00e8re  condition. On a donc P \\(\\subset\\) NP, mais a-t-on NP \\(\\subset\\) P ?  </li> </ul>"},{"location":"Nombres/Nombres%20flottants/","title":"Nombres flottants","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Probl\u00e8me\u00a0: On veut repr\u00e9senter une partie des nombres avec une quantit\u00e9 finie de chiffres apr\u00e8s la virgule</p> <p>Id\u00e9e\u00a0: On se donne tous les chiffres composants le nombre de la position de la virgule\u00a0: 1234,2 repr\u00e9sente 12,34 c\u2019est \u00e0 dire 1,234x10\u00b9</p> <p>Comment\u00a0: On peut \u00e9crire tous les nombres r\u00e9els non nuls sous la forme \\((\u22121)^s(1+m)2^e\\) avec</p> <ul> <li>s\u2208{0,1} le signe du nombre</li> <li>m\u2208[0, 1[ la mantisse</li> <li>e\u2208\u2124 son exposant</li> </ul> <p>L\u2019exposant du nombre repr\u00e9sente la position de la virgule dans son expression en base 2</p> <p>1+m est un nombre entre 1 et 2 (exclu). Il s\u2019\u00e9crit sous la forme \\(1.c\u2081...c_i\\) avec les \\(c_i\u2208{0,1}\\). Comme les ordinateurs ne g\u00e8re que des quantit\u00e9s finies, le nombre de chiffres binaires \\(c_i\\) est born\u00e9 (il est souvent \u00e9gal \u00e0 23 ou 52)</p> <p>L\u2019avantage d\u2019avoir une virgule flottante c\u2019est qu\u2019on peut exprimer 6 fois plus d\u2019expressions qu\u2019en virgule fixe, mais il faut coder la position de la virgule</p>"},{"location":"Nombres/Nombres%20flottants/#ieee754","title":"IEEE754","text":"<p>Standard le plus employ\u00e9 pour le calcul des nombres \u00e0 virgule flottante, il d\u00e9finit les formats de repr\u00e9sentation des nombres \u00e0 virgule flottante (signe mantisse, exposant, nombres d\u00e9normalis\u00e9s) et valeurs sp\u00e9ciales (infinis et NaN) en m\u00eame temps qu\u2019un ensemble d\u2019op\u00e9rations sur les nombres flottants en plus de 4 modes d\u2019arrondi et 5 exceptions (comprenant les conditions dans lesquelles une exception se produit, et ce qui se passe dans ce cas)</p> <p>Les modes d\u2019arrondi\u00a0:</p> <ul> <li>Vers moins l\u2019infini\u00a0: \u230a\u22123,\u22124\u230b=\u22124  </li> <li>Vers plus l\u2019infini\u00a0:\u2308\u22123,\u22124\u2309=\u22123</li> <li>Vers 0\u00a0: \u230a\u22123,\u22124\u230b=\u22123 et \u230a3,4\u230b=3</li> <li>Au plus proche (avec le cas particulier de 1,5 qu\u2019on arrondi vers 1 ou 2?)</li> </ul> <p>La version 1985 d\u00e9finit 4 formats pour repr\u00e9senter les nombres \u00e0 virgule flottante\u00a0:</p> <ul> <li>Simple pr\u00e9cision (32bits\u00a0: 1 bit signe, 8 d\u2019expos, 23 de mantisse et 1 bit implicite)</li> <li>Simple pr\u00e9cision \u00e9tendue (\u2265 43 bits, obsol\u00e8te)</li> <li>Double pr\u00e9cision (64bits\u00a0: 1 bit de signe, 11 d\u2019expo, 52 de mantisse, 1 implicite)</li> <li>Double pr\u00e9cision \u00e9tendue (&gt;79 bits)</li> </ul> <p>Bit implicite</p> <p>La mantisse repr\u00e9sente un nombre d\u00e9cimal entre 1 et 2 (exclu), par exemple 1. 1101100011. Rendre le bit 1 implicite consiste \u00e0 \u00e9crire 1101100011, la partie 1. \u00e9tant sous entendue puisque toujours la m\u00eame.</p> <p>Le format (1, E, M) sur 1 + E + M bits\u00a0:</p> <p></p> <p></p> <p>Ce format (1, 8, 23) est obsol\u00e8te mais on l\u2019utilise parce que c\u2019est plus simple \u00e0 afficher</p> <ul> <li>Bit de poids fort \u00e0 1\u00a0: N\u00e9gatif, \u00e0 0\u00a0: Positif</li> <li>Exposant\u00a0: Pas de repr\u00e9sentation en compl\u00e9ment \u00e0 2. L\u2019exposant est d\u00e9cal\u00e9, afin de le stocker sous forme d\u2019un nombre non sign\u00e9. En notant E le nombre de chiffres (toujours le m\u00eame nombre) de l\u2019exposant, on ajoute un d\u00e9calage de \\(d=2^{E\u22121}\u22121\\)</li> <li>Avec E = 8, d = 127. L\u2019exposant est dans l\u2019intervalle [-127\u00a0; 128], donc l\u2019exposant d\u00e9cal\u00e9 est dans [0, 255]\u00a0; 0 et 255 ayant une signification sp\u00e9ciale.</li> </ul> <p>Ils sont longs de 4 octets (32 bits)\u00a0: (1, 8, 23)</p> <p>La mantisse compl\u00e8te, le significande, doit \u00eatre consid\u00e9r\u00e9e comme une valeur sur 24 bits. Si la mantisse avec bit 1 implicite est 101000\u2026 alors le significande en base 2 est 1. 101000</p> <p>La quantit\u00e9 de nombres repr\u00e9sentables au format (1, E, M) est grande mais pas infinie (mince). L\u2019ordinateur travaille donc avec des valeurs en g\u00e9n\u00e9ral approch\u00e9es\u00a0:</p> <p>Avec floatx=0,1, l\u2019ordinateur travaille en interne avec \\(00111101110011001100110011001101\u2082\\) c\u2019est \u00e0 dire \\(0.100000001490116_{10}\\) qui est \u00e9gal \u00e0 \\(\\frac{13421773}{134217728}\\)</p>"},{"location":"Nombres/Nombres%20flottants/#format-1em","title":"Format (1,E,M)","text":"<p>En fonction de la valeur du champ exposant d\u00e9cal\u00e9, certains nombres peuvent avoir une signification sp\u00e9ciale (Nombre d\u00e9normalis\u00e9, Z\u00e9ro, Infini, NaN). L\u2019exposant est d\u00e9cal\u00e9 dans\\(\u27e60,2^E\u22121\u27e7\\)donc le d\u00e9calage est de \\(2^{E\u22121}\u22121\\). Le bit implicite de la mantisse est d\u00e9termin\u00e9 par la valeur de l\u2019exposant d\u00e9cal\u00e9.</p> <p>Si l\u2019exposant d\u00e9cal\u00e9 est diff\u00e9rent de 0 et de \\(2^E\u22121\\), le bit implicite est 1, et le nombre est dit normalis\u00e9. Si l\u2019exposant d\u00e9cal\u00e9 est nul, par convention, le bit implicite vaut 0. Le nombre est dit d\u00e9normalis\u00e9. La repr\u00e9sentation au format d\u00e9normalis\u00e9 est destin\u00e9e aux tr\u00e8s petites quantit\u00e9s en valeur absolue.</p> <p>La quantit\u00e9 de nombre \u00e0 virgules flottante sur une machine et grande mais finie. Chaque nombre positif (sauf le plus grand et plus petit) \u00e0 un successeur et un pr\u00e9d\u00e9cesseur positif</p> <p>Le successeur du nombre d\u00e9normalis\u00e9 positif le plus grand est le plus petit nombre normalis\u00e9 positif. Z\u00e9ro n\u2019est ni normalis\u00e9 ni d\u00e9normalis\u00e9. Il y a deux \u00e9critures +0 et -0</p> <p>Un nombre d\u00e9normalis\u00e9 \u00e0 une mantisse non nulle, un champ exposant d\u00e9cal\u00e9\u00a0: E bits \u00e0 0. Tous les nombres d\u00e9normalis\u00e9s ont le m\u00eame exposant. Par convention, l\u2019exposant pour les nombres d\u00e9normalis\u00e9s est en fait \u00e9gal au plus petit exposant de nombre normalis\u00e9 soit \\(\u22122^{E\u22121}+1+1\\). Ce qui change c\u2019est le bit implicite 0 (d\u00e9normalis\u00e9) ou 1 (normalis\u00e9)</p>"},{"location":"Nombres/Nombres%20flottants/#recap","title":"R\u00e9cap","text":"Type Exposant d\u00e9cal\u00e9 Mantisse Z\u00e9ros\u00a0: +-0 0 0 Nombres d\u00e9normalis\u00e9s 0 Diff\u00e9rente de 0, 0. implicite Nombres normalis\u00e9s 1 \u00e0 \\(2^E\u20132\\) Quelconque, 1. implicite Infinis +- infinity \\(2^E\u20131\\) 0 NaN \\(2^E\u20131\\) Diff\u00e9rente de 0 <p>L\u2019exposant e d\u2019un nombre normalis\u00e9\u00a0: e\u2208[\u2212126,127]. L\u2019exposant -127 (qui est d\u00e9cal\u00e9 vers la valeur 0) est r\u00e9serv\u00e9 pour z\u00e9ro et les nombres d\u00e9normalis\u00e9s, tandis que l\u2019exposant 128 (d\u00e9cal\u00e9 vers 255) est r\u00e9serv\u00e9 pour coder les infinis et les NaN</p>"},{"location":"Nombres/Nombres%20flottants/#des-reels-aux-flottants","title":"Des r\u00e9els aux flottants","text":""},{"location":"Nombres/Nombres%20flottants/#cas-des-nombres-normalises","title":"Cas des nombres normalis\u00e9s","text":"<p>On calcule (s, e, m) en base 10</p> <ul> <li>Ecriture de 0\u00a0: 32 bits \u00e0 0 ou un bit \u00e0 1 suivi de 31 bits nuls</li> <li>Ecriture sous forme scientifique au standard d\u00e9cimal\u00a0: Si \\(X\u22600\\), \\(X=(\u22121)^s\u00d72^e\u00d7(1+m)\\) avec s=0 ou s=1, \\(e\u2208\u2124\\) et \\(m\u2208[0, 1[\\)</li> </ul>"},{"location":"Nombres/Nombres%20flottants/#trouver-s","title":"Trouver s","text":"<p>0 si X est positif ou nul, 1 sinon</p>"},{"location":"Nombres/Nombres%20flottants/#trouver-e","title":"Trouver e","text":"<ul> <li>Si |X| \u2265 2, diviser par 2 la valeur absolue de X autant de fois que n\u00e9cessaire jusqu\u2019\u00e0 obtenir un entier de l\u2019intervalle [1, 2[.   e est donc le nombre de divisions faites</li> <li>Si |X| &lt; 1, multiplier par 2 la valeur absolue de X autant de fois que n\u00e9cessaire jusqu\u2019\u00e0 obtenir un entier de l\u2019intervalle [1, 2[.   e est donc l\u2019oppos\u00e9 du nombre de multiplication (on met un \u2013 devant le nombre de multiplication)</li> <li>Si 2&gt;|X|&gt;=1 alors e = 0</li> </ul>"},{"location":"Nombres/Nombres%20flottants/#trouver-m","title":"Trouver m","text":"<p>Si on conna\u00eet X, s et e alors il est facile de trouver m\u00a0:</p> <p>\\(m=\\frac{(\u22121)^s}{2^e}X\u22121\\)</p> <p>Exemple</p> <p><p></p></p> <p>Si c\u2019est infini, on calcule encore 3 fois la multiplication, on regarde si on est plus proche de 0,2 (dans notre cas), donc on ajoute 1 au bit de poids faible (le 23e) et on tient compte des retenues</p> <p><p></p></p> <p>Dans cet exemple, on pousse le calcul des d\u00e9cimales jusqu\u2019au 27eme bit et on peut d\u00e9terminer sans erreur quel est l\u2019arrondi au plus proche de la matrice. Le cas ou les 3 bits suppl\u00e9mentaires s\u2019\u00e9crivent 100 alors on utilise la r\u00e8gle dite de l\u2019arrondi au plus proche pair.</p>"},{"location":"Nombres/Nombres%20flottants/#des-flottants-aux-reels","title":"Des flottants aux r\u00e9els","text":"<p>On prend le flottant 0100 0000 1011 1000 0000 0000 0000\u2082, \u00e0 quel r\u00e9el correspond-t-il\u00a0?</p> <p></p> <p>Le signe est 0, le nombre est donc positif, le champ d\u2019exposant d\u00e9cal\u00e9 est \\(10000001_2\\) soit \\(129_{10}\\) donc la valeur de l\u2019exposant est 2(=129\u2212127). Le significande (avec le bit implicite) est donc \\(1.0111000000000000000000_2\\). En convertissant\u00a0: =\\(5,75_{10}\\)</p> <p>En g\u00e9n\u00e9ral, partant d\u2019un flottant simple pr\u00e9cision normalis\u00e9\u00a0:</p> <ul> <li>L\u2019\u00e9crire en binaire et retrouver chaque champs</li> <li>Signe de s\u00a0: bit de poids fort</li> <li>Convertir le binaire du champs exposant en un entier e, lui retrancher le d\u00e9calage \\(d=127(2^{8\u22121}\u22121)\\)</li> <li>Partie d\u00e9cimale m (indiqu\u00e9 par la mantisse \\(b_1b_2...b_{22}b_{23}\\))</li> </ul> \\[m=\\sum_{i=0}^{22}b_i2^{-i} = b_1\u00d72^{-1}+b_2\u00d72^{-2}+...+b_{22}\u00d72^{-22}+b_{23}\u00d72^{-23}\\] <ul> <li>Le nombre r\u00e9el correspondant est \\((\u22121)^s(1+m)2^{e\u2212127}\\) avec 1 le bit implicite</li> </ul>"},{"location":"Ocaml/Arguments%20en%20ligne%20de%20commande/","title":"Arguments en ligne de commande","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"Ocaml/Arguments%20en%20ligne%20de%20commande/#arguments-en-ligne-de-commande_1","title":"Arguments en ligne de commande","text":"<p>Comme en C ou en Python les arguments qui sont pass\u00e9s en ligne de commande d\u2019un programme OCaml sont stock\u00e9s dans un tableau. Il est traditionnel de nommer ce tableau argv. </p> <p>On le trouve dans le module Sys de la biblioth\u00e8que standard. Son nom complet est donc <code>Sys.argv</code>. Le nombre d\u2019arguments (parmi lesquels le nom du programme en position 0) est la longueur du tableau.</p> <p>On verra plus tard comment travailler avec les tableaux en OCaml. Retenons simplement qu\u2019on acc\u00e8de \u00e0 la case \\(i\\) du tableau <code>tab</code> par <code>tab[i]</code>. Dans un fichier arg.ml, entrer :</p> <pre><code>let boucle tab =\n    let n = Array.length tab in \n    let rec aux i = match i with\n        | x when x=n -&gt; ()\n        | _ -&gt; Printf.printf \"[%d] %s\\n\" i tab.(i);\n            aux (i+1)\n    in aux 0\n\nboucle Sys.argv\n</code></pre> <p>Ce programme affiche la liste des arguments et leurs positions dans <code>Sys.argv</code>. Compiler, le programme</p> <pre><code>$ ocamlopt \u2212o args args.ml\n</code></pre> <p>Dans un terminal, la commande <code>./args arg1 arg2 arg3</code> produit l\u2019affichage : <pre><code>[0] ./args\n[1] arg1\n[2] arg2\n[3] arg3\n</code></pre></p>"},{"location":"Ocaml/Entr%C3%A9es-Sorties/","title":"Entr\u00e9es-sorties en OCAML","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"Ocaml/Entr%C3%A9es-Sorties/#definition","title":"D\u00e9finition","text":"<p>D\u00e9finition</p> <p>Les fonctions d\u2019entr\u00e9es sorties calculent une valeur (parfois de type <code>unit</code>) et modifient l\u2019\u00e9tat des p\u00e9riph\u00e9riques d\u2019entr\u00e9es-sorties : - modification du buffer du clavier, - affichage \u00e0 l\u2019\u00e9cran, - \u00e9criture dans un fichier - ou modification du pointeur de lecture.</p> <p>Deux types pr\u00e9d\u00e9finis <code>in_channel</code> et <code>out_channel</code> d\u00e9crivent les canaux de communication d\u2019entr\u00e9e et de sortie.</p>"},{"location":"Ocaml/Entr%C3%A9es-Sorties/#ouverture-en-lecture","title":"Ouverture en lecture","text":"<p>Dans un fichier essai.txt du r\u00e9pertoire courant, \u00e9crivons trois lignes : <pre><code>    un\n    deux\n    trois et quatre\n</code></pre> sans retour chariot apr\u00e8s <code>quatre</code> .</p> <p>La fonction <code>open_in</code> de type <code>string -&gt; in channel</code> permet d\u2019ouvrir un fichier en lecture \u00e0 partir de son chemin d\u2019acc\u00e8s (ou son nom si le fichier \u00e0 ouvrir est dans le r\u00e9pertoire courant).</p> <p>Elle ouvre un canal de communication (un flot) avec le fichier s\u2019il existe et d\u00e9clenche une exception <code>Sys_error</code> sinon (notamment si le fichier n\u2019existe pas).</p> <p>Notre fichier est ouvert avec l\u2019instruction</p> <pre><code>let ic = open_in \"essai.txt\" ;; \n(* cr\u00e9ation d'un canal de com. vers essais.txt *)\n</code></pre> <p>On acc\u00e8de aux lignes du fichier gr\u00e2ce \u00e0 la fonction</p> <pre><code>input_line ;;\n- : in_channel -&gt; string = &lt;fun&gt;\n</code></pre> <p>Ci-dessous, nous lisons et affichons la premi\u00e8re ligne du fichier :</p> <pre><code>let s = input_line ic in Printf.printf \"%s\\n\" s ;;\nun\n- : unit = ()\n</code></pre> <p>Lisons donc les deux autres lignes :</p> <pre><code># let s = input_line ic in Printf . printf \" %s\\n\" s ;;\ndeux\n- : unit = ()\n# let s = input_line ic in Printf . printf \" %s\\n\" s ;;\ntrois et quatre\n- : unit = ()\n</code></pre> <p>Si on essaye de lire une nouvelle ligne, on se doute bien qu\u2019on va au devant d\u2019un probl\u00e8me : une exception <code>End_of_file</code> sera soulev\u00e9e. Ne tentons pas le diable et fermons le canal de communication <code>ic</code>:</p> <pre><code># close_in ic ;;\n- : unit = ()\n</code></pre> <p>Le canal <code>ic</code> est ferm\u00e9. Toute tentative de lire une ligne de essai.txt se solde par une exception <code>Sys_error \"Bad file descriptor\"</code>.</p> <p>En r\u00e9sum\u00e9, pour lire et afficher toutes les lignes d\u2019un fichier et le fermer proprement, il suffit de rentrer dans une boucle infinie qui affiche les lignes une \u00e0 une et de r\u00e9cup\u00e9rer l\u2019exception End of file qui finira par arriver. On ferme alors le canal.</p> <pre><code>let ic = open_in \" test1.txt\" in\nlet rec lire () =\nlet s = input_line ic in Printf . printf \"%s\\n\" s ;\n    lire () ;\nin\ntry\n    lire () ;\nwith End_of_file -&gt; close_in ic ;;\n</code></pre> <p>Apr\u00e8s compilation et ex\u00e9cution, le contenu du fichier test1.txt s\u2019affiche (s\u2019il existe).</p>"},{"location":"Ocaml/Entr%C3%A9es-Sorties/#ouverture-en-ecriture","title":"Ouverture en \u00e9criture","text":"<p>Quand on ouvre un canal de communication en \u00e9criture, le fichier correspondant est ouvert s\u2019il existe ou cr\u00e9\u00e9 s\u2019il n\u2019existe pas.</p> <p>La fonction <code>open_out</code> permet d\u2019ouvrir le fichier en mode \u00e9criture \"avec \u00e9crasement\". La fonction <code>close_out</code> referme le canal.</p> <pre><code>let oc = open_out \"sortie.txt\" in close_out oc ;;\n</code></pre> <p>Nous avons juste ouvert puis referm\u00e9 le fichier mais il a bien \u00e9t\u00e9 cr\u00e9\u00e9. </p> <p>L'ex\u00e9cution de <code>ls sort*</code> renvoie dans le terminal:</p> <pre><code>sortie.txt\n</code></pre> <p>La fonction <code>output_string</code> permet d\u2019\u00e9crire une cha\u0131\u0302ne de caract\u00e8re dans le fichier :</p> <pre><code># let oc = open_out \"sortie.txt\" in\noutput_string oc \"un\" ;\noutput_string oc \"deux\" ;\noutput_string oc \"trois\" ;\nclose_out oc ;;\n- : unit = ()\n</code></pre> <p>Attention, aucun saut de ligne n\u2019a \u00e9t\u00e9 ins\u00e9r\u00e9, il ne faut donc pas oublier les <code>\\n</code> si on veut passer \u00e0 la ligne :</p> <p>L'ex\u00e9cution de <code>cat sortie.txt</code> renvoie dans le terminal :</p> <pre><code>undeuxtrois\n</code></pre> <p>Plus proche de ce que nous connaissons est la fonction <code>Printf.fprintf</code> qui reconna\u0131\u0302t les sp\u00e9cifieurs de format :</p> <pre><code>let oc = open_out \"sortie.txt\" in\nPrintf.fprintf oc \"%f\\n\" 3.45;\nPrintf.fprintf oc \"%d\\n\" 26;\nPrintf.fprintf oc \"%s\\n\" \"fini\" ;\nclose_out oc ;;\n</code></pre> <p>L'ex\u00e9cution de <code>cat sortie.txt</code> renvoie alors dans le terminal :</p> <pre><code>3.450000\n26\nfini\n3\n</code></pre>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/","title":"Imp\u00e9ratif et types","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> Sommaire <ul> <li>Tableaux, r\u00e9f\u00e9rences, boucles</li> <li>Exceptions</li> <li> <p>Types personnalis\u00e9s</p> <ul> <li>Type enregistrement</li> <li>Type somme</li> </ul> </li> <li> <p>Astuce : le type option </p> </li> </ul> <p>Cr\u00e9dits</p> <p>Develooppez.com \u03bb OCaml Programming FAQ Caml  </p>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#tableaux-references-boucles","title":"Tableaux, r\u00e9f\u00e9rences, boucles","text":""},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#tableaux","title":"Tableaux","text":"<p>D\u00e9claration d\u2019un tableau :  </p> <pre><code>let tab = [|3;6;8|];; (* \u00e0 la main *)\n\nlet tab = Array.make 5 0;; (* un tableau de 5 z\u00e9ros *)\n\n(* Cr\u00e9er une matrice \u00e0 la main *)\nlet mat = let p = Array.make 3 [||] in\n    p.(0)&lt;-[|1;2|]; p.(1) &lt;-[|0;9|]; p.(2)&lt;-[|-1;1|]; p;;\n\n(* utiliser une fonction de biblioth\u00e8que *)\nArray.make_matrix 3 2 0;;\n</code></pre>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#acces-aux-elements","title":"Acc\u00e8s aux \u00e9l\u00e9ments","text":"<pre><code># let tab = [|3;6;8|] in\ntab.(0)&lt;-10;\nPrintf.printf \"tab.(%d)=%d\\n\" 0 tab.(0);;\n    tab.(0) =10\n- : unit = ()\n# let mat = Array.make_matrix 3 2 0 in\nmat.(2).(1)&lt;- -4; mat ;;\n- : int array array = [|[|0; 0|]; [|0; 0|]; [|0; -4|]|]\n</code></pre>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#parcours-dun-tableau-longueur-boucle-for","title":"Parcours d\u2019un tableau, longueur, boucle for","text":"<pre><code># let tab = [|3;6;8|];;\nval tab : int array = [|3; 6; 8|]\n# let n = Array.length tab in\n  for i = 0 to (n-1) do\n    Printf.printf \" tab.(%d)=%d; \" i tab.(i) ;\n  done ;;\n    tab.(0)=3; tab.(1)=6; tab.(2)=8; - : unit = ()\n\n# let n = Array.length tab in\n  for i = n -1 downto 0 do\n    Printf.printf \"tab.(%d)=%d; \" i tab.(i) ;\n  done ;;\n  tab.(2)=8; tab.(1)=6; tab.(0)=3; - : unit = ()\n</code></pre>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#references","title":"R\u00e9f\u00e9rences","text":"<p>Une r\u00e9f\u00e9rence est un pointeur vers un objet. Cela permet de rendre des  variables mutables.</p> <pre><code># let n = ref 0;;\nval n : int ref = {contents = 0}\n# n := !n+3;;\n- : unit = ()\n# Printf.printf \"!n = %d\\n\" !n ;;\n!n = 3\n- : unit = ()\n</code></pre>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#egalites","title":"Egalit\u00e9s","text":"<p><code>==</code> : \u00e9galit\u00e9 physique. <pre><code># [1] == [1];;\n- : bool = false \n</code></pre></p> <p>Les deux listes ne sont pas au m\u00eame endroit de la m\u00e9moire.</p> <p><code>=</code> : \u00e9galit\u00e9 physique. <pre><code># [1] = [1];;\n- : bool = true \n</code></pre></p> <p>Les deux listes \"s'\u00e9rivent pareillement\".</p> <p><code>!=</code> : diff\u00e9rence physique. <pre><code># [1] != [1];;\n- : bool = true \n</code></pre></p> <p><code>&lt;&gt;</code> : diff\u00e9rence syntaxique. <pre><code># [1] &lt;&gt; [1];;\n- : bool = false \n</code></pre></p>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#boucle-while","title":"Boucle while","text":"<pre><code># let i = ref 0 and s = ref 0 in\nwhile !i&lt;10 do\n    s := ! s + ! i ;\n    incr i ;\ndone ;\nPrintf.printf \"!s = %d\\n\" !s ;;\n!s = 45\n- : unit = ()\n</code></pre> <p>Noter le <code>incr i</code> qui incr\u00e9mente de 1 la valeur point\u00e9e par i .  Il existe aussi un <code>decr i</code>.</p>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#exceptions","title":"Exceptions","text":""},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#presentation","title":"Pr\u00e9sentation","text":"<ul> <li>En programmation fonctionnelle, les fonctions sont totales,  c\u2019est-\u00e0-dire qu\u2019elles sont applicables \u00e0 tout argument qui appartient \u00e0  leur type de d\u00e9part.  </li> <li>Il faut donc \u00eatre capable de traiter les cas, appel\u00e9s exceptions, o\u00f9 cet argument n\u2019est pas acceptable. Par exemple : une division par z\u00e9ro ou  bien la recherche de la t\u00eate d\u2019une liste vide.  </li> <li>Ceci peut \u00eatre fait par des tests pr\u00e9ventifs plac\u00e9s dans le corps des  fonctions, mais ce m\u00e9canisme est tr\u00e8s lourd, car il implique un travail  important pour le programmeur et il alt\u00e8re la lisibilit\u00e9 d\u2019un  programme en masquant son fonctionnement normal.  </li> <li>C\u2019est pourquoi les langages de programmation modernes comportent  un m\u00e9canisme sp\u00e9cifique pour le traitement des exceptions.  </li> </ul>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#exceptions-predefinies","title":"Exceptions pr\u00e9d\u00e9finies","text":"<p>Les exceptions ont le type <code>exn</code>. On les soul\u00e8ve avec la commande <code>raise</code>.</p> <ul> <li>Une exception qui porte bien son nom :  </li> </ul> <pre><code># Exit ;;\n- : exn = Pervasives.Exit\n# raise Exit ;;\nException : Pervasives.Exit.\n</code></pre> <ul> <li>Une qu\u2019on conna\u00eet bien</li> </ul> <pre><code># failwith \" big pb ! \" ;;\nException : Failure \" big pb ! \".\n</code></pre> <p>Observons que l\u2019invocation de <code>failwith</code> d\u00e9clenche le <code>raise</code>.</p> <ul> <li>Une exception au sens compr\u00e9hensible  </li> </ul> <pre><code># 1/0;;\nException : Division_by_zero.\n</code></pre> <p>C\u2019est l\u2019\u00e9valuateur de OCaml qui d\u00e9clenche cette exception.  </p> <ul> <li>Une autre qui rappelle le C ou encore Python.</li> </ul> <pre><code># let l = [3] in assert (List.mem 2 l);;\nException : Assert_failure(\"//toplevel//\", 1, 15).\n</code></pre>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#declarer-une-exception","title":"D\u00e9clarer une exception","text":"<pre><code># exception MyException ;;\nexception MyException\n# MyException ;;\n- : exn = MyException\n# raise MyException ;;\nException : MyException.\n# exception MyException2 of string ;;\nexception MyException2 of string\n# raise (MyException2 \"big pb\") ;;\nException : MyException2 \"big pb\".\n# exception MyException2 of string ;;\nexception MyException2 of string\n# let f = function x -&gt;\n    if x &lt;&gt; 0 then\n        365 / x\n    else\n        raise (MyException2 \" Division par z\u00e9ro \") ;;\n            val f : int -&gt; int = &lt;fun&gt;\n# f 3;;\n- : int = 121\n# f 0;;\nException : MyException2 \" Division par z\u00e9ro \".\n</code></pre>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#recuperation-dune-exception","title":"R\u00e9cup\u00e9ration d\u2019une exception","text":"<p>La r\u00e9cup\u00e9ration d\u2019une exception d\u00e9clench\u00e9e lors de l\u2019\u00e9valuation d\u2019une  expression <code>e</code> peut \u00eatre r\u00e9alis\u00e9e en encapsulant cette expression dans une  expression <code>try..with</code>.Voici la syntaxe \u00e0 utiliser :</p> <pre><code>try expr with\n| p1 -&gt; e1 (* si le type d'exception est p1 , renvoyer e1 *)\n|...\n| pn -&gt; en (* si le type d\u2019exception est pn , renvoyer en *)\n</code></pre> <p>Dans l\u2019exemple suivant, on met la t\u00eate de la liste <code>l2</code> dans <code>l1</code> et, si une  exception de type <code>Failure</code> est soulev\u00e9e, on renvoie la liste vide :  </p> <pre><code># let ajouter l1 l2 =\n    try List.hd l2::l1 with Failure _ -&gt; [];;\n    val ajouter : \u2019a list -&gt; \u2019a list -&gt; \u2019a list = &lt;fun&gt;\n# ajouter [2] [3;4];;\n- : int list = [3; 2]\n# ajouter [2] [];;\n- : int list = []\n</code></pre>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#types-personnalises","title":"Types personnalis\u00e9s","text":""},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#type-enregistrement","title":"Type enregistrement","text":""},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#presentation_1","title":"Pr\u00e9sentation","text":"<p>L\u2019id\u00e9e est celle des <code>struct</code> de C. On acc\u00e8de aux champs avec la notation  point\u00e9e; on les modifie avec la notation \ufb02\u00e9ch\u00e9e des tableaux.</p> <pre><code># type complex = {x : float ; y : float};;\ntype complex = {x : float ; y : float ;}\n# let i = {x=1.; y=1.};;\nval i : complex = {x = 1.; y = 1.}\n# i.x , i.y ;;\n- : float * float = (1., 1.)\n# i.x=4.;;\n- : bool = false\n# i.x&lt;-4.;;\nCharacters 0-7:\ni.x&lt;-4.;;\n^^^^^^^\nError : The record field x is not mutable\n</code></pre>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#champs-mutables","title":"Champs mutables","text":"<p>Il peut \u00eate souhaitable de modifier certains champs. Il faut les d\u00e9clarer comme mutable. Par d\u00e9faut, un champ est persistant.  </p> <pre><code># type complex = {mutable x : float ; y : float};;\ntype complex = {mutable x : float ; y : float ;}\n# let i = {x =1.; y =1.};;\nval i : complex = {x = 1.; y = 1.}\n# i.x , i.y ;;\n- : float * float = (1. , 1.)\n# i.x=4.;;\n- : bool = false\n# i.x&lt;-4.;;\n- : unit = ()\n# i.y&lt;-1.;;\nCharacters 0-7:\n    i.y&lt;-1.;;\n    ^^^^^^^\nError : The record field y is not mutable\n</code></pre>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#polymorphisme","title":"Polymorphisme","text":"<p>Dnas l'exemple ci-dessous, on d\u00e9clare une structure \u00e0 deux champs <code>x,y</code> dont les types ne sont pas connus au d\u00e9part. Le premier est dun certain type <code>'a</code> qui sera connu \u00e0 l'initialisation, de m\u00eame le second est d'un type <code>'b</code>.</p> <pre><code># type (\u2019a , \u2019b) fourre_tout = {x : \u2019a ; y : \u2019b};;\ntype (\u2019a , \u2019b) fourre_tout = { x : \u2019a ; y : \u2019b }\n# let z = {x=2; y = \"toto\"};;\nval z : (int, string) fourre_tout = {x = 2; y = \"toto\"}\n</code></pre>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#type-somme","title":"Type somme","text":""},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#presentation_2","title":"Pr\u00e9sentation","text":"<ul> <li>Un type somme est form\u00e9 d\u2019une liste de cas possibles pour une valeur  de ce type, chaque cas comporte un nom de cas, le \"constructeur\",  et une (\u00e9ventuelle) valeur associ\u00e9 (l\u2019argument du constructeur).</li> <li>Un cas d\u00e9g\u00e9n\u00e9r\u00e9 consiste \u00e0 d\u00e9finir un type dont les constructeurs  n\u2019ont pas d\u2019argument (constructeurs constants). On parle alors de type \u00e9num\u00e9r\u00e9 (le symbole <code>|</code> se lit \"ou\")  </li> </ul> <pre><code># type couleur = Bleu | Blanc | Rouge ;;\ntype couleur = Bleu | Blanc | Rouge\n# Bleu ;;\n- : couleur = Bleu\n# let fleur c = match c with\n    | Bleu -&gt; \" bleuet \"\n    | Blanc -&gt; \" marguerite \"\n    | Rouge -&gt; \" coquelicot \"\nin fleur Rouge ;;\n- : string = \" coquelicot \"\n</code></pre>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#type-somme_1","title":"Type somme","text":"<p>On peut passer des param\u00e8tres aux constructeurs.  </p> <ul> <li>Ci-dessous on d\u00e9finit un type pour les piles d\u2019entiers. Une pile non  vide poss\u00e9de deux \u00e9l\u00e9ments : une \u00e9tiquette enti\u00e8re et une pile (vide  \u00e9ventuellement). On \u00e9crit une fonction qui fait la somme du contenu  de la liste :  </li> </ul> <pre><code># type stack_of_int = Vide | P of int * stack_of_int;;\ntype stack_of_int = Vide | P of int * stack_of_int\n# let rec somme p = match p with\n    | Vide -&gt; 0\n    | P (x , q) -&gt; x + somme q ;;\n        val somme : stack_of_int -&gt; int = &lt;fun&gt;\n</code></pre> <ul> <li>On cr\u00e9e ensuite une pile dont le sommet est 3, l\u2019\u00e9l\u00e9ment interm\u00e9diaire  2 et la base 1. On lui applique la fonction <code>somme</code> :  </li> </ul> <pre><code># let p = P (3 , P (2 , P (1 , Vide))) ;;\nval p : stack_of_int = P (3 , P (2 , P (1 , Vide)))\n# somme p ;;\n- : int = 6\n</code></pre>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#type-somme-polymorphe","title":"Type somme polymorphe","text":"<p>Ci-dessous on d\u00e9finit un type pour les piles polymorphes. On \u00e9crit une  fonction qui prend en param\u00e8tre une pile, une addition adapt\u00e9e et une valeur de d\u00e9part.  </p> <pre><code># type \u2019a stack = Vide | P of \u2019a * \u2019a stack;;\ntype \u2019a stack = Vide | P of \u2019a * \u2019a stack\n# let rec somme_polymorphe p add start = match p with\n    | Vide -&gt; start\n    | P (x , q) -&gt; add x (somme_polymorphe q add start) ;;\n        val somme_polymorphe : \u2019a stack -&gt; (\u2019a -&gt; \u2019b -&gt; \u2019b)\n            -&gt; \u2019b -&gt; \u2019b = &lt;fun&gt;\n</code></pre> <p>On cr\u00e9e ensuite une pile de \ufb02ottant. On lui applique la fonction  <code>somme_polymorphe</code> \u00e0 laquelle on passe l\u2019addition des \ufb02ottants <code>(+.)</code> et le point de d\u00e9part <code>0.</code> :  </p> <pre><code># let p = P (0.3 , P (0.2 , P (0.1 , Vide))) ;;\nval p : float stack = P (0.3 , P (0.2 , P (0.1 , Vide)))\n# somme_polymorphe p (+.) 0.;;\n- : float = 0.600000000000000089\n</code></pre>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#astuce-le-type-option","title":"Astuce : le type option","text":""},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#utilite-du-type-option","title":"Utilit\u00e9 du type option","text":"<p>Nous voulons \u00e9crire une fonction qui retourne en g\u00e9n\u00e9ral une valeur  mais, parfois, ne retourne rien.  </p> <p>Par exemple, la fonction <code>list_max</code> renvoie le maximum d\u2019une liste si  elle n\u2019est pas vide. Mais on ne sait trop quoi faire avec la liste vide :</p> <pre><code>let rec list_max = function\n    | [] -&gt; ???\n    | h :: t -&gt; max h (list_max t)\n</code></pre> <p>Pour la liste vide, on peut :</p> <ul> <li>renvoyer une <code>min_int</code> ? mais le code ne fonctionnerait qu\u2019avec une  liste d\u2019entiers</li> <li>Soulever une exception ? mais il faudra que l\u2019utilisateur se souvienne  d\u2019encapsuler ses appels dans un <code>try..with</code> </li> <li>Renvoyer <code>NULL</code> ? mais cette notion existe en C pas en OCaml  </li> </ul> <p>La meilleure solution est d\u2019employer le type <code>option</code>.</p>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#le-type-option","title":"Le type option","text":"<p>Le type <code>\u2019a option</code> poss\u00e8de deux constructeurs <code>Some</code> et <code>None</code>.</p> <p>Un \u00e9l\u00e9ment du type <code>option</code> peut \u00eatre vu comme une bo\u00eete qui est soit vide, soit contenant un objet d\u2019un certain type.  </p> <pre><code># None ;;\n- : \u2019a option = None\n# Some 45;;\n- : int option = Some 45\n# Some \" toto \" ;;\n- : string option = Some \" toto \"\n</code></pre>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#type-option-acces-au-contenu","title":"Type option : Acc\u00e8s au contenu","text":"<p>On acc\u00e8de au contenu de la bo\u00eete par filtrage. Ci-dessous on \u00e9crit une fonction qui extrait un entier d\u2019une option (s\u2019il y en a un dedans) et le convertit en <code>string</code> :  </p> <pre><code># let extract o =\n    match o with\n    | Some i -&gt; string_of_int i\n    | None -&gt; \"\";;\n        val extract : int option -&gt; string = &lt;fun&gt;\n# extract (Some 42) ;;\n- : string = \"42\"\n# extract None ;;\n- : string = \"\"\n</code></pre>"},{"location":"Ocaml/Imp%C3%A9ratif%20et%20types/#maximum-dune-liste","title":"Maximum d\u2019une liste","text":"<p>On revient au programme de recherche du maximum. On ne renvoie rien (donc <code>None</code>) dans le cas o\u00f9 la liste est vide.</p> <pre><code># let rec list_max = function\n    | [] -&gt; None\n    | h :: t -&gt; begin\n        match list_max t with\n            | None -&gt; Some h\n            | Some m -&gt; Some (max h m)\n        end ;;\n                val list_max : \u2019a list -&gt; \u2019a option = &lt;fun&gt;\n# list_max [5;1;9;2];;\n- : int option = Some 9\n# list_max [];;\n- : \u2019a option = None\n</code></pre>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/","title":"OCaml","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> Sommaire <ul> <li> <p>G\u00e9n\u00e9ralit\u00e9s</p> <ul> <li>Compilation</li> <li>Boucle interractive</li> </ul> </li> <li> <p>Variable</p> </li> <li>Les types de base</li> <li>Expressions conditionnelles</li> <li>Fonction </li> <li>Filtrage sur les listes</li> </ul> <p>Cr\u00e9dits</p> <ul> <li>Ce cours de Olivier Pons </li> <li>Cette page de la documentation officielle et les remarques \u00e0 propos des parenth\u00e8ses. (Le vieux lien n'exsite plus donc \u00e7a vous renvoie sur la page principale d'OCaml)</li> <li>Cette introduction de Jean-Christophe Filliatre</li> <li>Quelques mots sur la compilation</li> </ul>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#generalites","title":"G\u00e9n\u00e9ralit\u00e9s","text":""},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#compilation","title":"Compilation","text":""},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#2-compilateurs-mp2i","title":"2 Compilateurs (MP2I)","text":"<p>Il y a deux compilateurs en OCaml:</p> <ul> <li><code>ocamlc</code> qui produit un bytecode ; un code compr\u00e9hensible par un interpr\u00e9teur appel\u00e9 <code>ocamlrun</code>. Avantages : simplicit\u00e9, portabilit\u00e9 et rapidit\u00e9 de compilation.</li> <li><code>ocamlopt</code> qui compile directement en langage machine (l'ex\u00e9cution sera alors plus rapide qu'avec l'intrepr\u00e9teur). Il accepte des fichiers de type <code>.ml</code> (fichiers de code) et <code>.mli</code> (fichiers d'interfaces). Il produit :</li> <li>Un fichier objet <code>.o</code> en langage machine ;</li> <li>Un fichier <code>.cmx</code> contenant des informations pour l'\u00e9dition de lien et l'optimisation des relations entre les divers modules.</li> <li>Un fichier d'interface <code>.cmi</code> qui contient les signatures des types export\u00e9s vers d'autres unit\u00e9s de compilation.</li> </ul>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#hello-world-mp2i","title":"Hello world (MP2I)","text":"<p>Dans un fichier <code>hello.ml</code> \u00e9crivons</p> <pre><code>print_string \"hello world\\n\"\n</code></pre> <p>Pas besoin de fonction <code>main()</code>. Pas besoin de parenth\u00e8se !</p> <p>Compilons et ex\u00e9cutons (dans un terminal)</p> <pre><code>ocamlopt  asup.ml \u2212o hello\n</code></pre> <p>Sans surprise, la commande <code>./toto</code> affiche</p> <pre><code>hello world\n</code></pre> <p>Listons les fichiers de pr\u00e9fixe <code>hello</code></p> <pre><code>$ls hello\u2217\nhello hello.cmi hello.cmx hello.ml hello.o\n</code></pre>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#commentaires","title":"Commentaires","text":"<p>Les commentaires en OCaml commencent par <code>(*</code> et finissent par <code>*)</code> .</p> <pre><code>(*on d\u00e9clare x et on teste si il est pair ou impair *)\nlet x = 3 in x mod 2;;\n(*On peut\nfaire des commentaires\nsur plusieurs lignes *)\n</code></pre>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#application-dune-fonction-a-ses-arguments","title":"Application d'une fonction \u00e0 ses arguments","text":"<p>En OCaml, l'application d'une fonction s'\u00e9crit par simple juxtaposition de la fonction et de son argument. \u00c0 la diff\u00e9rence de la plupart des langages o\u00f9 l'application de <code>f</code> \u00e0 <code>x</code> doit s'\u00e9crire <code>f(x)</code> , on se contente ici d'\u00e9crire <code>f x</code>.</p> <p>Remarque</p> <p>Rien n'interdit d'\u00e9crire <pre><code>print_string(\"hello world!\\n\")\n</code></pre></p> <p>Mais les parenth\u00e8ses autour de la cha\u00eene de caract\u00e8res sont tout simplement inutiles. Et c'est consid\u00e9r\u00e9 comme in\u00e9l\u00e9gant.</p> <p>En dehors des appels de fonctions, les parenth\u00e8ses peuvent et doivent \u00eatre utilis\u00e9es lorsque les priorit\u00e9s des op\u00e9rateurs l'exigent, comme dans l'expression <code>2*(1+3)</code> .</p>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#affichage-avec-printf","title":"Affichage avec <code>printf</code>","text":"<p>L'affichage en OCaml est un peu contraignant :</p> <ul> <li><code>print_string</code> pour les cha\u00eenes de caract\u00e8res,</li> <li><code>print_int</code> pour les entiers,</li> <li><code>print_float</code> pour les flottants...</li> </ul> <p>Heureusement, OCaml emprunte au C quelques habitudes comme la fonction <code>printf</code> du module <code>Printf</code>.</p> <pre><code># Printf.printf \"une cha^\u0131ne : %s, un entier : %d, un flottant %f\\n\" \"toto\" 45 32.3;;\n une cha\u00eene : toto , un entier : 45, un flottant 32.300000\n- : unit = ()\n</code></pre>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#boucle-interractive","title":"Boucle interractive","text":""},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#presentation","title":"Pr\u00e9sentation","text":"<p>Le plus souvent, nous ne compilerons pas les codes <code>.ml.</code></p> <p>Nous nous contenterons d'utiliser une boucle interractive. Il en existe plusieurs. Faisons un rapide tour d'horizon.</p>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#dans-un-terminal","title":"Dans un terminal","text":"<p>OCaml est un langage compil\u00e9. Cependa[]</p> <pre><code>print_string \"hello\\n\";;(*un commentaire*)\nhello\n- : unit = ()\n1+2;; (* ne pas oublier les deux points-virgules*)\n- : int = 3\n</code></pre> <p>Observons que le type des expressions est calcul\u00e9 (on dit inf\u00e9r\u00e9) et affich\u00e9. Ici, le type <code>unit</code> correspond au type <code>void</code> en C.</p> <p>On quitte la boucle interactive avec la commande <code>exit(0);;</code></p> <p>Le double point-virgule s\u00e9pare les diff\u00e9rentes d\u00e9calarations et expressions \u00e0 \u00e9valuer.</p>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#interpreteurs-en-ligne","title":"Interpr\u00e9teurs en ligne","text":"<p>Si on n'a pas encore install\u00e9 OCaml sur sa machine, on peut utiliser un interpr\u00e9teur en ligne :</p> <ul> <li>TryOCaml;</li> </ul> <p></p> <ul> <li>Better OCaml;</li> </ul> <p></p> <p>Raccourcis :</p> <ul> <li>Ctrl+Enter Ex\u00e9cute le code s\u00e9lectionn\u00e9</li> <li>Ctrl+Shif+Enter Ex\u00e9cute le code entier.</li> <li>Ctrl+Space montre le menu d'autocompl\u00e9tion</li> </ul>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#tuareg","title":"Tuareg","text":"<p>Pour ma part, j'utilise le greffon Tuareg d'emacs pour rendre plus agr\u00e9able l'utilisation de l'interpr\u00e9teur OCaml.</p> <p></p> <p>Consulter par exemple cette page.</p>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#variables","title":"Variables","text":"<p>Syntaxe <code>let &lt;id&gt; = &lt;expr&gt;</code>. Le plus souvent <code>&lt;id&gt;</code> est un identificateur (il commence par une lettre minuscule ou un underscore). La partie \u00e0 droite  de l'\u00e9galit\u00e9 est une expression (elle peut \u00eatre le r\u00e9sultat d'un calcul).</p> <p>Une d\u00e9claration affecte le r\u00e9sultat de l'\u00e9valuation d'une expression \u00e0 une varialble, et est introduite par le mot cl\u00e9 <code>let</code>. Par exemple \u00e9crivons ceci :</p> <pre><code>let x = 1 + 2;;\nprint_int x;;\nlet y = x * x;;\nprint_int y;;\n</code></pre> <p>Le programme calcule le r\u00e9sultat de <code>1+2</code>, l'affecte \u00e0 la variable <code>x</code>, affiche la valeur de <code>x</code>, puis calcule le carr\u00e9 de <code>x</code>, l'affecte \u00e0 la variable <code>y</code> et enfin affiche la valeur de <code>y</code>.</p> <p><code>x,y</code> sont des variables globales utilisables ailleurs dans le programme.</p>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#a-propos-des-variables","title":"\u00c0 propos des variables","text":"<p>Une variable est n\u00e9cessairement initialis\u00e9e.</p> <p>Le type de la variable n'a pas besoin d'\u00eatre d\u00e9clar\u00e9, il est inf\u00e9r\u00e9 par le compilateur.</p> <p>Le contenu de la variable n'est pas modifiable. Dans le code pr\u00e9c\u00e9dent, x contient 3 pour toute la dur\u00e9e du programme. La variable est immuable ou persistante (on est en paradigme fonctionnel).</p>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#variable-persistante-vraiment","title":"Variable persistante, vraiment ?","text":"<pre><code>let x =3;;\n val x : int = 3\nlet x = 4;; (*c'est une AUTRE variable x*)\n val x : int = 4\n</code></pre>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#variable-locale","title":"Variable locale","text":"<p>En C, les variables locales sont d\u00e9finies dans un bloc d\u00e9limit\u00e9 par des accolades et elles n'ont pas d'existence hors de ce bloc.</p> <pre><code>    {\n      int x = 10 ;\n      ...\n    }\n</code></pre> <p>En OCaml, il n'y a pas de notion de bloc. Les variables locales d'une expression sont introduites par la construction <code>let in</code> .</p> <pre><code>let x=10 in 2*x;;\n- : int = 20\n</code></pre> <p>Les variables locales sont immuables et obligatoirement initialis\u00e9es.</p> <p>Port\u00e9e de la variable <code>x</code> :</p> <pre><code>let x=10 in 2*x;;\n- : int = 20\nx;;\n Error: Unbound value x\n</code></pre> <p>Une d\u00e9claration locale est visible seulement dans l'expression qui suit le <code>in</code>.</p>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#les-types-de-base","title":"Les types de base","text":""},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#types-de-base","title":"Types de base","text":"<ul> <li>entiers (<code>int</code>), op\u00e9rateurs : <code>+ - * / mod</code></li> <li>flottants (<code>float</code>), op\u00e9rateurs : <code>+. -. *. /.</code></li> <li>caract\u00e8res (<code>char</code>), <code>'a','b','1' ...</code> avec une seule quote.</li> <li>cha\u00eenes, (<code>string</code>), <code>\"abc\", \"b\"</code> (double quotes), concat\u00e9nation :</li> </ul> <pre><code>\"toto\" ^ \" et gogo\";;\n- : string = \"toto et gogo\"\n</code></pre> <ul> <li>bool\u00e9ans, (<code>bool</code>), <code>true, false</code> ; op\u00e9rateurs : <code>&amp;&amp;, || , not</code></li> <li>Op\u00e9rateur de comparaison de valeurs pour tous les types <code>=, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;</code>. Polymorphes, mais les deux arguments doivent avoir le MEME type.</li> <li>Op\u00e9rateur de comparaison physique pour tous les types <code>==, !=</code></li> </ul> <p>Quelques op\u00e9rations</p> <pre><code>1+2;;\n- : int = 3\n1.5+.3.5;;\n- : float = 5.\n2&gt;7;;\n- : bool = false\n\"bonjour\" &gt; \"bon\";;\n- : bool = true\n\"durand\" &lt; \"martin\";;\n- : bool = true\n\"ab\" = \"ba\";;\n- : bool = false\n6 mod 2;;\n- : int = 0\n</code></pre>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#type-unit","title":"Type unit","text":"<p>Pour d\u00e9finir une fonction sans r\u00e9sultat, OCaml introduit le type <code>unit</code> qui ne contient qu'une seule valeur, not\u00e9e <code>()</code>.</p> <p>C'est par exemple le type de retour de la fonction <code>print_string</code>.</p> <p>Il sert aussi \u00e0 d\u00e9finir des fonctions sans argument.</p> <p>Il joue un r\u00f4le comparable au type <code>void</code> de C.</p>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#types-construits-predefinis","title":"Types construits pred\u00e9finis","text":"<p>Les tuples (<code>t1 * t2 * .. * tn</code>) o\u00f9 <code>ti</code> est le type de la composante \\(i\\) du n-uplet.</p> <pre><code>let x = false , 5, \"hello\";;\n val x : bool * int * string = (false , 5, \"hello\")\nlet a,b,c= x;; (* unpacking *);;\n val a : bool = false\n val b : int = 5\n val c : string = \"hello\"\n</code></pre> <p>Les listes <code>t_list</code> , o\u00f9 <code>t</code> est le type des \u00e9l\u00e9ments.</p> <pre><code>[1;2;3];; (* une liste d'entiers *)\n- : int list = [1; 2; 3]\n[\"a\";\"bc\"] @ [\"bonjour\"];; (*@: operateur de concatenation *)\n- : string list = [\"a\"; \"bc\"; \"bonjour\"]\n[1]@[];; (* []: liste vide *)\n- : int list = [1]\n</code></pre>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#plus-sur-les-listes","title":"Plus sur les listes","text":"<p>La liste vide est polymorphe. <pre><code>[];;(*la liste vide est polymorphe *)\n- : 'a list = []\n</code></pre></p> <p>Le module <code>List</code> contient des fonctions de manipulation de listes:</p> <pre><code>List.length [1;2;3];; (* En O(n) !!! *)\n- : int = 3\nList.hd [1;2;3];; (*t\u00eate (head) de la liste; O(1)*)\n- : int = 1\nList.tl [1;2;3];; (* queue (tail) de la liste; O(1)*)\n- : int list = [2; 3]\n3::[2;1];; (* ajouter un \u00e9l\u00e9ment en t\u00eate de liste *)\n- : int list = [3; 2; 1]\nlet a::b = [1;2;3];; (*s\u00e9parer la t\u00eate de la queue *)\n  ! Warning 8: this pattern -matching is not exhaustive !\n val a : int = 1\n val b : int list = [2; 3]\n</code></pre>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#plus-sur-les-tuples","title":"Plus sur les tuples","text":"<p>Cas d'un tuple de taille 2 :</p> <pre><code>let y = 1 ,6.2;;\n val y : int * float = (1, 6.2)\nfst y;; (*pour first y*)\n- : int = 1\nsnd y;; (*pour second y*)\n- : float = 6.2\n</code></pre> <p>Tuples contenant des tuples</p> <pre><code>let z= (y,(2. +. 1.,4));;\n val z : (int * float) * (float * int) = ((1, 6.2), (3., 4))\nlet a,b = z;;\n val a : int * float = (1, 6.2)\n val b : float * int = (3., 4)\nlet ((e,f),(g,h)) = z;;\n val e : int = 1\n val f : float = 6.2\n val g : float = 3.\n val h : int = 4 \n</code></pre> <p>D\u00e9construire un tuple en ne prenant que certains items.</p> <pre><code>let (_,(_,i)) = z;;\n val i : int = 4\n</code></pre> <p>Le symbole <code>_</code> indique la pr\u00e9sence d'une composante sans la nommer.</p> <p>Isomorphisme de types :</p> <ul> <li>Un \u00e9l\u00e9ment de type <code>int * int * int</code> est un triplet d'entier.</li> <li>Un \u00e9l\u00e9ment de type <code>int * (int * int)</code> est un couple dont le premier \u00e9l\u00e9ment est un entier et le second un couple d'entiers.</li> <li>Un \u00e9l\u00e9ment de type <code>(int * int) * int</code> est un couple dont le premier \u00e9l\u00e9ment est un couple d'entiers et le second un entier</li> <li>Les 3 ensembles des \u00e9l\u00e9ments appartenant \u00e0 chacun de ces 3 types sont en bijection canonique. C'est un exemple d'isomorphisme de types. Malheureusement, pour OCaml, ces types sont bien distincts !</li> </ul>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#expressions-conditionnelles","title":"Expressions conditionnelles","text":""},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#les-mots-cles-if-then-else","title":"Les mots cl\u00e9s <code>if</code> then <code>else</code>","text":"<p>En OCaml, il n'y a pas de distinction expression/instruction : il n'y a que des expressions.</p> <p>Les expressions conditionnelles sont d\u00e9finies \u00e0 l'aide de l'op\u00e9rateur ternaire <code>if e1 then e2 else e3</code>.</p> <p>L'expression <code>e1</code> doit renvoyer une valeur boul\u00e9enne.</p> <p>En g\u00e9n\u00e9ral (sauf cas particulier o\u00f9 <code>e2</code> est de type <code>unit</code>) la branche n\u00e9gative est obligatoire.</p> <p>Une expression conditionnelle est polymorphe : i.e. <code>e2</code> peut \u00eatre de n'importe quel type, mais <code>e3</code> est obligatoirement du m\u00eame type que <code>e2</code>.</p> <p><pre><code>let x = 42;;\n val x : int = 42\nlet v = 10 + (if x &gt; 0 then -1 else 4);;\n val v : int = 9\n</code></pre> Branche n\u00e9gative non obligatoire si type <code>unit</code> : <pre><code>if (3 mod 2 = 1) then print_string \"okayyyyy\";;\n okayyyyy - : unit = ()\n</code></pre></p>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#fonction","title":"Fonction","text":""},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#fonctions-anonymes","title":"Fonctions anonymes","text":"<p>Les fonctions en OCaml sont des valeurs comme les autres. Syntaxe : <code>fun &lt;id&gt; -&gt; &lt;expr&gt;</code>.</p> <ul> <li><code>&lt;id&gt;</code> d\u00e9signe le param\u00e8tre de la fonction. Il a une port\u00e9e localis\u00e9e au corps de la fonction.</li> <li><code>-&gt;</code> d\u00e9signe le d\u00e9but du corps de la fonction.</li> <li><code>&lt;expr&gt;</code> est une expression quelconque qui peut utiliser <code>&lt;id&gt;</code>.</li> </ul> <p>Fonction produit \\(x \u2192x \u00d7x\\) : <pre><code>fun x -&gt; x*x;;(* fonction anonyme *)\n- : int -&gt; int = &lt;fun&gt;\n(fun x -&gt; x*x) 5;;(* appliquer une fonction anonyme *)\n- : int = 25\n</code></pre></p> <p>Observer le type de la fonction. Il est not\u00e9 sous la forme \\(\u03c4_1 \u2192\u03c4_2\\).</p> <p>Inf\u00e9rence de type : comme on utilise l'op\u00e9rateur <code>*</code> , OCaml en d\u00e9duit que le type de la fonction est <code>int -&gt; int</code> .</p> <p>Pour nommer une fonction : <pre><code>let f = fun x y -&gt; x +. y;; (*d\u00e9clarer f*)\n val f : float -&gt; float -&gt; float = &lt;fun&gt;\nf 1. 2.;; (* utiliser f*)\n - : float = 3.\n</code></pre></p>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#sucre-syntaxique-forcer-le-type-du-parametre","title":"Sucre syntaxique ; Forcer le type du param\u00e8tre","text":"<p>OCaml permet de d\u00e9clarer une fonction de fa\u00e7on plus concise que <code>let f = fun ...</code> .</p> <pre><code>let f x y = x +. y;;\n(*\u00e9quivalent \u00e0 let f = fun x y -&gt; x+.y*)\nf 1. 2.;;\n</code></pre> <p>On peut indiquer le type du param\u00e8tre et celui de retour :</p> <pre><code>let f (x:int) : int = x+x;;\n</code></pre> <p>C'est ici surtout utile pour le lecteur.</p> <p>Attention aux priorit\u00e9s (penser aux parenth\u00e8ses) :</p> <pre><code>f 3 + 5, (f 3) + 5, f (3+5);;\n- : int * int * int = (11, 11, 16)\n</code></pre> <p>En OCaml, l'application d'une fonction est syntaxiquement plus prioritaire que les autres op\u00e9rations.</p>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#application-de-fonction","title":"Application de fonction","text":"<p>En programmation fonctionnelle, l'application de fonction est la seule op\u00e9ration qui permette d'effectuer un calcul. M\u00eame <code>2 + 3</code> est en fait du sucre syntaxique pour exprimer l'application de <code>(+)</code> \u00e0 <code>2</code> et <code>3</code> : c.a.d <code>(+) 2 3</code></p> <p>Pour effectuer <code>&lt;expr1&gt; &lt;expr2&gt;</code> :</p> <ul> <li>On \u00e9value <code>&lt;expr1&gt;</code> . C'est n\u00e9cessairement une fonction de la forme <code>fun x -&gt; e</code> de type \\(\u03c4\u2192\u03c4\u2032\\).</li> <li>On \u00e9value <code>&lt;expr 2&gt;</code> . L'expression r\u00e9sultante <code>v</code> doit \u00eatre de type \\(\u03c4\\).</li> <li>On \u00e9value l'expression <code>e</code> dans un environnement o\u00f9 <code>x</code> est associ\u00e9 \u00e0 la valeur <code>v</code> . La valeur renvoy\u00e9e est de type \\(\u03c4\u2032\\).</li> </ul>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#fonction-sans-argument","title":"Fonction sans argument","text":"<p>Une fonction sans argument prend en fait un unique argument de type <code>unit</code> (qu'on note <code>()</code>).</p> <p><pre><code>let f () = print_string \"coucou\";;\nval f : unit -&gt; unit = &lt;fun&gt;\n</code></pre> Bien s\u00fbr, la fonction <code>f</code> ci-dessus peut \u00eatre vue comme un alias pour l'expression <code>print_string \"coucou\"</code>.</p> <p>Les fonctions dont le type de retour est <code>unit</code> sont souvent utilis\u00e9es pour r\u00e9aliser des affichages ou bien des mises \u00e0 jour de variables mutables (tableaux, r\u00e9f\u00e9rences...).</p>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#fonction-sans-resultat","title":"Fonction sans r\u00e9sultat","text":"<p>Les fonctions sans r\u00e9sultat sont utilis\u00e9es \u00e0 des fins d'affichage et/ou pour r\u00e9aliser des effets de bord. Pour le moment toutes nos variables sont persistantes mais on d\u00e9couvrira bient\u00f4t comment cr\u00e9er des variables mutables.</p> <pre><code>let print_square x =\nPrintf.printf \"%f^0.5=%f\" x (sqrt x);;\n val print_square : float -&gt; unit = &lt;fun&gt;\nprint_square 2.;; (* Observer : '2.' pas '2'*)\n 5 2.000000^0.5=1.414214 - : unit = ()\n</code></pre>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#ordre-superieur","title":"Ordre sup\u00e9rieur","text":"<p><pre><code>let f x = x*x;;\n val f : int -&gt; int = &lt;fun&gt;\nlet affiche f x = print_int (f x);;\n val affiche : ('a -&gt; int) -&gt; 'a -&gt; unit = &lt;fun&gt;\naffiche f 2;;\n- : unit = ()\n</code></pre> Ci-dessus <code>affiche</code> prend deux arguments : une fonction d'un certain type (not\u00e9 <code>'a</code> ) vers les entiers, un \u00e9l\u00e9ment de type <code>'a</code> . Le type de retour est unit . Le type de la fonction est donc <code>('a -&gt; int) -&gt; 'a -&gt; unit = &lt;fun&gt;</code></p> <p>On a vu qu'on peut passer une fonction en argument. On peut aussi renvoyer une fonction.</p> <p>renvoie de l'homoth\u00e9tie de rapport x : <pre><code>let homothetie x = fun a -&gt; a * x;;\n val homothetie : int -&gt; int -&gt; int = &lt;fun&gt;\n(homothetie 3) 5;;\n- : int = 15\nlet g = homothetie 3 in g 5;;\n- : int = 15\n</code></pre></p>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#application-partielle","title":"Application partielle","text":"<p>D\u00e9finissons une fonction \u00e0 deux arguments :</p> <pre><code>let milieu x y = (x+.y)/.2.;;\n val milieu : float -&gt; float -&gt; float = &lt;fun&gt;\nmilieu 2. 3.;;\n- : float = 2.5\n</code></pre> <p>Lorsqu'une fonction a plusieurs arguments, on n'est pas oblig\u00e9 de les lui fournir tous lors de l'application. Si on ne le fait pas le r\u00e9sultat de cette application partielle est lui m\u00eame une fonction qui peut \u00e9ventuellement \u00eatre li\u00e9 a un identificateur et \u00eatre appliqu\u00e9 par la suite.</p> <pre><code>let g = milieu 2.;;\nval g : float -&gt; float = &lt;fun&gt;\ng 3.;;\n- : float = 2.5\n</code></pre>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#fonctions-recursives","title":"Fonctions r\u00e9cursives","text":"<p>Ecrivons la fonction <code>puissance</code></p> <pre><code>let puissance b n =\n    if n =0 then 1\n    else b * puissance b (n-1);;\n\nCharacters 69 -78:\n    else b * puissance b (n-1);;\n                       ^^^^^^^^^\nError: Unbound value puissance\n</code></pre> <p>Il faut pr\u00e9venir le compilateur que la fonction est r\u00e9cursive en faisant suivre le mot clef <code>let</code> du mot clef <code>rec</code>. <pre><code>let rec puissance b n =\n    if n =0 then 1\n    else b * puissance b (n-1);;\n val puissance : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre></p>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#fonctions-mutuellement-recursives","title":"Fonctions mutuellement r\u00e9cursives","text":"<p>On utilise une construction de la forme <code>let rec g = ... and f = ...</code> Calcul de parit\u00e9</p> <pre><code>let rec pair n = (n=0) || impair (n-1)\nand impair n = (n &lt;&gt; 0) &amp;&amp; pair (n-1);;\n val pair : int -&gt; bool = &lt;fun&gt;\n val impair : int -&gt; bool = &lt;fun&gt;\npair 5;;\n- : bool = false\nimpair 5;;\n- : bool = true\n</code></pre>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#filtrage-sur-motif-de-largument","title":"Filtrage sur motif de l'argument","text":"<p>Quand on conna\u00eet la forme du motif de l'argument, on peut anticiper :</p> <pre><code>let f ((x,(y,z)),t) = x*t-z*y;;\n val f : (int * (int * int)) * int -&gt; int = &lt;fun&gt;\nf ((1,(2,3)) ,4);;\n- : int = -2\nf (1,2,3,4);; (* erreur de type*)\nCharacters 2-11:\n f (1,2,3,4);;\n   ^^^^^^^^^\nError: This expression has type 'a * 'b * 'c * 'd\n       but an expression was expected of type\n       (int * (int * int)) * int\n</code></pre>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#emuler-des-boucles","title":"Emuler des boucles","text":"<p>Pour le moment on ne pr\u00e9sente pas les traits imp\u00e9ratifs de OCaml. Comment \u00e9muler une boucle comme celle-ci : <pre><code>int x = ...;\nwhile (x &lt; 45){\nx = x+3\n}\n</code></pre></p> <p>On peut le faire facilement avec une fonction comme celle-ci :</p> <pre><code>let rec loop x =\n    if x &lt; 45 then loop (x+3) else x;;\n</code></pre>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#filtrage-sur-les-listes","title":"Filtrage sur les listes","text":"<p>Warning</p> <p>Les pr\u00e9sents transparents ne sont qu'une introduction \u00e0 OCaml. On ne pr\u00e9sente ci-dessous que le cas particulier du filtrage sur les listes.</p>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#listes","title":"Listes","text":"<p>Les listes d'objets de type \\(\u03c4\\) sont d\u00e9finies inductivement par</p> <ul> <li>la liste vide <code>[]</code> est une liste d'objets de n'importe quel type donc en particulier de type \\(\u03c4\\);</li> <li>Si \\(e\\) est de type \\(\u03c4\\) et si <code>t</code> est une liste de type \\(\u03c4\\), alors <code>e::t</code> est une liste d'objets de type \\(\u03c4\\).</li> </ul> <p>On peut donc explorer une liste en la d\u00e9construisant : on s\u00e9pare son \u00e9l\u00e9ment de t\u00eate du reste de la liste ; on traite l'\u00e9l\u00e9ment de t\u00eate et on applique le m\u00eame traitement au reste de la liste.</p>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#consequence-de-la-definition-inductive","title":"Cons\u00e9quence de la d\u00e9finition inductive","text":"<p>On a vu comment sont construites inductivement les listes. Il devient possible de les explorer.</p> <pre><code>let rec longueur t = if t = [] then 0\nelse let l = List.tl t in 1 + longueur l;;\n val longueur : \u2019a list -&gt; int = &lt;fun &gt;\nlongueur [3;6;8];;\n- : int = 3\n</code></pre> <p>Rappel : <code>List.tl t</code> donne la queue de liste (tout sauf le premier \u00e9l\u00e9ment)</p> <p>On pourrait aussi \u00e9crire, de fa\u00e7on plus proche de la d\u00e9finition inductive :</p> <pre><code>let rec longueur t = if t = [] then 0\n    else let _::l = t in 1 + longueur l;;\n</code></pre> <p>Mais on recevrait un Warning pour risque de filtrage non exhaustif dans <code>let _::l = t</code></p>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#instruction-de-filtrage-match-with","title":"Instruction de filtrage match with","text":"<p>L'exemple simpliste du calcul de la longueur pourrait faire penser qu'on peut r\u00e9soudre \u00e9l\u00e9gamment tous les probl\u00e8mes sur les listes avec les op\u00e9rateurs <code>if then else</code>.</p> <p>Mais on risque vite d'avoir une cascade inesth\u00e9tique de <code>if then else</code>.</p> <p>Pour \u00e9viter cela, l'instruction match with r\u00e9alise un filtrage de motif. Elle permet soit de g\u00e9rer diff\u00e9rents cas en fonction des valeurs d'une expression, soit d'acc\u00e9der aux \u00e9l\u00e9ments d'un type construit (ou les deux \u00e0 la fois).</p> <p>Plus lisible que <code>if then else</code> en cascades <code>match with</code> effectue en outre une analyse d'exhaustivit\u00e9. Il v\u00e9rifie que tous les cas possibles ont bien \u00e9t\u00e9 couverts ce qui est tr\u00e8s utile pour le d\u00e9bugage.</p> <p>Calcul de longueur avec filtrage</p> <pre><code>let rec longueur l = match l with\n| [] -&gt; 0\n| _::t -&gt; 1+ longueur t;;\n  val longueur : 'a list -&gt; int = &lt;fun&gt;\nlongueur [3;6;8];;\n- : int = 3\n</code></pre> <p>Observer le <code>_::t</code> qui permet de ne pas tenir compte de la valeur de l'\u00e9l\u00e9ment de t\u00eate, seulement de son existence.</p>"},{"location":"Ocaml/Prise%20en%20main%20en%20OCaml/#filtrage-sur-des-tuples","title":"Filtrage sur des tuples","text":"<p>Le filtrage de motif permet soit de g\u00e9rer diff\u00e9rents cas en fonction des valeurs d'une expression, soit d'acc\u00e9der aux \u00e9l\u00e9ments d'un type construit (ou les deux \u00e0 la fois). La fonction suivante filtre ses arguments (une paire) pour faire leur addition en tenant compte du cas o\u00f9 l'un d'entre eux est z\u00e9ro : <pre><code>let rec somme a b =\n    match a,b with\n    | 0,n -&gt; n\n    | n,0 -&gt; n\n    | _,_ (* autres cas*) -&gt; 1 +\n                                if a &gt; b\n                                then somme a (b-1)\n                                else somme (a-1) b;;\n val somme : int -&gt; int -&gt; int = &lt;fun&gt;\nsomme 2 3;; (*exo : faire tourner \u00e0 la main*)\n- : int = 5\n</code></pre></p>"},{"location":"Ocaml/R%C3%A9cursion%20terminal/","title":"R\u00e9cursion terminale et gestion de la m\u00e9moire en OCaml","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <p>Developpez.com</p>"},{"location":"Ocaml/R%C3%A9cursion%20terminal/#gestion-de-la-memoire-en-ocaml","title":"Gestion de la m\u00e9moire en OCaml","text":""},{"location":"Ocaml/R%C3%A9cursion%20terminal/#un-exemple","title":"Un exemple","text":"<p>Exemple</p> <p>Consid\u00e9rons le programme suivant. Il calcule la somme des entiers de \\(0\\) \u00e0 \\(1 000 000\\) : <pre><code>let rec somme n =\n    if n=0 then 0 else n + somme (n-1)\nlet v = somme 1_000_000\n</code></pre> Compilation, ex\u00e9cution : <pre><code>$ocamlopt somme.ml -o somme\n$./ somme\nFatal error: exception Stack_overflow\n</code></pre> Il y a d\u00e9bordement de pile : le nombre de stack frame est trop grand.</p>"},{"location":"Ocaml/R%C3%A9cursion%20terminal/#analyse","title":"Analyse","text":"<p>On empile puis d\u00e9pile les stack frame</p> <p>Chaque stack frame contient une sauvegarde des registres du processeur; un espace pour stocker la valeur de retour; le param\u00e8tre; l'adresse de retour.</p> <p>Entrons la commande suivante</p> <pre><code>$ulimit -s\n8192\n</code></pre> <p>On obtient donc que la taille de la pile d'appel est de 8 octets.</p> <p>Avec <code>somme 1 000 000</code> on empile donc \\(1 000 000 + 1\\) stack frame d'au moins \\(4\\) bytes. On comprend que la taille allou\u00e9e \u00e0 la pile soit d\u00e9pass\u00e9e.</p>"},{"location":"Ocaml/R%C3%A9cursion%20terminal/#organisation-de-la-memoire-en-ocaml","title":"Organisation de la m\u00e9moire en OCaml","text":"<p>La zone de donn\u00e9es statiques contient les constantes pr\u00e9sentes dans le code source du programme comme les cha\u00eenes de caract\u00e8res.</p> <p>Toutes les valeurs en OCaml sont des pointeurs sur des donn\u00e9es dans le tas. Les var. locales de la pile ne peuvent \u00eatre que d'une des 4 cat\u00e9gories suivantes :</p> <ul> <li>les entiers <code>int</code> , les caract\u00e8res <code>char</code></li> <li>le type <code>unit</code></li> <li>les constructeurs sans arguments dans les types sommes (ils sont repr\u00e9sent\u00e9s en interne par des entiers)</li> </ul> <p></p> <p>R\u00e9partition de la m\u00e9moire lors de l'ex\u00e9cution d'un programme</p>"},{"location":"Ocaml/R%C3%A9cursion%20terminal/#ramasse-miette","title":"Ramasse miette","text":"<p>En OCaml, la lib\u00e9ration des zones m\u00e9moires est faite automatiquement par un algorithme appel\u00e9 ramasse miette (en anglais Garbage Collector GC).</p> <p>Le GC agit pendant l'ex\u00e9cution du programme. Il d\u00e9termine quelles zones m\u00e9moires dans le tas sont devenues inutiles. Il les lib\u00e8re automatiquement.</p>"},{"location":"Ocaml/R%C3%A9cursion%20terminal/#gestion-de-la-memoire-par-los","title":"Gestion de la m\u00e9moire par l'OS","text":"<p>L'OS g\u00e8re l'espace occup\u00e9 par les segments durant l'ex\u00e9cution du programme. C'est lui qui assure l'int\u00e9grit\u00e9 de ces diff\u00e9rents segments et qui emp\u00eache par exemple que la pile \u00e9crive dans le tas.</p> <p>S'il est besoin d'allouer plus de m\u00e9moire pour le tas que ce qui \u00e9tait pr\u00e9vu, c'est le m\u00e9canisme de m\u00e9moire virtuelle du syst\u00e8me qui s'en charge.</p> <p>Il faut donner au programmeur l'impression que la RAM est infinie. Si la RAM vient \u00e0 manquer, l'OS est capable d'utiliser automatiquement d'autres zones de stockage comme le disque dur ou une cl\u00e9 USB (\u00e9videmment, les performances se d\u00e9gradent alors).</p>"},{"location":"Ocaml/R%C3%A9cursion%20terminal/#remediation-en-force-brute","title":"Rem\u00e9diation en force brute","text":"<p>On d\u00e9cide d'augmenter la taille de la pile :</p> <pre><code>$ulimit -s unlimited\n$ulimit -s\nunlimited\n</code></pre> <p>Cela permer d'augmenter la taille de la pile \u00e0 la taille maximale du syst\u00e8me d'exploitation. Sous \\(Linux\\), cette taille est illimit\u00e9 (mais l'administrateur peut imposer une limite). Sous \\(MacOs\\), la limite est de \\(65\\) Mo.</p> <p>Il est maintenant possible d'ex\u00e9cuter le programme <code>./somme</code>. Mais l'ex\u00e9cution est lente du fait des empilements/d\u00e9pilements successifs de stack frame.</p>"},{"location":"Ocaml/R%C3%A9cursion%20terminal/#recursion-terminale","title":"R\u00e9cursion terminale","text":""},{"location":"Ocaml/R%C3%A9cursion%20terminal/#appel-terminal","title":"Appel terminal","text":"<p>La r\u00e9cursivit\u00e9 terminale est une forme particuli\u00e8re de r\u00e9cursivit\u00e9 pouvant \u00eatre optimis\u00e9e afin de ne pas consommer de m\u00e9moire dans la pile.</p> <p>Dans le corps d'une fonction, un appel est terminale s'il est la derni\u00e8re op\u00e9ration effectu\u00e9e par la fonction.</p> <p>Les fonctions suivantes font un appel terminal \u00e0 <code>g</code></p> <pre><code>1 let f1 x = g x\n2 let f2 x = if ... then g x else ...\n3 let f3 x = let y = ... in g y\n4 let f4 x = match x with\n5 | ... -&gt; ...\n6 | ... -&gt; g x\n7 | _ -&gt; ...\n</code></pre> <p>Appels \u00e0 g non terminaux :</p> <pre><code>1 let f5 x = x + g x\n2 let f6 x = let y = g x in y+1\n</code></pre>"},{"location":"Ocaml/R%C3%A9cursion%20terminal/#definition","title":"D\u00e9finition","text":"<p>D\u00e9finition Une fonction est dite r\u00e9cursive terminale si tous les appels r\u00e9cursifs dans sa d\u00e9finition sont en position terminale.</p> <p>Int\u00e9r\u00eat Il n'est plus n\u00e9cessaire d'empiler les stack frame lors des appels r\u00e9cursifs. La stack frame de d\u00e9part suffit.</p>"},{"location":"Ocaml/R%C3%A9cursion%20terminal/#exemple","title":"Exemple","text":"<p><code>let rec f x = if x = 0 then 10 else f (x-1)</code> Gestion de la pile d'appel :</p> <ul> <li>Pour <code>f 2</code> La case r\u00e9serv\u00e9e pour la valeur retour est vide, l'argument <code>x</code> contient \\(2\\).</li> <li>L'appel <code>f 1</code> peut utiliser la m\u00eame stack frame que <code>f 2</code> car la valeur 2 contenue dans la case <code>x</code> , n'est plus utilis\u00e9e par la suite. On met donc 1 dans <code>x</code> .</li> <li>L'appel <code>f 0</code> utilise encore la m\u00eame stack frame en mettant 0 dans la case <code>x</code>. <p>La valeur de retour (10) est mise dans <code>ret</code></p> car c'est la valeur qui est finalement renvoy\u00e9e par le 1er appel (<code>f 2</code>)</li> </ul> <p></p> <p>Pile de m\u00e9moire lors de l'appel de <code>f 2</code></p>"},{"location":"Ocaml/R%C3%A9cursion%20terminal/#fonction-somme-version-en-recursion-terminale","title":"Fonction somme : version en r\u00e9cursion terminale","text":"<p>On utilise une fonction auxiliaire <code>sum</code> \u00e0 deux param\u00e8tres : l'entier ourant <code>x</code> et un accumulateur <code>acc</code>.</p> <p>L'accumulateur grossit au fil des appels r\u00e9cursifs internes et il contient la valeur voulue lorsque <code>x</code> devient nul. On renvoie donc <code>acc</code>.</p> <p>Code : <pre><code>let somme x =\n    let rec sum x acc = (* fonction auxiliaire *)\n        if x = 0 then acc else sum (x-1) acc + x\n    in sum x 0\n\nlet _ = let v = somme 1_000_000 in Printf.printf \"%d\" v\n</code></pre></p> <p>D'une fa\u00e7on g\u00e9n\u00e9rale, une fonction auxiliaire est utile lorsqu'on a besoin de plus de param\u00e8tres que ceux initialement pr\u00e9vus.</p>"},{"location":"SQL/bdd1/","title":"bdd1","text":"<p>====</p> <p>Danger</p> <p>Ce cours n'a pas \u00e9t\u00e9 enti\u00e8rement reverifi\u00e9 apr\u00e8s le passage du programme. Pensez \u00e0 supprimer ce message si vous avez reverifi\u00e9 ce cours</p> <p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"SQL/bdd1/#introduction","title":"Introduction","text":""},{"location":"SQL/bdd1/#e-f-codd-wikipedie","title":"E. F. Codd (Wikipedi\u00e9)","text":""},{"location":"SQL/bdd1/#resume","title":"R\u00e9sum\u00e9","text":"<ul> <li>Le Modele relationnel pour la gestion des Bases De Donn\u00e9es (BDD)  est un mod\u00e8le de BDD bas\u00e9 sur la logique du premier ordre propos\u00e9  et formul\u00e9 pour la 1ere fois par Edgar F. Codd (1969).  </li> <li>Dans une BDD relationnelle l\u2019information est organis\u00e9e dans des  tableaux \u00e0 deux dimensions appel\u00e9es relations ou tables.  </li> <li>Une BDD est donc un ensemble de tables. Les lignes sont appel\u00e9es  tuples, nuplets ou encore enregistrements.  </li> <li>Le mod\u00e8le relationnel fournit une m\u00e9thode d\u00e9clarative pour sp\u00e9cifier  donn\u00e9es (l\u2019ensemble \u00e9tudi\u00e9) et requ\u00eates (questions permises sur cet  ensemble).  </li> <li>L\u2019utilisateur d\u00e9crit les informations que contient la BDD et quelles  informations il souhaite conna\u00eetre et laisse le syst\u00e8me de gestion de  BDD (SGBD) g\u00e9rer la description machine de la base et son stokage  ainsi que la mani\u00e8re dont il retrouve l\u2019information.  </li> </ul>"},{"location":"SQL/bdd1/#le-modele-relationnel","title":"Le mod\u00e8le relationnel","text":""},{"location":"SQL/bdd1/#quelques-considerations-generales","title":"Quelques consid\u00e9rations g\u00e9n\u00e9rales","text":"<ul> <li>Toutes les donn\u00e9es sont repr\u00e9sent\u00e9es comme des relations n\u2212aires,  des sous-ensembles de produits cart\u00e9siens de n ensembles.  </li> <li>Calculs sur les donn\u00e9es : calcul relationnel ou alg\u00e8bre relationnelle. Le concepteur de BDD relationnelle cr\u00e9e un mod\u00e8le logique coh\u00e9rent  (sans contradiction).  </li> </ul>"},{"location":"SQL/bdd1/#attributs","title":"Attributs","text":"<p>D\u00e9finition: Attribut</p> <p>On consid\u00e8re donn\u00e9 un ensemble infini A, dont les \u00e9l\u00e9ments sont appel\u00e9s des attributs, un ensemble D (ensemble des domaine), et une application dom de A dans D.</p> <p>Remarque Si A \\(\\in\\) A, l\u2019\u00e9l\u00e9ment dom(A) de D est appel\u00e9 domaine de A. La domaine de A est lui-m\u00eame un ensemble, par exemple ensemble des entiers, des flottants, des cha\u0131\u0302nes de caract\u00e8res...</p> <p>Exemple Soit le lyc\u00e9e Pierre Dupont contenant des CPGE. Les classes sont des couples (fili\u00e8re,num\u00e9ro) comme (MPSI,1) ; (MPSI,2) ou (PCSI,1).</p> <ul> <li>fili\u00e8re est un attribut dont le domaine est l\u2019ensemble fini de cha\u00eenes de caract\u00e8res {MPSI,PCSI,PC,PSI,MP,BCPST,HK}. </li> <li>num\u00e9ro est un attribut dont le domaine est l\u2019ensemble \\(\\mathbb{N}^\u2217\\) ou mieux : un intervalle \\([\\![0,m]\\!]\\) o\u00f9 m est le nombre maximum de classes de m\u00eame niveau dans le lyc\u00e9e.</li> </ul>"},{"location":"SQL/bdd1/#schema-relationnel","title":"Sch\u00e9ma relationnel","text":"<p>D\u00e9finition : Sch\u00e9ma relationnel</p> <p>Soit A un ensemble d\u2019attributs et dom une application qui associe un domaine \u00e0 chaque attribut. Un Sch\u00e9ma relationnel est un tuple \\(S = (A_1, A_2, ..., A_n) \\in A_n\\) o\u00f9 les \\(A_i\\) sont distincts deux \u00e0 deux (mais peuvent avoir les m\u00eames domaines).</p> <p>Remarque - G\u00e9n\u00e9ralement, on \u00e9crit le sch\u00e9ma relationnel sous forme de tuples de couples (attribut, domaine) comme $S = ((A_1, dom(A_1)), ...  , (A_n , dom(A_n))) - Le plus souvent, on ajoute au sch\u00e9ma des symboles indiquant les cl\u00e9s primaires et cl\u00e9s \u00e9trang\u00e8res (voir sections d\u00e9di\u00e9es).</p> <p>Exemple Sch\u00e9ma des classes du lyc\u00e9e : \\(\\(S = ((\\text{filiere, {MPSI,PCSI,...}}), (\\text{num\u00e9ro,} \\mathbb{N}^\u2217 ))\\)\\)</p> <p>Notation - On \u00e9crit \\(B \\in S\\) si \\(B \\in {A_1, ... , A_n}\\). - Si \\(X = {B_1, ... , B_m}\\) est un ensemble d\u2019attributs (distincts), on \u00e9crit  \\(X \\subset S\\) si tous les \\(B_i\\) sont dans \\({A_1, ... , A_n}\\). - On s\u2019autorise aussi des notations de la forme : \\(\\(\\text{(nom,ville)} \\subset \\text{(t\u00e9l\u00e9phone,nom,ville,classe)}\\)\\)</p>"},{"location":"SQL/bdd1/#table","title":"Table","text":"<p>D\u00e9finition: Relation ou table associ\u00e9e \u00e0 un sch\u00e9ma relationnel</p> <p>On appelle relation ou table associ\u00e9e \u00e0 un sch\u00e9ma relationnel \\((A_1, A_2, ... , A_n)\\) tout ensemble fini de tuples de \\(dom(A_1) \u00d7 dom(A_2) \u00d7 . . . dom(A_n)\\).</p> <p>Notation - Les relations sont souvent not\u00e9es sous la forme R(S) (pour indiquer que R est associ\u00e9 au sch\u00e9ma S). - Explication : dans la colonne i d\u2019une table de sch\u00e9ma S, les valeurs sont obligatoirement dans le domaine dom(Ai ). C\u2019est ce qu\u2019on appelle une contrainte d\u2019int\u00e9grit\u00e9 (ici, on parle d\u2019int\u00e9grit\u00e9 de domaine).</p> <p>j'arrive pas avec les tableaux</p> Example <ul> <li> <p>Si la table classe est finie on peut la repr\u00e9senter par un tableau :</p> <p>classe(fili\u00e8re,num\u00e9ro)=  | Fili\u00e8re | Num\u00e9ro | |---------|--------| |MPSI|1| |PC|3| |PCSI|2| |PCSI|1|</p> </li> <li> <p>L\u2019ordre des attributs et des tuples n\u2019a pas d\u2019importance. On a aussi :</p> <p>classe(fili\u00e8re,num\u00e9ro)=  |Num\u00e9ro|Fili\u00e8re| |---|---| |3|PC| |1|PCSI| |1|MPSI| |2|PCSI|</p> </li> </ul>"},{"location":"SQL/bdd1/#representation-des-schemas-relationnels","title":"Repr\u00e9sentation des sch\u00e9mas relationnels","text":"<p>j'arrive pas avec les tableaux</p> <p>D\u00e9finition</p> <p>Notation</p> <p>D\u00e9finition</p> <p>Exemple</p> <p>Nom du sch\u00e9ma Attribut 1  Attribut 2 type 1  type 2 \u00e9l\u00e8ve Le sh\u00e9ma Nom  Ann\u00e9e de naissance string  int poss\u00e8de les instances Nom  Hoareau  Grondin Ann\u00e9e de naissance  1996  1995 Nom  Nativel  Hoareau  Grondin Ann\u00e9e de naissance  1998  1996  1997  </p>"},{"location":"SQL/bdd1/#multi-ensemble","title":"Multi-ensemble","text":"<p>Remarque Un multi-ensemble est une sorte d\u2019ensemble dans lequel un m\u00eame \u00e9l\u00e9ment  peut appara\u00eetre plusieurs fois comme dans {1, 2, 3, 2}. - Notion \u00e0 mi-chemin des ensembles et des listes. - On peut voir les multi-ensembles comme des listes quotient\u00e9es par les  permutations, i.e. des listes commutatives. - Le multi-ensemble {1, 2, 2} est \u00e9gal \u00e0 {2, 1, 2}.  </p> <p>Les relations du mod\u00e8le relationnel sont en fait des multi-ensembles.  </p>"},{"location":"SQL/bdd1/#cles-uniques","title":"Cl\u00e9s uniques","text":""},{"location":"SQL/bdd1/#notation-objet","title":"Notation objet","text":"<p>Notation Soit R(S) une relation, e \\(\\in\\) R(S) un enregistrement et A \\(\\in\\) S. On note e.A la composante du tuple e associ\u00e9e \u00e0 l\u2019attribut A. Si K \\(\\subset\\) S, on note e.K le sous-tuple de e constitu\u00e9 des composantes associ\u00e9es aux \u00e9l\u00e9ments de K. Il s\u2019agit de la projection de e sur les attributs de K.</p> <p>Exemple</p> <p>j'arrive pas avec les tableaux</p> <p>classe(fili\u00e8re,num\u00e9ro,Salle)= Fili\u00e8re Num\u00e9ro  MPSI  MPSI  PCSI 1  2  2 Salle  B.10  C.34  B.1 Si e = (PCSI, 2, B.1), alors e.Num\u00e9ro = 2 et e.(Num\u00e9ro, Salle) = (2, B.1).  On dit que e.A est la projection de e sur l\u2019attribut A. e.\\((A_1, ... , A_n)\\) est la  projection de e sur \\(A_1 \u00d7 \u00b7\u00b7\u00b7 \u00d7 A_n\\).  </p>"},{"location":"SQL/bdd1/#cle-unique","title":"Cl\u00e9 unique","text":"<p>D\u00e9finition : cl\u00e9 unique</p> <p>Soit R(S) une relation de sch\u00e9ma S. On dit que K \u2282 S est une cl\u00e9 unique pour R si et seulement si \\(\\(\u2200(t_1, t_2) \\in R^2 , t_1.K = t_2.K \u21d0\u21d2 t_1 = t_2\\)\\)</p> <p>Remarque - La connaissance des attributs dans K suffit \u00e0 distinguer deux \u00e9l\u00e9ments. - K est une cl\u00e9 unique si et seulement si la projection sur K est injective. - Lorsqu\u2019il y a une cl\u00e9 unique, la table ne contient pas de doublon de lignes. - Souvent, on impose que K soit de cardinal mi</p> <p>Exemple</p> <p>j'arrive pas avec les tableaux</p> <p>\u00e9l\u00e8ve(Nom,Pr\u00e9nom,Ann\u00e9e de naissance)= Pr\u00e9nom Ann\u00e9e de naissance  Nom  Patrice  Hoareau  Hoareau  Patrice  Dupont Marie  Patrice  Grondin 1996  1995  1997  1996  </p> <p>(Nom,Pr\u00e9nom) n\u2019est pas une cl\u00e9 unique, ni (Pr\u00e9nom,Ann\u00e9e) mais  (Nom,Ann\u00e9e) est une cl\u00e9 unique.  </p> <p>Soit R(S) une relation de sch\u00e9ma S.  </p> <ul> <li>Souvent, on cherche \u00e0 limiter la cl\u00e9 unique \u00e0 un seul attribut.  Le terme cl\u00e9 unique est trompeur : il peut y en avoir plusieurs ! Exemple : dans la table Etudiant(id,nom, pr\u00e9nom,num. de  s\u00e9cu) il y a deux cl\u00e9s uniques possibles :  </li> <li>id (le num\u00e9ro d\u2019\u00e9tudiant).  </li> <li>num. de s\u00e9cu  </li> <li>Les cl\u00e9s sont choisies par le d\u00e9veloppeur au moment d ela conception. Une cl\u00e9 unique peut porter sur plusieurs attributs : il peut tr\u00e8s bien ne  pas y avoir de cl\u00e9 \u00e0 un seul \u00e9l\u00e9ment.  </li> <li>Et d\u2019ailleurs, il est possible qu\u2019il n\u2019y ait pas de cl\u00e9 unique (si la table  poss\u00e8de des doublons de lignes). Mais on d\u00e9courage d\u2019utiliser de telles  tables.  </li> </ul>"},{"location":"SQL/bdd1/#cle-primaire","title":"Cl\u00e9 primaire","text":"<p>MySQL fait la distinction entre les notions de cl\u00e9 unique et cl\u00e9 primaire.  </p> <p>D\u00e9finition: cl\u00e9 primaire</p> <p>Une cl\u00e9 primaire est une cl\u00e9 unique particuli\u00e8re associ\u00e9e \u00e0 un index.</p> <p>Remarque - On peut voir l\u2019index comme une table des mati\u00e8res facilitant un acc\u00e8s  rapide aux enregistrement d\u2019une table ayant une cl\u00e9 primaire. - En particulier, la complexit\u00e9 des jointures est grandement diminu\u00e9e  par l\u2019usage d\u2019une cl\u00e9 primaire ; les valeurs possibles \u00e9tant tri\u00e9es dans  l\u2019index. - Il peut y avoir plusieurs cl\u00e9s unique par table mais une seule cl\u00e9  primaire. - Une cl\u00e9 unique peut prendre la valeur NULL (case vide, \u00e9quivalent  Python de None) pas la cl\u00e9 primaire.  </p>"},{"location":"SQL/bdd1/#cle-unique-vs-cle-primaire","title":"Cl\u00e9 unique VS cl\u00e9 primaire","text":"<ul> <li>Conform\u00e9ment au programme nous ferons d\u00e9sormais la confusion :  nous n\u2019emploirons plus que l\u2019expression \"cl\u00e9 primaire\" sans nous  soucier de la pr\u00e9sence d\u2019un index ou non.</li> <li>Une cons\u00e9quence est que nous avons au plus une cl\u00e9 primaire par  table.  </li> <li>Une autre est que les cases des colonnes d\u00e9finissant la cl\u00e9 primaire ne sont jamais vide (pas de valeur NULL).  </li> </ul>"},{"location":"SQL/bdd1/#cle-primaire_1","title":"Cl\u00e9 primaire","text":"<ul> <li>On indique par un symbole dans le sch\u00e9ma qu\u2019une cl\u00e9 est  unique/primaire.  </li> <li>Nous signalons les cl\u00e9s uniques en les soulignant. Sous  PHPMYADMIN, les cl\u00e9s primaires sont repr\u00e9sent\u00e9es par des cl\u00e9s  jaunes, les cl\u00e9s uniques par une cl\u00e9 grise.</li> </ul> <p>j'arrive pas avec les tableaux</p> <p>\u00e9l\u00e8ve Nom  Num\u00e9ro SS string  int  </p> <ul> <li>Un mot cl\u00e9 PRIMARY indique, au moment de la cr\u00e9ation de la table  dans la plupart des SGBD, qu\u2019une cl\u00e9 est primaire.  </li> <li>Si un tuple d\u00e9j\u00e0 d\u00e9fini poss\u00e8de une valeur v pour la cl\u00e9 primaire de la  table T, alors le SGBD devrait emp\u00eacher l\u2019ajout de tout nouveau tuple  \u00e0 T poss\u00e9dant la valeur v pour la cl\u00e9.  </li> </ul> <p>jme suis arr\u00eat\u00e9 l\u00e0</p>"},{"location":"SQL/bdd1/#relation-entre-deux-tables","title":"Relation entre deux tables","text":""},{"location":"SQL/bdd1/#deux-schemas","title":"Deux sch\u00e9mas","text":"<p>Soit une BDD mod\u00e9lisant une biblioth\u00e8que simplifi\u00e9e avec deux tables dont les sch\u00e9mas sont : livre titre  auteur  ann\u00e9e de publication string  string  int emprunteur et Nom  Livre emprunt\u00e9 string  string  </p>"},{"location":"SQL/bdd1/#deux-tables","title":"Deux tables","text":"<p>Une table biblioth\u00e8que instanciant livre : titre  Harry Potter  Pens\u00e9es  Marseille coquin auteur  J.K. Rowling  Pascal  Anonyme Publication  1997  1670  2016 Une table Clients instanciant emprunteur Livre emprunt\u00e9  Nom  Hoareau  Harry Potter  Grondin Marseille coquin  Dupont Maths MP On en conclut que Hoareau a emprunt\u00e9 \"Harry Potter\" et que  Grondin est un petit coquin ! Dupont emprunte un ouvrage qui n\u2019existe pas dans la biblioth\u00e8que,  ce qui concerne davantage l\u2019administrateur de BDD que la vie priv\u00e9e  de Grondin.  </p>"},{"location":"SQL/bdd1/#cle-etrangere","title":"Cl\u00e9 \u00e9trang\u00e8re","text":"<p>D\u00e9finition</p> <p>D\u00e9finition</p> <p>Une cl\u00e9 \u00e9trang\u00e8re (repr\u00e9sent\u00e9e dans ce cours par un #) est un attribut qui est la cl\u00e9 primaire d\u2019une autre relation. Elle permet d\u2019\u00e9tablir le lien entre plusieurs relations. Elle met en \u00e9vidence les d\u00e9pendances fonctionnelles entre 2 tables.</p> <p>D\u00e9finition</p> <p>Remarque</p> <p>En SQL, on d\u00e9clare une cl\u00e9 \u00e9trang\u00e8re avec les mots cl\u00e9s FOREIGN KEY.</p> <p>On peut repr\u00e9senter les liens entre deux relations dans un diagramme  par une \ufb02\u00e8che depuis l\u2019attribut vers la cl\u00e9 primaire.  Si on impose que le domaine de livre emprunt\u00e9 est constitu\u00e9  exactement des livres apparaissant dans la relation biblioth\u00e8que, le  sch\u00e9ma de emprunteur devient  Sh\u00e9ma r\u00e9f\u00e9ren\u00e7ant emprunteur Nom  Livre emprunt\u00e9# titre string \u2192 Sch\u00e9ma r\u00e9f\u00e9renc\u00e9  livre titre  auteur  ann\u00e9e de publication string  string  int Le tuple (Dupont,Maths MP) ne peut plus \u00eatre un enregistrement de  Client car Maths MP n\u2019est pas dans la colonne \"titre\" de  Biblioth\u00e8que.  </p> <p>La contrainte de cl\u00e9 \u00e9trang\u00e8re est g\u00e9r\u00e9e par la plupart des SGBD :  Oracle, Microsoft SQL Server, PostgreSQL, SQLite, etc.  </p>"},{"location":"SQL/bdd1/#_1","title":"bdd1","text":"<p>Introduction  Le mod\u00e8le relationnel  Cl\u00e9s uniques  Relations entre deux tables  Mod\u00e8le client-serveur Architecture client-serveur  Architecture trois-tiers  </p>"},{"location":"SQL/bdd1/#mode-de-communication","title":"Mode de communication","text":"<p>Environnement client-serveur : mode de communication \u00e0 travers un  r\u00e9seau entre plusieurs programmes ou logiciels  le premier, le client, envoie des requ\u00eates ;  l\u2019autre ou les autres, les serveurs, attendent les requ\u00eates des clients et y  r\u00e9pondent.  </p> <p>Par extension, le client d\u00e9signe \u00e9galement l\u2019ordinateur sur lequel est  ex\u00e9cut\u00e9 le logiciel client, et le serveur, l\u2019ordinateur sur lequel est  ex\u00e9cut\u00e9 le logiciel serveur.  </p>"},{"location":"SQL/bdd1/#vocabulaire","title":"Vocabulaire","text":"<p>Serveurs : souvent des ordinateurs d\u00e9di\u00e9s au logiciel serveur qu\u2019ils  abritent (ex : serveur Web, serveur de bases de donn\u00e9es, d\u2019impression  ...). Ils sont dot\u00e9s de capacit\u00e9s sup\u00e9rieures \u00e0 celles des ordinateurs  personnels en termes de puissance de calcul, d\u2019entr\u00e9es-sorties et de  connexions r\u00e9seau. Clients : souvent des ordinateurs personnels ou des appareils  individuels (t\u00e9l\u00e9phone, tablette), mais pas syst\u00e9matiquement. Nombre de clients. Un serveur peut r\u00e9pondre aux requ\u00eates d\u2019un grand  nombre de clients.  </p>"},{"location":"SQL/bdd1/#exemples","title":"Exemples","text":"<p>Grande vari\u00e9t\u00e9 de logiciels serveurs et de logiciels clients en fonction des  besoins \u00e0 servir : un serveur web publie des pages web demand\u00e9es par des navigateurs  web ; un serveur de messagerie \u00e9lectronique envoie des mails \u00e0 des clients  de messagerie ; un serveur de fichiers permet de stocker et consulter des fichiers sur le  r\u00e9seau ; un serveur de donn\u00e9es \u00e0 communiquer des donn\u00e9es stock\u00e9es dans une  base de donn\u00e9es, etc...  </p>"},{"location":"SQL/bdd1/#notion-de-port","title":"Notion de port","text":"<p>La notion de port logiciel permet, sur un ordinateur donn\u00e9, de  distinguer di\ufb00\u00e9rents interlocuteurs. Ces interlocuteurs sont des  programmes informatiques qui, selon les cas, \u00e9coutent ou \u00e9mettent  des informations sur ces ports. Un port est distingu\u00e9 par son num\u00e9ro.  Image : port = porte donnant acc\u00e8s au syst\u00e8me d\u2019exploitation.  Pour fonctionner, un programme ouvre des portes pour acc\u00e9der aux  services de l\u2019OS. Quand on ferme le programme, la porte n\u2019a plus  besoin d\u2019\u00eatre ouverte. Lorsqu\u2019un logiciel client veut dialoguer avec un logiciel serveur (le  service), il a besoin de conna\u00eetre le port \u00e9cout\u00e9 par ce dernier. Par  exemple port 80 pour un serveur web HTTP ; port 3306 serveur de  bases de donn\u00e9es MySQL ; port 8888 pour jupyter...  cat /etc/services pour avoir la liste des services bien connus. Ou  sudo netstat -antup | grep LISTEN pour la liste des ports en  \u00e9coute.  </p>"},{"location":"SQL/bdd1/#caracteristiques-dun-processus-serveur","title":"Caract\u00e9ristiques d\u2019un processus serveur","text":"<p>Attend une connexion entrante sur un ou plusieurs ports r\u00e9seaux. \u00e0 la connexion d\u2019un client sur le port en \u00e9coute, ouvre un socket local  (interface de comunication) avec le syst\u00e8me d\u2019exploitation ; suite \u00e0 la connexion, le processus serveur communique avec le client  suivant le protocole pr\u00e9vu par la couche application du mod\u00e8le OSI.  </p>"},{"location":"SQL/bdd1/#caracteristiques-dun-processus-client","title":"Caract\u00e9ristiques d\u2019un processus client","text":"<p>Figure \u2013 Architecture client-serveur</p> <p>\u00e9tablit la connexion au serveur gr\u00e2ce \u00e0 son adresse IP et le port, qui  d\u00e9signe un service particulier du serveur. Un socket est cr\u00e9\u00e9 c\u00f4t\u00e9  client. lorsque la connexion est accept\u00e9e par le serveur, les deux c\u00f4t\u00e9s  communiquent via les sockets comme le pr\u00e9voit la couche  application du mod\u00e8le OSI.  </p>"},{"location":"SQL/bdd1/#la-machine-a-cafe","title":"La machine \u00e0 caf\u00e9","text":"<p>Dans une caf\u00e9t\u00e9ria, les caf\u00e9s sont d\u00e9livr\u00e9s par un automate. Le client ins\u00e8re des pi\u00e8ces dans l\u2019automate, s\u00e9lectionne sa boisson et  attend que la machine remplisse son gobelet. Le serveur est la machine \u00e0 caf\u00e9. Le couple (client, automate) est une  architecture client-serveur.  Le client acc\u00e8de directement \u00e0 la ressource. Si le serveur est en panne, c\u2019est au client d\u2019en trouver un autre (pb de  maintenance)  Si le client est malhonn\u00eate, il peut tenter d\u2019ins\u00e9rer de fausses pi\u00e8ces (il  ne court aucun risque).  </p> <p>Introduction  Le mod\u00e8le relationnel  Cl\u00e9s uniques  Relations entre deux tables  Mod\u00e8le client-serveur Architecture client-serveur  Architecture trois-tiers  </p>"},{"location":"SQL/bdd1/#une-brasserie","title":"Une brasserie","text":"<p>Dans une brasserie, les gar\u00e7ons de caf\u00e9 ont acc\u00e8s directement au  percolateur. Le client (couche pr\u00e9sentation) s\u2019assied \u00e0 une table, attend que le  gar\u00e7on (couche m\u00e9tier) vienne prendre sa commande. Une fois que le gar\u00e7on a pris la commande, il acc\u00e8de au percolateur  (couche acc\u00e8s aux donn\u00e9es) derri\u00e8re le comptoir, pr\u00e9pare l\u2019expresso et  le ram\u00e8ne au client. Le triplet (client,gar\u00e7on,percolateur) est une architecture trois-tiers  (ou trois couches)  </p> <p>Le client acc\u00e8de n\u2019acc\u00e8de plus directement \u00e0 la ressource. Si le percolateur est en panne, c\u2019est au gar\u00e7on et pas au client d\u2019en  trouver un autre (maintenance facilit\u00e9e, on peut imaginer un  percolateur d\u2019appoint en attendant la r\u00e9paration du principal) Si le client est malhonn\u00eate, il lui est plus di\ufb03cile d\u2019acc\u00e9der au  percolateur pour se servir gratuitement (s\u00e9curit\u00e9 renforc\u00e9e). Bien s\u00fbr, le client pourrait attendre que le gar\u00e7on prenne la  commande d\u2019une autre personne pour acc\u00e9der en cachette au  percolateur. Il su\ufb03rait alors de mettre quelqu\u2019un en permanence  derri\u00e8re le bar (le patron) et ce probl\u00e8me serait r\u00e9solu (mais on  passerait en architecture 4 couches).  </p>"},{"location":"SQL/bdd1/#architecture-trois-tiers","title":"Architecture trois-tiers","text":"<p>D\u00e9finition</p> <p>D\u00e9finition</p> <p>Le mot tier signifie \u00e9tage ou niveau en anglais. On dit aussi couche.</p> <p>Une application est compos\u00e9e de 3 couches ind\u00e9pendantes :  couche pr\u00e9sentation,   couche traitements (on dit aussi m\u00e9tier ou application)   couche d\u2019acc\u00e8s aux donn\u00e9es. Ces 3 couches communiqueront entre elles \u00e0 l\u2019aide de fonctions  sp\u00e9cifiques (des API : Application Programming Interface ou  Interfaces de programmation).  </p>"},{"location":"SQL/bdd1/#sgbd-et-architecture-trois-tiers","title":"SGBD et architecture trois-tiers","text":"<p>On r\u00e9partit les r\u00f4les entre Un serveur contenant la base donn\u00e9es (non accessible par les clients)  Un syst\u00e8me de gestion de base donn\u00e9es : une interface souvent  graphique entre les clients et la base. Elle transmet la demande (requ\u00eate) du client au serveur de donn\u00e9es.  Elle r\u00e9cup\u00e8re la r\u00e9ponse du serveur de donn\u00e9es et la transmet au client. Le point important : le client ne communique jamais directement avec  le serveur de donn\u00e9es.  </p> <p>Base de donn\u00e9es Client 1 SGBD Client 2 Client 3 Seul le SGBD peut acc\u00e9der aux donn\u00e9es et les modifier. Le client n\u2019a pas besoin de conna\u00eetre le SQL : souvent une interface  graphique avec des cases \u00e0 cliquer lui \u00e9vite de le faire. Le client n\u2019a pas besoin d\u2019installer de logiciel : un navigateur Web lui  su\ufb03t  </p>"},{"location":"Tests/tests/","title":"Tests","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Sur la nuance entre erreur et d\u00e9faut, cet article de Cynthia Lefevre.  </li> <li>Ce cours du Labri.  </li> <li>Cet article de Wikipedia.  </li> <li>Ce cours du LRI de Paris-Saclay</li> <li>Un cours du CNAM avec des exemples de normes r\u00e9clamant les  crit\u00e8res \u00e9tudi\u00e9s.  </li> </ul>"},{"location":"Tests/tests/#presentation","title":"Pr\u00e9sentation","text":""},{"location":"Tests/tests/#terminologie","title":"Terminologie","text":"<p>D\u00e9finition: Erreur</p> <p>Action humaine produisant un r\u00e9sultat incorrect \\(\\color{red}\\text{\"l\u2019erreur est humaine\"}\\)</p> <p>D\u00e9finition: D\u00e9faut</p> <p>Une imperfection dans un composant (ou un syst\u00e8me) qui peut conduire \u00e0 ce que ce composant (ou syst\u00e8me) n\u2019ex\u00e9cute pas les fonctions requises. \\(\\color{red}\\text{On cherche les d\u00e9fauts sans manipuler le syst\u00e8me}\\).</p> <p>D\u00e9finition: D\u00e9faillance ou Panne</p> <p>IEEE 729 : La fin de la capacit\u00e9 d\u2019un syst\u00e8me ou d'un de ses composants d'effectuer la fonction requise, ou de l'effectuer \u00e0 l'int\u00e9rieur de limites sp\u00e9cifi\u00e9es. \\(\\color{red}\\text{On cherche une d\u00e9faillance en manipulant le syst\u00e8me}\\).</p> <p>D\u00e9finition : Anolamie</p> <p>Un \u00e9cart entre le r\u00e9sultat attendu et celui obtenu.</p> <p>Remarque</p> <p>Ce n\u2019est pas parce qu\u2019il y a anomalie qu\u2019il y a d\u00e9faut. Peut-\u00eatre le testeur a-t-il compris la sp\u00e9cification d\u2019une fa\u00e7on et le d\u00e9veloppeur d\u2019une autre.</p>"},{"location":"Tests/tests/#defaut-vs-defaillance","title":"D\u00e9faut VS D\u00e9faillance","text":"<p>Il y a un rapport de causalit\u00e9.  </p> <ul> <li>A retenir : Un d\u00e9faut (dans le code) ou une erreur (de l\u2019utilisateur du  programme) peut causer (un jour) une d\u00e9faillance.  </li> <li>On peut trouver un d\u00e9faut sans manipuler le syst\u00e8me (analyse du  code).  </li> <li>Mais on trouve une d\u00e9faillance en manipulant le syst\u00e8me.  </li> </ul>"},{"location":"Tests/tests/#test","title":"Test","text":"<p>D\u00e9finition (norme IEEE 729) : Le test est un processus manuel ou  automatique, qui vise \u00e0 \u00e9tablir qu\u2019un syst\u00e8me v\u00e9rifie les propri\u00e9t\u00e9s  exig\u00e9es par sa sp\u00e9cification, ou \u00e0 d\u00e9tecter des di\ufb00\u00e9rences entre les  r\u00e9sultats engendr\u00e9s par le syst\u00e8me et ceux qui sont attendus par la  sp\u00e9cification.  </p> <p>Le test ne se pr\u00e9occupe pas des erreurs. Ce n\u2019est pas au testeur de pointer les imperfections humaines.  </p> <p>Le test met en \u00e9vidence les d\u00e9fauts afin de pr\u00e9venir les d\u00e9faillances.  </p>"},{"location":"Tests/tests/#tests-en-general","title":"Tests en g\u00e9n\u00e9ral","text":"<p>Toute fabrication de produit suit les \u00e9tapes suivantes  </p> <ol> <li>Conception</li> <li>R\u00e9alisation</li> <li>Tests  </li> </ol> <p>Test : On s\u2019assure que le produit final correspond \u00e0 ce qui a \u00e9t\u00e9  demand\u00e9 selon divers crit\u00e8res :  </p> <ul> <li>esth\u00e9tique</li> <li>performance</li> <li>ergonomie</li> <li>fonctionnalit\u00e9</li> <li>robustesse etc.  </li> </ul> <p>Des Bogues aux cons\u00e9quences d\u00e9sastreuses</p> <ul> <li> <p>Su\u00e8de - 1980 :  776 millions d'euros (275 millions de dollars de 1980). 104 camions semi-remorques de 35 tonnes, c'est la cargaison que le Zenobia emporta par le fond lors de son naufrage, 1 mois seulement apr\u00e8s son lancement inaugural. Pourquoi ? Un bug dans le logiciel de contr\u00f4le des ballasts surremplissait les r\u00e9servoirs par rapport aux indications qui lui \u00e9taient envoy\u00e9es.</p> </li> <li> <p>EADS - 1996 : 266 millions d'euros (200 millions d'euros de 1996) Le 4 juin 1996 (1er vol), la fus\u00e9e Ariane 5 s'est \u00e9lev\u00e9e jusqu'\u00e0 la moiti\u00e9 du ciel, avant que son logiciel ne coupe les moteurs et que le lanceur explose en plein vol. Pourquoi ? L'acc\u00e9l\u00e9ration maximale de la fus\u00e9e a d\u00e9pass\u00e9 la valeur admissible par le logiciel, g\u00e9n\u00e9rant une erreur g\u00e9n\u00e9rale et donc l'autodestruction. Valeurs recopi\u00e9es du programme Ariane 4 (moins puissante). La simulation avait \u00e9t\u00e9 annul\u00e9e afin d'\u00e9conomiser 800.000 francs (11900\u0152euros).</p> </li> </ul>"},{"location":"Tests/tests/#cout-des-tests","title":"Co\u00fbt des tests","text":"<ul> <li>Budget IT : Budget allou\u00e9 aux technologies de l'information (ou IT pour Information Technology).</li> <li>Dans les entreprises, la part du budget IT consacr\u00e9e aux tests et \u00e0 l'assurance qualit\u00e9 augmente de 9 points d'une ann\u00e9e sur l'autre selon Capgemini.</li> <li>De 26% en 2014, elle passe \u00e0 35 % en 2015.</li> <li>Il \u00e9tait pr\u00e9vu qu'en 2018, la part des tests et de la qualit\u00e9 passe \u00e0 40 % du total. (Source Silicon)</li> </ul>"},{"location":"Tests/tests/#vvt","title":"VVT","text":"<p>Validation, V\u00e9rification et Test logiciel.</p> <p>D\u00e9monstration automatique (Hum !) : exhaustive mais consid\u00e9r\u00e9e  comme trop co\u00fbteuse.  </p> <p>Model Checking : v\u00e9rifier si le mod\u00e8le d\u2019un syst\u00e8me satisfait une  propri\u00e9t\u00e9. Par exemple, on souhaite v\u00e9rifier qu\u2019un programme ne se  bloque pas, qu\u2019une variable n\u2019est jamais nulle, etc. G\u00e9n\u00e9ralement, la  propri\u00e9t\u00e9 est \u00e9crite dans un langage, souvent en logique temporelle.  La v\u00e9rification est g\u00e9n\u00e9ralement faite de mani\u00e8re automatique.  </p> <p>Test : non exhaustif mais facile \u00e0 mettre en \u0153uvre (bon rapport  qualit\u00e9/temps).  </p>"},{"location":"Tests/tests/#cycle-en-v","title":"Cycle en V","text":"<p>Le test commence d\u00e8s le d\u00e9but !  </p> <p></p> <p>Figure \u2013 Le cycle en V du G\u00e9nie Logiciel (d\u2019apr\u00e8s Irif)</p>"},{"location":"Tests/tests/#classification","title":"Classification","text":""},{"location":"Tests/tests/#selon-le-niveau-au-cycle-de-developpement","title":"Selon le niveau au cycle de d\u00e9veloppement","text":"<ul> <li>Tests de recette : test de r\u00e9ception du logiciel chez le client final  </li> <li>Tests int\u00e9gration syst\u00e8me : test de l\u2019int\u00e9gration du logiciel avec  d\u2019autres logiciels  </li> <li>Tests systeme : test d\u2019acception du logiciel avant livraison (nouvelle  version par exemple). G\u00e9n\u00e9ralement e\ufb00ectu\u00e9 par le client dans ses  locaux apr\u00e8s installation du syst\u00e8me ou d\u2019une unit\u00e9 fonctionnelle, avec  la participation du fournisseur.  </li> <li>Tests Integration : test de l\u2019int\u00e9gration des di\ufb00\u00e9rents composants  (avec ou sans hardware)  </li> <li>\\(\\color{red}\\text{Tests Unitaires : tests \u00e9l\u00e9mentaires des composants logiciels (une  fonction, un module, ...)  }\\)</li> </ul>"},{"location":"Tests/tests/#selon-la-caracteristique","title":"Selon la caract\u00e9ristique","text":"<ul> <li>$\\color{red}\\text{Tests fonctionnels : destin\u00e9s \u00e0 s\u2019assurer que, dans le contexte d\u2019utilisation r\u00e9elle, le comportement fonctionnel obtenu est bien  conforme avec celui attendu.}</li> <li>Tests de performance (rapidit\u00e9, consommation m\u00e9moire etc.)  </li> <li>Tests de robustesse (mon serveur va-t-il bien r\u00e9agir \u00e0 un a\ufb04ux de  connexion ?)  </li> <li>Tests de vuln\u00e9rabilit\u00e9 : suis-je bien prot\u00e9g\u00e9 face aux risques  d\u2019intrusions ?  </li> </ul>"},{"location":"Tests/tests/#selon-le-niveau-daccessibilite","title":"Selon le niveau d\u2019accessibilit\u00e9","text":"<ul> <li>Tests de type bo\u00eete noire : technique de conception de test,  fonctionnel ou non, qui n\u2019est pas fond\u00e9e sur l\u2019analyse de la structure  interne du composant ou du syst\u00e8me mais sur la d\u00e9finition du  composant ou du syst\u00e8me.  </li> <li>Tests de type bo\u00eete blanche : technique de conception de test, en  g\u00e9n\u00e9ral fonctionnel, fond\u00e9e sur l\u2019analyse de la structure interne du  composant ou du syst\u00e8me.  </li> </ul> <p>Pour comparer les deux.</p>"},{"location":"Tests/tests/#divers","title":"Divers","text":"<p>Tests de non-r\u00e9gression : \u00e0 la suite de la modification d\u2019un logiciel (ou  d\u2019un de ses constituants), un test de r\u00e9gression a pour but de montrer que  les autres parties du logiciel n\u2019ont pas \u00e9t\u00e9 a\ufb00ect\u00e9es par cette modification.  </p>"},{"location":"Tests/tests/#en-cpge","title":"En CPGE","text":"<ul> <li>Tests unitaires en g\u00e9n\u00e9ral bo\u00eete blanche et fonctionnels.  </li> <li>Moyen : pour tout exercice, cr\u00e9er un fichier ou une fonction de tests.  </li> <li>Rendu de projets : les tests sont imp\u00e9ratifs.  </li> </ul>"},{"location":"Tests/tests/#copmlementarite-des-tests-fonctionnels-et-structurels","title":"Copml\u00e9mentarit\u00e9 des tests fonctionnels et structurels","text":"<p>En examinant ce qui a \u00e9t\u00e9 r\u00e9alis\u00e9, on ne prend pas forc\u00e9ment en compte ce qui aurait du \u00eatre fait</p> <ul> <li>Les approches structurelles (bo\u00eete blanche) d\u00e9tectent plus facilement les erreurs commises</li> <li>Les approches fonctionnelles (bo\u00eete noire) d\u00e9tectent plus facilement les erreurs d\u2019omission</li> </ul>"},{"location":"Tests/tests/#partitionnement-limite","title":"Partitionnement, limite","text":""},{"location":"Tests/tests/#partitionnement-du-domaine-dentree","title":"Partitionnement du domaine d\u2019entr\u00e9e","text":"<ul> <li>Il s\u2019agit de r\u00e9partir les donn\u00e9es en un nombre fini de classes  d\u2019\u00e9quivalence, sans restreindre le degr\u00e9 d\u2019exigence. Cette m\u00e9thode est  g\u00e9n\u00e9ralement utilis\u00e9e pour r\u00e9duire le nombre total de cas de test \u00e0 un  ensemble fini.  </li> <li>Exemple : test d\u2019une zone de saisie attendant des nombres de \\(1\\) \u00e0 \\(1000\\).  </li> <li>Classe des donn\u00e9es valides d\u2019entr\u00e9e : s\u00e9lectionner un (ou quelques)  nombre.s dans \\([\\![ 2, 99]\\!]\\) (exemple : \\(50\\) et \\(800\\)).  </li> <li>Classe des donn\u00e9es inf\u00e9rieure \u00e0 \\(0\\) : s\u00e9lectionner un ou plusieurs nombres  n\u00e9gatifs (\\(-1\\) et \\(-100\\) par exemple).  </li> <li>Classe des donn\u00e9es sup\u00e9rieures \u00e0 \\(1001\\) : choisir \\(1050\\) et \\(2300\\) par  exemple.  </li> </ul>"},{"location":"Tests/tests/#tests-aux-limites","title":"Tests aux limites","text":""},{"location":"Tests/tests/#test-dune-zone-de-saisie-attendant-des-nombres-de-1-a-1000","title":"Test d\u2019une zone de saisie attendant des nombres de 1 \u00e0 1000","text":"<p>En compl\u00e9ment du partitionnement du domaine d\u2019entr\u00e9e, on ajoute les  tests aux limites</p> <ul> <li>Ce sont les donn\u00e9es encore valides mais au del\u00e0 desquelles les entr\u00e9es  ne le sont plus.  </li> <li>Il faut imp\u00e9rativement tester \\(1\\) et \\(1000\\). On peut y ajouter les valeurs  </li> <li>juste en dessous des bornes : \\(0\\) et \\(999\\) </li> <li>juste au-dessus des bornes : \\(2\\) et \\(1001\\) </li> <li>Si un des tests ne donne pas le r\u00e9sutat attendu, le programme n\u2019est  pas correct. En revanche, le programme peut \u00eatre incorrect m\u00eame si  tous les tests du sc\u00e9nario donnent satisfaction.  </li> </ul>"},{"location":"Tests/tests/#graphe-de-flots-de-controle","title":"Graphe de flots de contr\u00f4le","text":""},{"location":"Tests/tests/#rappel-tests-unitaires-tests-fonctionnels","title":"Rappel : Tests unitaires ; tests fonctionnels","text":"<p>En CPGE on s'int\u00e9resse uniquement aux \\(\\color{red}\\text{Test Unitaires : tests \u00e9l\u00e9mentaires des composants logiciels (une fonction, un module, ...)}\\);</p> <p>La plupart des tests que nous avons \u00e9crits jusqu\u2019\u00e0 pr\u00e9sent \u00e9taient des \\(\\color{red}\\text{Tests fonctionnels (\"bo\u00eete noire\") : destin\u00e9s \u00e0 s\u2019assurer que, dans le contexte d\u2019utilisation r\u00e9elle, le comportement fonctionnel obtenu est bien conforme avec celui attendu}\\). On cr\u00e9e des tests sans ce soucier du code \u00e9crit.</p>"},{"location":"Tests/tests/#tests-structurels","title":"Tests structurels","text":"<p>dits aussi tests bo\u00eete blanche</p> <ul> <li>S\u00e9lection de tests \u00e0 partir de l\u2019analyse du code source du syst\u00e8me  </li> <li>Constructions des tests uniquement pour du code d\u00e9j\u00e0 \u00e9crit.  </li> </ul> <p></p>"},{"location":"Tests/tests/#test-structurel","title":"Test structurel","text":"<ul> <li>Utiliser la structure du code pour d\u00e9river des cas de tests.  </li> <li>Compl\u00e9mentaire des tests fonctionnels car on \u00e9tudie la r\u00e9alisation et  pas seulement la sp\u00e9cification.  </li> <li>Il y a deux m\u00e9thodes :  <ul> <li>\u00c0 partir du graphe de \ufb02ot de contr\u00f4le : couverture de toutes les  instructions, tous les branchements... (CPGE)  </li> <li>\u00c0 partir du graphe de \ufb02ot de donn\u00e9es : couverture de toutes les  utilisations d\u2019une variable, de tous les couples d\u00e9finition-utilisation...  </li> </ul> </li> </ul>"},{"location":"Tests/tests/#graphe-de-flot-de-controle","title":"Graphe de \ufb02ot de contr\u00f4le","text":"<p>Graphe simple orient\u00e9 connexe avec un sommet initial (ou d\u2019entr\u00e9e) <code>E</code> et un sommet de sortie <code>S</code> accessible depuis <code>E</code>.</p> <ul> <li>Un sommet interne est  </li> <li>Soit un bloc d\u2019instructions \u00e9l\u00e9mentaires (on regroupe les s\u00e9quences).  </li> <li>Soit un sommet de d\u00e9cision \u00e9tiquet\u00e9 par un test.  </li> <li>Il y a deux sortes d\u2019arcs :  </li> <li>Les arcs de sortie de blocs d\u2019instructions : ils repr\u00e9sentent le passage  d\u2019un bloc d\u2019instructions \u00e0 une instruction conditionnelle ou \u00e0 un autre  bloc d\u2019instruction. Il ne sont pas \u00e9tiquet\u00e9s.  </li> <li>Les arcs de d\u00e9cision : ce sont les arcs de sortie des sommets de d\u00e9cision.  Ils sont \u00e9tiquet\u00e9s par les r\u00e9ponses aux tests des expressions  conditionnelles.  </li> </ul> <p>Il y a un seul arc de sortie d\u2019un sommet bloc d\u2019instructions. Et, le plus  souvent, deux arcs de sortie (dits arcs de d\u00e9cision) des sommets de d\u00e9cision correspondant aux valeurs positives ou n\u00e9gatives des conditions.  </p>"},{"location":"Tests/tests/#exemple-calcul-de-x_n","title":"Exemple : calcul de \\(X_n\\)","text":"<pre><code>float power (float x, int n){\n    int p = n ; float s = 1.;\n    while(p&gt;=l){\n        s=s*x;\n        p=p-1;\n    }\n    return s;\n}\n</code></pre>"},{"location":"Tests/tests/#exemple-des-triangles","title":"Exemple des triangles","text":"<pre><code>void triangle (int j, int k, int l) {\n    // j, k, l : les 3 c\u00f4t\u00e9s d'un triangle\n    // indique si le triangle est quelconque,\n    // isoc\u00e8le ou \u00e9quilat\u00e9ral\n    int n = 0; // n pour 'nature du triangle\n    if (j+k&lt;=l || k+l &lt;= j || l+j &lt;= k) {\n        printf(\"pas un triangle\");\n    } else {\n        if (j==k) n = n+1;\n        if (j==l) n = n+1;\n        if (l==k) n = n+1;\n        if (n==0)\n            printf(\"quelconque\");\n        else if (n==1)\n            printf(\"isoc\u00e8le\");\n        else\n            printf(\"\u00e9quilat\u00e9ral\");\n    }\n}\n</code></pre> <p>Avec \\(T\\) pour True et \\(F\\) pour False</p>"},{"location":"Tests/tests/#chemin-faisable","title":"Chemin faisable","text":"<p>Un chemin de contr\u00f4le est une suite \\(x_0, x_1, . . . , x_n\\) de sommets tels que \\(x_0 = E\\) , \\(x_n = S\\) et \\((x_i , x_{i+1})\\) est un arc pour tout \\(i &lt; n\\).  </p> <p>Un chemin est dit faisable si il existe un ensemble de conditions sur les variables d\u2019entr\u00e9es permettant de passer par tous les sommets de ce chemin.</p> <p>Si un chemin n\u2019est pas faisable, il est dit infaisable. La recherche de infaisable est ind\u00e9cidable : on ne sait pas en entr\u00e9e un GFC quelconque, dire dans tous les cas s'il existe un chemin infaisable.</p> Exemple des triangles <p><p></p> Figure - Chemin faisable <p></p> Figure - Chemin infaisable</p>"},{"location":"Tests/tests/#condition-dun-chemin","title":"Condition d\u2019un chemin","text":"<p>La condition d\u2019un chemin est la conjonction de tous les sommets de d\u00e9cision portant sur les entr\u00e9es que traverse ce chemin.  </p> <p>Exemple : avec \\(j = 3, k = 5, l = 3\\), la condition du chemin vert  parcouru est  </p> \\[\u00ac(j +k \u2264 l \u2228k +l \u2264 j \u2228j +l \u2264 k)\u2227j \\neq k \u2227 j = l \u2227 l \\neq k \u2227 n \\neq 0 \u2227 n = 1\\] <p>La condition du chemin rouge est  </p> \\[\u00ac(j + k \u2264 l \u2228 k + l \u2264 j \u2228 j + l \u2264 k) \u2227 j \\neq k \u2227 j \\neq l \u2227 l \\neq k \u2227 n \\neq 0 \u2227 n \\neq 1\\] <p>Or  </p> \\[\u00ac(j + k \u2264 l \u2228 k + l \u2264 j \u2228 j + l \u2264 k) \u2227 j \\neq k \u2227 j \\neq l \u2227 l \\neq k \\Rightarrow n = 0\\] <p>Et donc la condition du chemin rouge est  </p> \\[\u00ac(j +k \u2264 l \u2228k +l \u2264 j \u2228j +l \u2264 k)\u2227j \\neq k \u2227j \\neq l \u2227l \\neq k \u2227 {\\color{red}0\\neq 0} \u2227 0 \\neq 1\\] <p>Cette formule est une antilogie : le chemin est rouge est infaisable.  </p>"},{"location":"Tests/tests/#indecidabilite-de-la-recherche-de-chemins-infaisables","title":"Ind\u00e9cidabilit\u00e9 de la recherche de chemins infaisables","text":"<pre><code>void syracuse(int x) {\n    // on ne consid\u00e8re que des entiers &gt; 0\n    while (x!=1){\n        if (x%2==0)\n            x=x/2;\n        else\n            x=3*x+1;\n    }\n    printf(\" fini\\n\");\n</code></pre> <p>La conjecture veut que au bout d\u2019un moment \\(x = 1\\).  </p> <p></p> <p>On ne sait pas s\u2019il existe des chemins infaisables de \\(E\\) \u00e0 \\(S\\).  </p>"},{"location":"Tests/tests/#syracuse-la-discipline-de-test-dt-x2-sensibilise-le-chemin-c","title":"Syracuse : La discipline de test (DT) \\(x=2\\) sensibilise le chemin C","text":"<p>Etant donn\u00e9 un chemin faisable, on sait trouver les conditions pour le  parcourir.</p> <p></p> <ul> <li>soit le chemin \\(C\\) : \\(E\\), \\(x \u2260 1\\), \\(x\\text{ \\% } 2==0\\),   \\(x= \\frac{x}{2}\\),   \\(x \u2260 1\\), \\(S\\).</li> </ul> <p>Quelle condition le  v\u00e9rifie ?  </p> <ul> <li>\\(x \\neq 1\\) \\(x \\text{ mod } 2 = 0\\) : \\(x\\) est pair \\(\\frac{x}{2} = 1\\) </li> </ul> <p>On trouve \\(x = 2\\).  </p>"},{"location":"Tests/tests/#critere-de-couverture","title":"Crit\u00e8re de couverture","text":"<p>On appelle crit\u00e8re de couverture une condition d\u00e9finissant un  ensemble de chemins du graphe de \ufb02ot de contr\u00f4le.  </p> <p>G\u00e9n\u00e9ration de tests gr\u00e2ce \u00e0 un crit\u00e8re de couverture :  </p> <ul> <li>S\u00e9lectionner un ensemble minimal de chemins satisfaisant le crit\u00e8re.  </li> <li>Eliminer les chemins infaisables  </li> <li>Pour chaque chemin faisable, on d\u00e9finit un ensemble de conditions associ\u00e9es sur les entr\u00e9es (c\u2019est \u00e0 dire un objectif de test). \\(\\color{red}\\text{Par exemple : entr\u00e9e }x &gt; 0\\)</li> <li>Pour chaque objectif de test (donc pour chaque chemin faisable) choisir un cas de test (donc des valeurs d\u2019entr\u00e9es satisfaisant la condition associ\u00e9e au chemin). \\(\\color{red}\\text{Par exemple : entr\u00e9e }x = 3\\)</li> </ul>"},{"location":"Tests/tests/#critere-tous-les-sommets","title":"Crit\u00e8re \"tous les sommets\"","text":"<p>Crit\u00e8re atteint lorsque tous les sommets du graphe de contr\u00f4le sont  parcourus.  </p> <p>On d\u00e9finit le taux de couverture des sommets par  </p> \\[ \\tau_s = \\frac{\\text{nombre de sommets parcourus}}{\\text{nombre de sommets}}\\] <p>Exigence minimale pour la certification en a\u00e9ronautique (norme EUROCAE ED-12B) : \\(\\tau_s = 1\\).  </p> <p>Qualification niveau C : Un d\u00e9faut peut provoquer un probl\u00e8me majeur entra\u00eenant un dysfonctionnement des \u00e9quipements vitaux de l\u2019appareil.  </p> <pre><code>int somme (int x, int y){\n    int s = 0;\n    if (x==0) s=x;\n    else s=x+y;\n    return s;\n}\n</code></pre> <p>Il y a deux chemins. L\u2019un  d\u2019eux permet de d\u00e9tecter  le d\u00e9faut.  </p> <p></p> <p>Le chemin \\(E\\) ; \\(int\\) \\(s=0\\) ; \\(x==0\\) ; \\(s=x\\) ; \\(return\\) \\(s\\) ; \\(S\\) est associ\u00e9e \u00e0 la condition \\(x = 0\\)  satisfaite par les entr\u00e9es  \\(x = 0\\), \\(y = 6\\). Cela permet de d\u00e9tecter le d\u00e9faut.  </p>"},{"location":"Tests/tests/#limite-du-critere-tous-les-sommets","title":"Limite du crit\u00e8re \"tous les sommets\"","text":"<pre><code>float div(float x){\n    float r;\n    if (x!=0) \n        r=1.;\n    r = 1/x;\n    return r;\n}\n</code></pre> <p>Le chemin \\(E\\) ; \\(int\\) \\(r\\) ; \\(x\u22600\\) ; \\(r=1\\) ; \\(return\\) \\(r\\); \\(S\\)  (associ\u00e9 \u00e0 \\(x = 2\\)) couvre bien tous les sommets mais la division par z\u00e9ro n\u2019est pas d\u00e9tect\u00e9e.  </p>"},{"location":"Tests/tests/#critere-tous-les-arcs","title":"Crit\u00e8re \"Tous les arcs\"","text":"<p>Dit aussi crit\u00e8re \"toutes les d\u00e9cisions\".  </p> <p>Pour chaque d\u00e9cision, un test rend la d\u00e9cision vraie, un autre la rend  fausse.  </p> <p>Taux de courverture des arcs :</p> \\[\\tau_a = \\frac{\\text{nombre d\u2019arcs parcourus}}{\\text{nombre d\u2019arcs}}\\] <p>Norme DO 178B, qualification des syst\u00e8mes embarqu\u00e9s au niveau B :  un d\u00e9faut peut provoquer un probl\u00e8me dangereux</p> <p>Crit\u00e8re \"Tous-les-arcs\" entra\u00eene crit\u00e8re \"Tous-les-sommets\".(puisque le graphe est connexe, chaque sommet est adjacent \u00e0 un arc au moins).</p>"},{"location":"Tests/tests/#limite-du-critere-tous-les-arcs","title":"Limite du crit\u00e8re tous les arcs","text":"<pre><code>float F(int a, int b){\n    int r;\n    if (a!=0 || a==b) \n        r=1/a;\n    else \n        r=0;\n    return r;\n}\n</code></pre> <p>Crit\u00e8re Toutes-les-D\u00e9cisions  satisfait avec \\(\\{a = 0,b = 1\\}\\) \\(et\\) \\(\\{a = 2, b = 1\\}\\).  </p> <p>Pourtant, division par z\u00e9ro non d\u00e9tect\u00e9e avec \\(\\{a = 0,b = 0\\}\\).  </p>"},{"location":"Tests/tests/#decomposer-les-conditionnelles","title":"D\u00e9composer les conditionnelles","text":""},{"location":"Tests/tests/#toutes-les-conditions-multiples","title":"Toutes les conditions multiples","text":"<p>On a vu que le crit\u00e8re \"tous les arcs\" pouvait passer \u00e0 c\u00f4t\u00e9  d\u2019erreurs.  </p> <p>C\u2019est parce que ce crit\u00e8re est satisfait pour un sommet de d\u00e9cision  avec seulement deux jeux d\u2019entr\u00e9es : un jeu d\u2019entr\u00e9es rendant la  d\u00e9cision vraie et un autre la rendant fausse.  </p> <p>Plut\u00f4t que la consid\u00e9rer la d\u00e9cision comme un seul sommet du graphe  de contr\u00f4le, on introduit les sous-decisions comme nouveaux sommets.  </p> <p>Ce crit\u00e8re est appel\u00e9 \"toutes les conditions multiples\"  </p> <p>Le crit\u00e8re  Toutes-les-d\u00e9cisions  n\u2019est plus satisfait  avec seulement \\(\\{a = 0,b = 1\\}\\) \\(et\\) \\(\\{a = 2, b = 1\\}\\).  </p> <p>Le crit\u00e8re  Toutes-les-d\u00e9cisions  est satisfait avec  \\(\\{a = 0,b = 1\\}\\) \\(et\\) \\(\\{a = 2, b = 1\\}\\) \\(et\\) \\(\\{a = 2, b = 2\\}\\) et enfin \\(\\{a = 0,b = 0\\}\\). Division par z\u00e9ro d\u00e9tect\u00e9e.  </p> <p><p></p></p> <p>Le graphe simple devient un  multigraphe (deux arcs sortant  du \\(a==b\\) de gauche vers \\(\\frac{1}{a}\\) ).  </p>"},{"location":"Tests/tests/#critere-toutes-les-decisions-multiples-explosion-combinatoire","title":"Crit\u00e8re \"Toutes les d\u00e9cisions multiples\" : Explosion combinatoire","text":"<p>Exemple <code>if (A &amp;&amp; (B || C))</code> </p> <p>Toutes-les-conditions  </p> \\[\\begin{array}{|c c c | c |} A &amp; B &amp; C &amp; \\text{D\u00e9cision} \\\\ \\hline 0 &amp; 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 \\\\ \\end{array}\\] <p>Toutes-les-conditions-multiples</p> \\[\\begin{array}{|c c c | c |} A &amp; B &amp; C &amp; \\text{D\u00e9cision} \\\\ \\hline 1 &amp; 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 0 &amp; 1 \\\\ 1 &amp; 0 &amp; 1 &amp; 1 \\\\ 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \\end{array}\\] <p>\\(2^{\\text{nb de variables }}\\): Comment limiter la  combinatoire ?  </p>"},{"location":"Tests/tests/#critere-toutes-les-conditionsdecisions-modifie-mcdc","title":"Crit\u00e8re Toutes-les-Conditions/D\u00e9cisions-modifi\u00e9 : MC/DC","text":"<p>Objectif : am\u00e9liorer les crit\u00e8res de couverture bas\u00e9s sur les d\u00e9cisions  tout en contr\u00f4lant la combinatoire  </p> <p>D\u00e9finition: Crit\u00e8re MC/DC</p> <p>MC/DC : Modified Condition/Decision Coverage</p> <p>On ne s\u2019int\u00e9resse \u00e0 un jeu de test faisant varier une condition que s\u2019il  in\ufb02ue sur la d\u00e9cision.  </p>"},{"location":"Tests/tests/#critere-mcdc","title":"Crit\u00e8re MC/DC","text":"<p>Exemple <code>if (A &amp;&amp; (B || C))</code></p> <p>Principe : pour chaque test atomique, trouver deux cas de tests qui  changent la d\u00e9cision lorsque les autres conditions sont fix\u00e9es.  </p> <ul> <li>Pour \\(A\\) :  <ul> <li>\\(A = 0\\) , \\(B = 1\\) , \\(C = 1\\). D\u00e9cision : \\(0\\) </li> <li>\\(A = 1\\) , \\(B = 1\\) , \\(C = 1\\). D\u00e9cision : \\(1\\) </li> </ul> </li> <li>Pour \\(B\\) :  <ul> <li>\\(A = 1\\) , \\(B = 0\\) , \\(C = 0.\\) D\u00e9cision : \\(0\\) </li> <li>\\(A = 1\\) , \\(B = 1\\) , \\(C = 0.\\) D\u00e9cision : \\(1\\) </li> </ul> </li> <li>Pour \\(C\\) :  <ul> <li>\\(A = 1\\) , \\(B = 0\\) , \\(C = 1.\\) D\u00e9cision : \\(1\\) </li> <li>\\(A = 1\\) , \\(B = 0\\) , \\(C = 0.\\) D\u00e9cision : \\(0\\). D\u00e9j\u00e0 couvert.  </li> </ul> </li> </ul> <p>Si \\(n\\) conditions : crit\u00e8re \\(MC/DC\\) entra\u00eene au plus \\(2 \u00d7 n\\) tests contre  \\(2^n\\) pour le crit\u00e8re Toutes-les-d\u00e9cisions-multiple.  </p>"},{"location":"Tests/tests/#limite-du-critere-toutes-les-decisions-multiples","title":"Limite du crit\u00e8re Toutes-les-d\u00e9cisions-multiples","text":"<pre><code>float invsum(int n, float a[]){\n    int i = 0;\n    float s = 0;\n    while(i&lt;n){\n        s = s+a[i];\n        i++;\n    }\n    return 1/s;\n}\n</code></pre> <p>Toutes-les-d\u00e9cisions \\(=\\) toutes-les-d\u00e9cisions-multiples Puisque test atomique</p> <p></p> <p>\\(\\color{red}\\textbf{E,B1,C1,B2,C1,ret. }\\frac 1 s\\textbf{ , S}\\text{ couvre toutes les d\u00e9cisions.}\\) \\(\\color{red}\\text{Satisfait par } n = 1,  a = \\{2., 3., 5.\\}.\\) \\(\\color{red}\\text{D\u00e9faut non  d\u00e9tect\u00e9 si le tableau est vide.}\\)</p>"},{"location":"Tests/tests/#critere-tous-les-chemins","title":"Crit\u00e8re \"tous les chemins\"","text":"<p>D\u00e9finition: Crit\u00e8re Tous-les-chemins</p> <p>parcourir tous les arcs dans chaque configuration possible (et non pas au moins une fois comme dans le  crit\u00e8re toutes-les-d\u00e9cisions)  </p> <p>Impraticable d\u00e8s qu\u2019il y a des boucles car existence de chemins infinis.  </p> <p>A\ufb00aiblissement possible : \"tous les chemins qui passent au plus \\(k\\) fois dans les boucles\"</p> <p>En pratique on se limite souvent aux cas \\(k = 1\\) ou \\(k = 2\\). Cela permet au moins de d\u00e9tecter les erreurs produites quand on ne rentre pas dans la/les boucle.s.  </p> <p>Dans l\u2019exemple pr\u00e9c\u00e9dent, \\(n = 1\\), \\(a = \\{\\}\\) satisfait le chemin  \\(\\textbf{E,B1,C1,ret. }\\frac 1 s\\textbf{ , S}\\) et d\u00e9tecte la division par z\u00e9ro.  </p>"},{"location":"Tests/tests/#hierarchie-des-criteres","title":"Hi\u00e9rarchie des crit\u00e8res","text":""},{"location":"Tests/tests/#convention-de-notation-algebrique","title":"Convention de notation alg\u00e9brique","text":"<ul> <li>\\(\u03b5\\) pour \"chemin vide\"  </li> <li>\\(A \u00b7 B\\) ou \\(AB\\) pour \"\\(A\\) suivi de \\(B\\)\"  </li> <li>\\((CB)^3\\) pour \"\\(CBCBCB\\)\"  </li> <li>\\(A + B\\) pour \"\\(A ou B\\)\"  </li> <li>\\(A^{+}\\) pour \"\\(A + A^2 + A^3 + \u00b7 \u00b7 \u00b7 + A^n + . . .\\)\"  </li> <li>\\(A^{\u2217}\\) pour \"\\(\u03b5 + A + A^2 + A^3 + \u00b7 \u00b7 \u00b7 + A^n + . . .\\)\"  </li> <li>\\(A^{\\underline{4}}\\) pour \\(\u03b5 + A + A^2 + A^3 + A^4\\)</li> </ul>"},{"location":"Tests/tests/#expression-des-chemins-sous-forme-algebrique","title":"Expression des chemins sous forme alg\u00e9brique","text":"<pre><code>void F(int x){\n    if (x &lt;= 0)\n        x = -x;\n    else\n        x = 1 + x;\n\n    if (x==1)\n        x=1-x;\n    else\n        x=1;\n    return x;\n}\n</code></pre> <ul> <li>Les chemins de contr\u00f4le possibles sont d\u00e9crits par</li> </ul> \\[IA(B+C)D(E+F)GO\\] <ul> <li>Le nombre de chemins de contr\u00f4le possible est \\(1 \u00b7 1 \u00b7(1+1)\u00b7 1 \u00b7(1+1)\u00b7 1 = 4\\)</li> </ul>"},{"location":"Textes/lzw/","title":"lzw","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"Textes/lzw/#credits","title":"Cr\u00e9dits","text":"<p>Un cours de Marc de Falco. Wikipedia Informatique -Cours et exercices corrig\u00e9s- (MP2I-MPI) (ellipse)  </p>"},{"location":"Textes/lzw/#compression","title":"Compression","text":""},{"location":"Textes/lzw/#presentation","title":"Pr\u00e9sentation","text":"<p>L\u2019algorithme de Lempel-Ziv-Welch (LZW)est un algorithme de  compression de donn\u00e9es sans perte. Ses inventeurs sont Abraham Lempel, Jakob Ziv qui l\u2019ont propos\u00e9 en  1977 et Terry Welch qui l\u2019a finalis\u00e9 en 1984. LZW a \u00e9t\u00e9 utilis\u00e9 dans des modems aujourd\u2019hui obsol\u00e8tes mais on le  trouve encore dans la compression des images \"GIFF\" ou  \"TIFF\" et les fichiers audio \"MOD\". Il est \u00e0 la base de la  compression \"ZIP\". Facile \u00e0 coder (c\u2019est son principal avantage) il n\u2019est souvent pas  optimal car il n\u2019e\ufb00ectue qu\u2019une analyse sommaire des donn\u00e9es \u00e0  compresser.  </p>"},{"location":"Textes/lzw/#principe","title":"Principe","text":"<p>Recherche dans le texte \u00e0 compresser des r\u00e9p\u00e9titions de sous-cha\u00eenes  identiques et leur donner une forme compacte dans le texte  compress\u00e9. L\u2019algorithme LZW proc\u00e8de en une seule passe, en maintenant, au fur  et \u00e0 mesure de la compression, l\u2019ensemble des factiers qu\u2019il a d\u00e9j\u00e0  rencontr\u00e9s. Cette caract\u00e9ristique est adapt\u00e9e \u00e0 la compression d\u2019un texte qu\u2019on  d\u00e9couvre \u00e0 la vol\u00e9e comme lorsque le texte est transmis via un canal  de communication.  </p>"},{"location":"Textes/lzw/#prefixe-suffixe","title":"Pr\u00e9fixe, su\ufb03xe","text":"<p>D\u00e9finition : Pr\u00e9fixe / Suffixe</p> <ul> <li>Le mot x est appel\u00e9 un pr\u00e9fixe du mot m si il existe un mot y tel que  m = x \u00b7 y .  </li> <li>Le mot x est appel\u00e9 un su\ufb03xe du mot m si il existe un mot y tel que  m = y \u00b7 x.  </li> </ul> <p>Exemple</p> <ul> <li>\\(\\varepsilon\\), langage et lang sont des pr\u00e9fixes de langage,  </li> <li>\\(\\varepsilon\\), langage et gage sont des su\ufb03xes de langage,  </li> <li>Si xu = m et xv = m alors, par r\u00e9gularit\u00e9, u = v .  </li> </ul>"},{"location":"Textes/lzw/#facteurs","title":"Facteurs","text":"<p>D\u00e9finition : facteur</p> <p>On dit qu\u2019un mot x est facteur d\u2019un mot m s\u2019il existe u, v , deux mots tels que m = uxv .</p> <p>Exemple</p> <p>Le mot sol est facteur de insolent. La cha\u00eene vide \\(\\varepsilon\\) est un pr\u00e9fixe de tout mot.</p> <p>Pour plus d\u2019informations sur la th\u00e9orie des mots, voir par exemple ce cours.  </p>"},{"location":"Textes/lzw/#table-des-correspondances-facteursencodage","title":"Table des correspondances facteurs/encodage","text":"<p>L\u2019algorithme de compression construit une table de traduction des  facteurs du texte en parcourant le texte \u00e0 compresser.  Cette table relie des codes de taille (le plus souvent) fix\u00e9e  (g\u00e9n\u00e9ralement \u00e0 12 bits) aux cha\u00eenes de caract\u00e8res. Certaines  impl\u00e9mentations avec taille d\u2019encodage variable existent aussi. La table est initialis\u00e9e avec tous les caract\u00e8res (256 entr\u00e9es dans le  cas de caract\u00e8res cod\u00e9s sur 8 bits). C\u2019est une injection qui associe une  valeur num\u00e9rique \u00e0 tout caract\u00e8re de l\u2019alphabet. Il est malin d\u2019utiliser un dictionnaire (facteur, encodage). Les seules  cl\u00e9s du dictionnaires qui ne sont pas des facteurs du texte sont les  caract\u00e8res de l\u2019alphabet non utilis\u00e9s par le texte. L\u2019algorithme LZW exploite et modifie \u00e0 la vol\u00e9e le dictionnaire des  facteurs. Il renvoie une liste de cl\u00e9s de ce dictionnaire (c\u2019est \u00e0 dire une  liste d\u2019entiers), chacune codant un facteur du texte.  </p>"},{"location":"Textes/lzw/#algorithme","title":"Algorithme","text":"<pre><code>/\u2217L\u2019alphabet \u03a3 est suppos\u00e9 connu \u2217/\nfonction lzw_compress (t : texte):\n    initialiser d avec \u03a3 /\u2217 dictionnaire(facteur, code) \u2217/\n    w \u2190 \u03b5 ; /\u2217 le facteur courant \u2217/\n    t' \u2190 \u03b5 ; /\u2217 le texte compress\u00e9 \u2217/\n    n \u2190 |\u03a3| ; /\u2217 nombre de facteurs d\u00e9j\u00e0 compress\u00e9s \u2217/\n    tant que t n\u2019est pas vide faire:\n        c \u2190 t[0] ; /\u2217 1ere lettre de t \u2217/\n        t \u2190 t[1:]/\u2217 supprimer la 1ere lettre de t \u2217/\n        p \u2190 w + c ; /\u2217 ajouter une lettre \u00e0 w \u2217/\n        si p est une cl\u00e9 de d :\n            w \u2190 p;\n        sinon :\n            d[p] \u2190 n ; /\u2217 ajouter l\u2019association (p, n)\u2217/\n            n++;/\u2217 incr\u00e9menter le nb de code enregistr\u00e9s \u2217/\n            /\u2217 rqe : n = |d| : nb de cl\u00e9s dans le dico \u2217/\n            t' \u2190 t' + d[w] ; /\u2217 ajouter le code de w \u00e0 t' \u2217/\n            w \u2190 c;\nt' \u2190 t' + d[w];\nrenvoyer t'\n</code></pre> Exemple (Wikipedia) <p>On veut compresser \u201dTOBEORNOTTOBEORTOBEORNOT\u201d. </p> <ul> <li>Initialisation de d : (A :65) ... (T :84), (O :79), (B :66), (E :69),  (R :82), (N :78) ... (Z :90) ... (\\255,255) et t' \\(\\leftarrow \\varepsilon\\) (texte compress\u00e9)</li> <li>Position 0 : T est une cl\u00e9 mais pas TO. d[TO] \\(\\leftarrow\\) 255 + 1 = 256,  t' \\(\\leftarrow\\) 84  </li> <li>Position 1 : O est une cl\u00e9 mais pas OB. d[OB] \\(\\leftarrow\\) 257, t' \\(\\leftarrow\\) 84, 79</li> <li>Position 2 : B est une cl\u00e9 mais pas BE. d[BE] \\(\\leftarrow\\) 258, t' \\(\\leftarrow\\) 84, 79, 66  </li> <li>Position 3 : E est une cl\u00e9 mais pas EO. d[EO] \\(\\leftarrow\\) 259,  t' \\(\\leftarrow\\) 84, 79, 66, 69  </li> <li>Position 4 : O est une cl\u00e9 mais pas OR. d[OR] \\(\\leftarrow\\) 260,  t' \\(\\leftarrow\\) 84, 79, 66, 69, 82</li> <li>Position 5 : R est une cl\u00e9 mais pas RN. d[RN] \\(\\leftarrow\\) 261,  t' \\(\\leftarrow\\) 84, 79, 66, 69, 82, 78  </li> <li> <p>La derni\u00e8re lettre du dernier facteur ajout\u00e9 est la premi\u00e8re du nouveau  facteur parcouru.  </p> </li> <li> <p>Position 6 : N est une cl\u00e9 mais pas NO. d[NO] \\(\\leftarrow\\) 262,  t' \\(\\leftarrow\\) 84, 79, 66, 69, 82, 78, 79</p> </li> <li>Position 7 : O est une cl\u00e9 mais pas OT. d[OT] \\(\\leftarrow\\) 263,  t' \\(\\leftarrow\\) 84, 79, 66, 69, 82, 78, 79, 84</li> <li>Position 8 : T est une cl\u00e9 mais pas TT. d[TT] \\(\\leftarrow\\) 264,  t' \\(\\leftarrow\\) 84, 79, 66, 69, 82, 78, 79, 84, 84</li> <li>Position 9 : T, TO sont des cl\u00e9s mais pas TOB. d[TOB] \\(\\leftarrow\\) 265,  t' \\(\\leftarrow\\) 84, 79, 66, 69, 82, 78, 79, 84, 84, 256  </li> <li>Position 11 : B, BE sont des cl\u00e9s mais pas BEO. d[BEO] \\(\\leftarrow\\) 266,  t' \\(\\leftarrow\\) 84, 79, 66, 69, 82, 78, 79, 84, 84, 256, 258  </li> <li>Position 13 : O, OR sont des cl\u00e9s mais pas ORT. d[ORT] \\(\\leftarrow\\) 267,  t' \\(\\leftarrow\\) 84, 79, 66, 69, 82, 78, 79, 84, 84, 256, 258, 260  </li> <li>Position 15 : T,TO,TOB sont des cl\u00e9s mais pas TOBE. d[TOBE] \\(\\leftarrow\\) 268,  t' \\(\\leftarrow\\) 84, 79, 66, 69, 82, 78, 79, 84, 84, 256, 258, 260, 265  </li> <li>Position 18 : E,EO sont des cl\u00e9s mais pas EOR. d[EOR] \\(\\leftarrow\\) 269,  t' \\(\\leftarrow\\) 84, 79, 66, 69, 82, 78, 79, 84, 84, 256, 258, 260, 265, 259  </li> <li>Position 20 : R,RN sont des cl\u00e9s mais pas RNO. d[RNO] \\(\\leftarrow\\) 270,  t' \\(\\leftarrow\\) 84, 79, 66, 69, 82, 78, 79, 84, 84, 256, 258, 260, 265, 259, 261  </li> <li>Position 22 \u00e0 fin : O,OT sont des cl\u00e9s.  t' \\(\\leftarrow\\) 84, 79, 66, 69, 82, 78, 79, 84, 84, 256, 258, 260, 265, 259, 261, 263  </li> </ul>"},{"location":"Textes/lzw/#decompression","title":"D\u00e9compression","text":""},{"location":"Textes/lzw/#initialisation","title":"Initialisation","text":"<p>On note d le dictionnaire (code,facteur) qui est l\u2019inverse de celui de la  partie pr\u00e9c\u00e9dente (en fait, puisque l\u2019ensemble des codes forme un  intervalle de nombres, un simple tableau redimensionnable su\ufb03t).</p> <p>Ce dictionnaire est initialis\u00e9 ainsi : \u00e0 tous les codes entre (par exemple  0 et 256) on associe la lettre correspondante de l\u2019alphabet.</p> <p>La notation |d| d\u00e9signe le nombre d\u2019associations d\u00e9j\u00e0 entr\u00e9es. Avec le  code ASCII, |d| = 256 au d\u00e9part.</p> <p>Le premier code c lu est n\u00e9cessairement celui d\u2019un unique caract\u00e8re.  On \u00e9crit donc d[c] dans le fichier de sortie et on garde c en m\u00e9moire.  </p>"},{"location":"Textes/lzw/#deroulement","title":"D\u00e9roulement","text":""},{"location":"Textes/lzw/#cas-general","title":"Cas g\u00e9n\u00e9ral","text":"<p>On garde en m\u00e9moire le pr\u00e9c\u00e9dent code lu c.  </p> <ul> <li>On lit un code n o\u00f9 n &lt; |d| (ce qui signifie qu\u2019on sait ce que code n).  Posons d[n] = xm' ; x est un caract\u00e8re et m' un mot.</li> <li>On \u00e9crit xm' dans le fichier de sortie  </li> <li>On rajoute ensuite un nouvel \u00e9l\u00e9ment mx dans le dictionnaire o\u00f9  m = d[c]. On pose donc d[|d|] = mx.  </li> </ul>"},{"location":"Textes/lzw/#cas-general-pourquoi-cela-marche-t-il","title":"Cas g\u00e9n\u00e9ral : Pourquoi cela marche-t-il ?","text":"<p>On reproduit en fait le processus de compression mais en remplissant  le dictionnaire avec un temps de retard. Selon le principe de compression :  </p> <ul> <li>On ajoute une entr\u00e9e au dictionnaire pour mx quand on lit x et que le  pr\u00e9c\u00e9dent motif lu est m.  </li> <li>Le code c de m (qui est connu, sinon on ne serait pas arriv\u00e9 \u00e0 x) est  ajout\u00e9 au texte cod\u00e9.  </li> <li>On repart alors avec x comme motif lu  </li> </ul>"},{"location":"Textes/lzw/#cas-problematique-n-d","title":"Cas probl\u00e9matique : n = |d|","text":"<p>Le code n lu est tel que n = |d|, donc on lit un code non encore pr\u00e9sent  dans la table de d\u00e9compression.</p> <ul> <li>On lit le code n : il a \u00e9t\u00e9 plac\u00e9 \u00e0 cet endroit au moment de la  compression apr\u00e8s avoir lu un wy . Ainsi, n est le code de w .  </li> <li>n est maximal parmi les codes d\u00e9j\u00e0 rencontr\u00e9s. Revenant au moment  de la compression, cela signifie que w est le dernier facteur qui a  produit un code avant d\u2019\u00e9crire n.  </li> <li>Or, juste avant n dans le texte compress\u00e9, il y a c (lequel code m).  Ainsi w est de la forme mx.  </li> <li>Dans la compression, apr\u00e8s avoir lu mx, on repart de x et on lit wy ,  c.a.d. mxy . Ainsi, la 1ere lettre de m est x ! (dans le texte originel, on  a donc . . . mxmxy . . . ).  </li> <li>On ajoute mx au texte d\u00e9compress\u00e9 et on r\u00e9alise l\u2019association  d[y ] = mx.  </li> </ul>"},{"location":"Textes/lzw/#algorithme_1","title":"Algorithme","text":"<p>On initialise le dictionnaire avec l\u2019alphabet (par exemple alphabet ASCII  des caract\u00e8res cod\u00e9s sur 8 bits).  </p> <pre><code>fonction lzw_decompress (T' : texte compress\u00e9,\n                            d : dictionnaire ( code , facteur )):\n    c \u2190 Lire(T'); /\u2217 1er code lu\u2217/\n    /\u2217 le 1er code correspond toujours \u00e0 une lettre \u2217/\n    Ecrire d[c]; /\u2217 ajouter le texte cod\u00e9 parc \u2217/\n    tant que il reste un codes de T' non lu faire\n        n \u2190 lire(T'); /\u2217 code courant \u2217/\n        si n est une clef de d /\u2217 code n d\u00e9j\u00e0 rencontr\u00e9 \u2217/\n            alors e \u2190 d[n]; /\u2217 d\u00e9compression \u2217/\n        sinon e \u2190 d[c] \u00b7 d[c][0]; /\u2217 d\u00e9compression , cas n = |d|\u2217/\n        Ecrire e;\n        c \u2190 n;\n        d[|d|] \u2190 d[c] \u00b7 e[0]; /\u2217 ajouter une association \u2217/\n    fin faire\n</code></pre>"},{"location":"Textes/lzw/#taille-des-entiers-de-codage","title":"taille des entiers de codage","text":""},{"location":"Textes/lzw/#taille-des-entiers-en-ocaml","title":"Taille des entiers en OCaml","text":"<p>En OCaml, les entiers sont deux bits plus courts que les entiers machines.  Sur la plupart des machines, les entiers sont de taille 32 ou 64 bits. En  OCaml, les entiers sont donc de taille 30 ou 62 bits  </p> <p>La repr\u00e9sentation du r\u00e9sultat de la compression par une liste d\u2019entiers  OCAML n\u2019est pas tr\u00e8s r\u00e9aliste : il faudrait a priori 30 bits (ou 62) pour  stocker chaque entier. Cependant, on remarque que la taille des entiers  produits par l\u2019algorithme de compression cro\u00eet progressivement au fur et \u00e0  mesure que l\u2019on avance dans la liste (et que le dictionnaire se remplit).  Dans la pratique, on peut donc utiliser la technique suivante pour coder la  liste :  </p> <ul> <li>Tant que tous les entiers sont strictement inf\u00e9rieurs \u00e0 255, coder ces  entiers sur 8 bits.  </li> <li>Lorsque l\u2019on rencontre le premier entier sup\u00e9rieur ou \u00e9gal \u00e0 255,  \u00e9mettre la s\u00e9quence 11111111 (huit fois le bit 1) et continuer, tant  que les entiers sont strictement inf\u00e9rieurs \u00e0 511, en codant les entiers  sur 9 bits.  </li> <li>Lorsque l\u2019on rencontre le premier entier sup\u00e9rieur ou \u00e9gal \u00e0 511,  \u00e9mettre la s\u00e9quence 111111111 (neuf fois le bit 1) et continuer, tant  que les entiers sont strictement inf\u00e9rieurs \u00e0 1023, en codant les  entiers sur 10 bits.  </li> <li>De mani\u00e8re g\u00e9n\u00e9rale, tant que les entiers consid\u00e9r\u00e9s sont strictement  inf\u00e9rieurs \u00e0 n = 2k \u2212 1, on peut les repr\u00e9senter sur k bits.  </li> <li>Lorsque le premier entier sup\u00e9rieur ou \u00e9gal \u00e0 2k \u2212 1 est rencontr\u00e9, on  \u00e9met la s\u00e9quence 1 . . . 1 (k fois le bit 1) et on continue en codant les  entiers sur k + 1 bits.  </li> <li>Donc si le code 10 se trouve au d\u00e9but de la liste des codages, il prend  8 bits d\u2019espace mais apr\u00e8s le premier nombre plus grand que 255, il  prend 9 bits etc.  </li> </ul>"},{"location":"Textes/textes/","title":"Recherche dans un texte","text":"<p>======</p> <p>Danger</p> <p>Ce cours n'a pas \u00e9t\u00e9 enti\u00e8rement reverifi\u00e9 apr\u00e8s le passage du programme. Pensez \u00e0 supprimer ce message si vous avez reverifi\u00e9 ce cours</p> <p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Rappel de l\u2019algorithme na\u00a8\u0131f  Algorithme de Boyer-Moore Boyer-Moore-Horspool  Algorithme de Rabin-Karp  </p>"},{"location":"Textes/textes/#credits","title":"Cr\u00e9dits","text":"<p>Pour Boyer-Moore : </p> <ul> <li>Wikipedia</li> <li>Un cours de Marc de Falco</li> <li>Cette vid\u00e9o de Ben Langmead  </li> </ul> <p>Pour Rabin-Karp : Informatique -Cours et exercices corrig\u00e9s- (MP2I-MPI) (ellipse)  </p>"},{"location":"Textes/textes/#principe-de-la-recherche","title":"Principe de la recherche","text":"<ul> <li>Soit un texte \u00e9crit dans l\u2019alphabet \u03a3  </li> <li>Soit un autre texte (plus court) \u00e9crit dans le m\u00eame alphabet : le motif  </li> <li>On cherche le motif dans le texte et, en cas de pr\u00e9sence constat\u00e9e, on  retourne la position de la premi\u00e8re lettre de la premi\u00e8re occurence du  motif dans le texte.  </li> <li>Nous dirons que le motif est pr\u00e9sent \u00e0 la position i si la lettre i du  texte est \u00e9gale \u00e0 la lettre 0 du motif, la lettre i+1 du texte est \u00e9gale \u00e0  la lettre 1 du motif et ainsi de suite jusqu\u00e0 la derni\u00e8re lettre du motif.  </li> </ul>"},{"location":"Textes/textes/#difference-avec-la-recherche-de-sous-tableau-dans-un-tableau","title":"Di\ufb00\u00e9rence avec la recherche de sous-tableau dans un  tableau","text":"<ul> <li>Le nombre de caract\u00e8res dans l\u2019alphabet est en g\u00e9n\u00e9ral n\u00e9gligeable  devant celle du texte explor\u00e9  </li> <li>Cette propri\u00e9t\u00e9 am\u00e8ne des optimisations inapplicables dans un  contexte de tableau contenant un grand nombre de symboles  di\ufb00\u00e9rents.  </li> </ul>"},{"location":"Textes/textes/#rappel-de-lalgorithme-naif","title":"Rappel de l'algorithme na\u00eff","text":""},{"location":"Textes/textes/#conventions","title":"Conventions","text":"<ul> <li>Soit s le texte et m le motif, |s| et |m| leurs longueurs. Soient k, r  dans \\([\\![ 0,\\left |\\textsf s  \\right | ]\\!]\\). Les lettres sont num\u00e9rot\u00e9es \u00e0 partir de 0.</li> <li>On applique les notation de slicing Python :  </li> <li>s[i] est la lettre en position i</li> <li>s[\u22121] : derni\u00e8re lettre de s (comprendre s[|s| \u2212 1]).</li> <li>s[\u2212k] : k-i\u00e8me lettre de s en partant de la fin (comprendre s[|s| \u2212 k]).</li> <li>s[k : r ] est la sous-cha\u00eene de s qui contient les lettres de la position k \u00e0  r \u2212 1. C\u2019est la cha\u00eene vide si r \u2264 k</li> <li>s[: r ] est le pr\u00e9fixe de longueur r de s (lettres 0 \u00e0 r \u2212 1).</li> <li>s[: \u2212k] est la sous-cha\u00eene qui ne contient pas les k derni\u00e8res lettres.  Longueur |s| \u2212 k.</li> <li>s[k :] est le su\ufb03xe de s qui commence \u00e0 la position k (toutes les lettres  de s[k] incluse \u00e0 la fin). C\u2019est un mot de longueur |s| \u2212 k.  </li> </ul>"},{"location":"Textes/textes/#principe","title":"Principe","text":"<ul> <li>On parcourt toutes les positions de s[: \u2212(|m| \u22121)] et on fait glisser le  motif de une case \u00e0 chaque \u00e9tape (on s\u2019arr\u00eate d\u00e8s que le motif  \"d\u00e9passe\" du texte).</li> <li>Pour la position i, on regarde si le motif est pr\u00e9sent \u00e0 partir de cette  position :  </li> <li>Pour une position k dans le motif</li> <li>La lettre s[i + k] dans le texte doit \u00eatre \u00e9gale \u00e0 la lettre m[k] dans le  motif</li> <li>Si c\u2019est le cas on passe \u00e0 la position suivante dans le motif et le texte.</li> <li>Sinon, le motif n\u2019est pas pr\u00e9sent en position i, on recommence la  recherche \u00e0 la position i+1.  </li> </ul>"},{"location":"Textes/textes/#code","title":"Code","text":"<pre><code>int recherche_naive ( const char *m , const char * s ){  \n   int n = strlen ( s ) ; \n   int p = strlen ( m ) ;  \n   for ( int i = 0; i &lt;= n - p ; i ++) {  \n      int j ;  \n      for ( j = 0; j &lt; p ; j ++) {  \n         if ( s [ i + j ] != m [ j ]) \n         break ; // pas la peine de continuer  \n      } // for j  \n      if ( j == p )  \n         return i ; // motif en pos . i  \n   }  // for i  \n   return -1; // motif absent  \n}\n</code></pre>"},{"location":"Textes/textes/#complexite-au-pire","title":"Complexit\u00e9 au pire","text":"<p>La complexit\u00e9 au pire est obtenue lorsqu\u2019on entre syst\u00e9matiquement dans  la seconde boucle et qu\u2019on explore les lettres du motif presque jusqu\u2019au  bout.</p> <ul> <li>s = an (n lettres) et \\(m = a^{p-1}b ~~\\)(p lettres)</li> <li>On explore les p lettres du motif pour chacune des n \u2212 p + 1  premi\u00e8res lettres du texte.  </li> <li>Complexit\u00e9 au pire en \\(\\Theta-(n+1 -p)p)~\\) Et \\(\\Theta(np)\\) (si \\(p &lt; \\frac{n}{2}\\) par exemple).  </li> </ul>"},{"location":"Textes/textes/#complexite","title":"Complexit\u00e9","text":"<ul> <li>Souvent, au bout d\u2019une ou deux comparaisons, on peut invalider la  position et passer \u00e0 la suivante.  </li> <li>Si le motif est pr\u00e9sent \u00e0 la fin du texte, on a une complexit\u00e9 en  \\(O(n+p)\\) (o\u00f9 \\(p\\) comparaisons sont n\u00e9cessaires pour v\u00e9rifier une \u00e0 une  les lettres du motif).  </li> <li>\\(O(n+p) = O(n)\\) si p \u2264 n.  </li> </ul>"},{"location":"Textes/textes/#algorithme-de-boyer-moore","title":"Algorithme de Boyer-Moore","text":""},{"location":"Textes/textes/#principe_1","title":"Principe","text":"<ul> <li>On parcourt le texte s du d\u00e9but \u00e0 la fin mais on e\ufb00ectue parfois un  d\u00e9calage d\u00e9pendant de la premi\u00e8re comparaison n\u00e9gative (ce qui fait  gagner du temps).  </li> <li>Le motif m est recherch\u00e9 en commen\u00e7ant par la fin : on teste la  pr\u00e9sence de su\ufb03xes du motif de plus en plus gros.  C\u2019est le contraire de la m\u00e9thode na\u00a8\u0131ve ou le motif est recherch\u00e9 en  faisant grossir ses pr\u00e9fixes.  </li> <li> <p>L\u2019algorithme utilise un pr\u00e9-traitement du motif afin de calculer le saut  maximum \u00e0 e\ufb00ectuer apr\u00e8s avoir trouv\u00e9 une non-concordance.  </p> </li> <li> <p>Exploration de la lettre i de s : on se demande si ce n\u2019est pas la  premi\u00e8re lettre de m.</p> </li> <li>On se place donc en position i + |m| \u2212 1 de s (donc \u00e0 droite de i). On  explore les positions i + |m| \u2212 1, i + |m| \u2212 2 . . . dans le texte en  comparant avec les positions \u22121, \u22122 etc.. du motif. On esp\u00e8re arriver  sans encombre \u00e0 la lettre i.</li> <li>Si on arrive sans erreur \u00e0 la position i : on a trouv\u00e9 le motif.</li> <li>Sinon, on a trouv\u00e9 un su\ufb03xe xm' de s[: i+ |m|] (s tronqu\u00e9 \u00e0  i + |m| \u2212 1) tel que m'est un su\ufb03xe propre de m et pas xm'<ul> <li>Si x n\u2019est pas pr\u00e9sent dans m, on reprend la recherche juste apr\u00e8s x (pas la peine de perdre son temps \u00e0 placer le motif avant le x du texte)</li> <li>si x est pr\u00e9sent, on aligne le x de m le plus \u00e0 droite et le x de s</li> </ul> </li> </ul>"},{"location":"Textes/textes/#regle-du-mauvais-caractere-exemple","title":"R\u00e8gle du mauvais caract\u00e8re : exemple","text":"<p>On cherche string (m) dans le texte stupid spring string (s).  </p> <ul> <li>D\u00e9marrage en position 0 de s.     d et g ne correspondent pas en position 5 et il n\u2019y a aucun d dans le  motif. On passe \u00e0 la position suivante 0 + |m| de s.  </li> <li> <p>Poursuite en position 6 de s :     Le n et le g ne correspondent pas. Mais 1 cran \u00e0 gauche de g, il y a  un n dans le motif. On aligne donc le n du motif avec celui du texte.  </p> </li> <li> <p>Poursuite en position 6 + 1 de s :        Correspondance de 4 lettres. Mais p ne figure pas dans le motif. On  d\u00e9cale le motif APRES ce p, donc de 2 positions. etc..  </p> </li> </ul>"},{"location":"Textes/textes/#table-des-sautsoccurences-a-droite","title":"Table des sauts/occurences \u00e0 droite","text":"<p>On veut chercher le motif abaa. Voici sa table des occurrences \u00e0  droite : occurrence la plus \u00e0 droite  2 (on ne tient pas compte du dernier a)  1  \u2205 Lettre  a  b  Autres lettres  On note dm(x) l\u2019occurrence la plus \u00e0 droite de x dans m.  On veut chercher le motif abc. Voici sa table des occurrences \u00e0  droite : saut max  3-2  3-1  |m| = 4 Lettre  a  b  Autres lettres dont c occurrence la plus \u00e0 droite  0  1  \u2205 saut max  2-0  2-1  |m| = 3  </p> <pre><code>Remarques\n</code></pre> <p>Table des sauts Lorsque la derni\u00e8re lettre du motif (m[\u22121]) n\u2019est pas pr\u00e9sente ailleurs  dans m (comme dans abcd mais pas abcb), le saut pour m[\u22121] est  de |m|. Il y a autant de lignes que dans l\u2019alphabet. On peut pr\u00e9f\u00e9rer utiliser  un dictionnaire, ce qui est \u00e9conome en espace si le motif contient  beaucoup moins de lettres que l\u2019alphabet (songer \u00e0 l\u2019UTF16 !)  </p> <p>Attention</p> <p>Jme suis arreter la</p>"},{"location":"Textes/textes/#s-texte-m-motif-dm-tableau-des-occurrences-les-plus-a-droite","title":"s : texte, m : motif, dm tableau des occurrences les plus \u00e0 droite.","text":"<p>i est la position courante dans le texte (position \u00e0 laquelle on esp\u00e8re  trouver le premier caract\u00e8re du motif). i \u2191 j est la position de la lettre courante du motif. j \u2193.  On compare s[i + j] et m[j] comme dans l\u2019algo na\u00a8\u0131f.  Supposons que s[i + j] (cid:54)= m[j] (sinon j est d\u00e9cr\u00e9ment\u00e9) : si dm(s[i + j]) = \u2205, la recherche du motif ne sera pas satisfaite tant que  ce caract\u00e8re s[i + j] sera pr\u00e9sent. On reprend la recherche en i + j + 1  si s[i + j] est dans le motif et dm(s[i + j]) \u2265 j, cela signifie que s[i + j]  est pr\u00e9sent plus \u00e0 droite que j dans le motif. Aligner cette occurrence  ne permettrait pas d\u2019avancer la recherche (cf figure 1). On reprend en  i + 1.  Si dm(s[i + j]) &lt; j, le caract\u00e8re s[i + j] est pr\u00e9sent dans le motif \u00e0  gauche de la position courante j. On \"aligne\" ce caract\u00e8re du motif  avec celui du texte.  On reprend donc la recherche dans le texte en i' tel que  i' + dm(s[i + j]) = i + j. Ainsi, la nouvelle position dans le texte est  i' = i + (j \u2212 dm(s[i + j]).  </p>"},{"location":"Textes/textes/#figure-1-dmsi-j-j","title":"Figure 1 : dm(s[i + j]) \u2265 j","text":"<p>s[i + j] est dans le motif et dm(s[i + j]) \u2265 j (dm(s[i + j]) est not\u00e9 d) : . . . . . i . . . (i+j) . . . a  ? y  z  j y  d pos. txt  texte  motif  pos. motif D\u00e9caler le motif de \u2212(d \u2212 j) n\u2019a pas d\u2019int\u00e9r\u00eat car le point de d\u00e9part dans  le texte serait alors en i \u2212 d qui a d\u00e9j\u00e0 \u00e9t\u00e9 inspect\u00e9 et invalid\u00e9 ! On se  place donc en i + 1 : aucun gain par rapport \u00e0 l\u2019algorithme na\u00a8\u0131f.  </p>"},{"location":"Textes/textes/#figure-2-0-dmsi-j-j","title":"Figure 2 : 0 \u2264 dm(s[i + j]) &lt; j","text":"<p>dm : table des occurrences \u00e0 droite. Posons d = dm(s[i + j]). . . . . i . . . . . . . (i+j) . . . : pos. dans txt a  ? 0 : texte  y  x : motif m  &lt;------&gt; Aucun y dans m[d+1:] : remarques y  z j-d d j (|m|-1) : pos. dans motif Nouveau point de d\u00e9part en i + j \u2212 d (pour aligner les y ) : . . . . i . . (i+j-d) . . . . (i+j) . . . . . dec. =j-d  dec. &lt;j-d b  ? ? y  y  y u z z x x pos. dans txt :  : texte  : motif (good)  : motif (bad) Prendre un d\u00e9calage plus petit am\u00e8ne une lettre u (cid:54)= y sous y .  </p>"},{"location":"Textes/textes/#terminaison-informelle","title":"Terminaison Informelle","text":"<p>Dans la boucle externe, |s| \u2212 i est strictement d\u00e9croissant et dans la  boucle interne, c\u2019est j qui est strictement d\u00e9croissant. On en d\u00e9duit la terminaison  </p>"},{"location":"Textes/textes/#correction-informelle","title":"Correction Informelle","text":"<p>Par rapport \u00e0 l\u2019algo na\u00a8\u0131f, on fait des sauts.  Il su\ufb03t donc de s\u2019assurer que les positions non explor\u00e9es du fait des  sauts ne conduisent pas \u00e0 une solution.  Un saut de 1 case n\u2019est pas int\u00e9ressant \u00e0 \u00e9tudier car il correspond \u00e0  l\u2019algo na\u00a8\u0131f.  On s\u2019int\u00e9resse au cas i = 0 (pour simplifier) et \u00e0 un saut de 2 cases  au moins. Il existe 3 caract\u00e8res x, y , z (avec y (cid:54)= z) et des mots m, m, m, s, s  (avec |m| \u2265 1) tels que m = m mx et m z y     dmy  &lt; j    j s = s y       j ms et y /\u2208 mzm. Un d\u00e9calage trop faible (donc inf\u00e9rieur \u00e0 j \u2212 dm(y ) \u2212 1) am\u00e8ne une  lettre de m au niveau du y de yms. Or cette lettre de m est  di\ufb00\u00e9rente de y (voir transparent figure 2).  D\u2019o\u00f9 l\u2019inutilit\u00e9 de d\u00e9caler moins que j \u2212 dm(y ).  </p>"},{"location":"Textes/textes/#complexite-informelle","title":"Complexit\u00e9 informelle","text":"<p>s texte, m motif Si l\u2019alphabet contient beaucoup de caract\u00e8res (par exemple UTF8),  on peut esp\u00e9rer que les motifs auront peu de r\u00e9p\u00e9titions.  Chaque d\u00e9calage sera donc en gros de |m|. En cas de recherche infructueuse, on e\ufb00ectue environ |s|  |m| comparaisons. Exemple le pire m = bap\u2212 et s = an. Il faut, avant de faire un  d\u00e9calage, atteindre le b, soit p comparaisons. Et le d\u00e9calage, obtenu  en comparant a et b, est alors de 1 (car j = 0 &lt; p \u2212 1 = da).  Comme pour l\u2019algo na\u00a8\u0131f, on a un nombre de comparaisons en (n \u2212 p + 1)p = \u0398(np) = \u0398(|m| \u00d7 |s|)  </p>"},{"location":"Textes/textes/#algorithme","title":"Algorithme \u2665","text":"<pre><code>f o n c t i o n                  \np o u r\np o u r     r e n v o y e r \n</code></pre> <p>Listing 2 \u2013 Table des sauts  </p> <pre><code>     \u2217\n\n\n\n\n\n          \u2217\n</code></pre> <p>\u2212 \u2217     </p> <pre><code>   \u2217\n</code></pre> <p>|| \u2212  \u2217 || \u2212      \u2217  </p> <pre><code>f o n c t i o n              \nt a n t que  t a n t q u e            \ns i\na l o r s\nr e n v o y e r\ns i  a l o r s\ns i n o n s i  a l o r s\ns i n o n \nr e n v o y e r ```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nListing 3 \u2013 Fonction principale  \n\n\n                       || \u2212 &lt; |      |  \n\n || \u2212  \n\n &gt;  \n\n  \u2212  \n   &lt;   \n             \u2217      &lt;  \u2217               \n\n             \u2217           \u2212 \u2217  \n  &gt;     \n   \u2217                \n        \u2217  \n   \u2217         \u2217      \u2212  \u2217      \u2217  \n\u2212 \u2217     \n     \u2217  \n\n#### Boyer-Moore complet\n\n\nL\u2019algorithme de Boyer-Moore complet, plus d\u00e9licat que  Boyer-Moore-Horspool, introduit une seconde table de sauts en plus de la  table des derni\u00e8res occurrences. Conform\u00e9ment au programme, on peut  s\u2019abstenir de l\u2019\u00e9tudier.  \n\n\n Rappel de l\u2019algorithme na\u00a8\u0131f  \n Algorithme de Boyer-Moore  \nBoyer-Moore-Horspool  \n Algorithme de Rabin-Karp  \n\n#### Pr\u00e9sentation\n\n\nL\u2019algorithme de Rabin-Karp ou Karp-Rabin est un algorithme de  recherche de sous-cha\u00eene cr\u00e9\u00e9 par Richard M. Karp et Michael O.  Rabin (1987).  \nCette m\u00e9thode recherche un ensemble de motifs donn\u00e9s (c\u2019est-\u00e0-dire  des sous-cha\u00eenes) dans un texte gr\u00e2ce \u00e0 une fonction de hachage. On  ne compare donc pas directement le motif \u00e0 des sous-cha\u00eenes du texte  mais seulement leurs empreintes (le hache).  \nL\u2019algorithme n\u2019est pas beaucoup employ\u00e9 pour les recherches d\u2019une  unique sous-cha\u00eene mais a une importance th\u00e9orique et s\u2019av\u00e8re tr\u00e8s  e\ufb03cace pour des recherches de multiples sous-cha\u00eenes. (Wikipedia)  Dans toute la suite on prend s : texte ; m motif. Pour un mot u, uk  d\u00e9signe la lettre k de u.  \n\n#### Utilisation d\u2019une fonction de hachage\n\n\nOn se donne une fonction de hachage h sur les cha\u00eenes de caract\u00e8res  et on calcule une fois pour toute h(m).  \nPour chaque position 0 \u2264 i \u2264 |s| \u2212 |m| on calcule h(s[i : i + |m|]).  \nSi h(m) (cid:54)= h(s[i : i + |m|]), on est certain que m n\u2019est pas en position  i dans le texte.  \nSi h(m) = h(s[i : i + |m|]), comme h n\u2019est pas injectif en g\u00e9n\u00e9ral, il  est possible que m soit en position i dans le texte. Il faut alors  comparer m et s[i : i + |m|] en force brute.  \n\n#### Choix de h\n\n\nLe calcul de h(s[i : i + |m|]) se fait \u00e0 priori en \u0398(|m|). La s\u00e9quence  des calculs des haches des sous-cha\u00eenes de s a alors la m\u00eame  complexit\u00e9 que la recherche na\u00a8\u0131ve, soit en \u0398((|s| \u2212 |m| + 1) \u00d7 |m|) (il  y a |s| \u2212 |m| + 1 sous-cha\u00eenes de s de taille |m|).  D\u2019o\u00f9 l\u2019id\u00e9e de choisir h de fa\u00e7on \u00e0 ce que h(s[i + 1 : i + 1 + |m|])  s\u2019obtienne \u00e0 partir de h(s[i : i + |m|]) en temps constant.  Choisissons un entier B arbitraire et posons pour le mot  u = uu . . . u|m| que  \nh(u) =  \n{sum symbol}  \nB |m|\u2212\u2212j \u00d7 uj  \n\u2264j&lt;|m|  \nUne telle fonction, polyn\u00f4miale, se calcule en O(|m|) par la m\u00e9thode  de Horner. En C, un caract\u00e8re n\u2019est rien d\u2019autre qu\u2019un nombre cod\u00e9  sur un octet d\u2019o\u00f9 la validit\u00e9 du produit.  Selon Wikipedia, cette fonction de hachage est appel\u00e9e empreinte de  Rabin.  \n\n#### Choix de h (suite)\n\n\nAppliqu\u00e9e au texte s, et posant |m| = M, on obtient :  \nh(sisi . . . siM ) =  \nM\u2212  {sum symbol}  \nj  \nB M\u2212\u2212j sij  \n= siM B M\u2212\u2212M \u2212 si B M + B \u00d7  \nM\u2212  {sum symbol}  \nj  \nB M\u2212\u2212j sij  \n= siM + B(h(si si . . . siM\u2212) \u2212 si B M\u2212)  \nOn peut donc calculer h(s[i + 1 : i + 1 + M]) \u00e0 partir de h(s[i : i + M])  en temps constant : avec un pr\u00e9calcul (une fois pour toute) de B M\u2212,  il faut faire une addition une soustraction et 2 produits.  Il peut y avoir un over\ufb02ow. D\u2019o\u00f9 la n\u00e9cessit\u00e9 de travailler modulo (il  est malin de prendre un grand nombre premier pour ce modulo).  \n\n#### Cas d\u2019un motif unique\n\n\n```linenums=\"1\"\nf o n c t i o n            \np o u r\nf a i r e\ns i   \ns i   \nr e n v o y e r\nr e n v o y e r \n</code></pre> <p>Listing 4 \u2013 Rabin-Karp : recherche d\u2019un motif  </p> <pre><code>                   \u2217\n</code></pre> <p>\u2217                                       \u2217         \u2217 ||   \u2217              \u2217  \u2217            \u2217       \u2212 </p> <p>||     </p> <pre><code>||\n</code></pre> <p>Si on veut toutes les occurrences du motif, on cr\u00e9e une liste initialement  vide positions puis : On remplace la ligne 10 par : ajouter i \u00e0 positions ;  La derni\u00e8re ligne devient : renvoyer positions  </p>"},{"location":"Textes/textes/#complexite-de-la-recherche-de-toutes-les-positions","title":"Complexit\u00e9 de la recherche de toutes les positions","text":"<p>On pose N = |s| (texte) ; M = |m| (motif) Dans le meilleur cas, les comparaisons des hach\u00e9s sont toujours  n\u00e9gatives et on n\u2019appelle jamais la fonction de comparaison de  cha\u00eenes de caract\u00e8res. Complexit\u00e9 au mieux en O(N + M) (O(M)  pour les deux hach\u00e9s initiaux -souvent M \u2264 N\u2212). Boyer-Moore  complet (non vu cette ann\u00e9e) peut faire encore mieux. Le pire cas arrive quand le motif est pr\u00e9sent \u00e0 toutes les positions.  Avec s = aN et m = aM , on doit faire une comparaisons de cha\u00eenes  de caract\u00e8res \u00e0 chaque position dans le texte. Complexit\u00e9 en  O(N(N \u2212 M + 1)) comme pour l\u2019algorithme na\u00a8\u0131f.  </p>"},{"location":"Textes/textes/#cas-de-motifs-multiples","title":"Cas de motifs multiples","text":"<pre><code>f o n c t i o n                     \np o u r\nf a i r e\ns i  r e n v o y e r         \n</code></pre> <p>On cherche un ensemble de motifs, tous de m\u00eame longueur m Listing 5 \u2013 Rabin-Karp : recherche de plusieurs motifs  </p> <p>\u2217                           \u2217                           \u2217              \u2217    { |  \u2208 M} \u2217                  \u2212   \u2217         \u2217         \u2217         \u2217           \u2217 \u2208        </p> <p>\u2208   </p> <p>Pas si e\ufb03cace pour la recherche d\u2019un motif unique, il faut privil\u00e9gier  Rabin-Karp pour la recherche de plusieurs motifs.  </p>"}]}