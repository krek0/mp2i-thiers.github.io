{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Accueil","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"Arbres/","title":"Arbre Binaire de Recherche","text":""},{"location":"Arbres/#autocours","title":"AutoCours","text":"<pre><code>graph TB; \n    A((1))--&gt;B((2))\n    A--&gt;C((3))\n    B--&gt;D((4))\n    B--&gt;E((5))\n    C--&gt;F((6))\n    C--&gt;G((7))\n    D--&gt;H((8))\n    D--&gt;I((9))\n    E--&gt;J((10))\n    E--&gt;K((11))\n    F--&gt;L((12))\n    F--&gt;M((13))\n    G--&gt;N((14))\n    G--&gt;O((15))</code></pre> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> Sommaire <ul> <li>Arbre binaire de recherche<ul> <li>ABR</li> <li>Suppression</li> </ul> </li> <li>Dictionnaire</li> <li>Tas<ul> <li>Supprimer un \u00e9l\u00e9ment</li> <li>Cr\u00e9ation</li> </ul> </li> <li>Files de priorit\u00e9s (une application des tas)</li> <li>Arbre binaire de recherche</li> </ul> <p>Cr\u00e9dits</p> <ul> <li>\"Option informatique MPSI, MP/MP*\", Roger Mansuy, paru chez Vuibert.</li> <li>Wikip\u00e9dia : Tas, Tas binaires, Tri par tas</li> <li>OpenClassRoom Arbres binaires de recherche</li> </ul> <p>D\u00e9finition</p> <p>Binary search trees (BST)</p> <p>Un arbre binaire de recherche (ABR) sur un type totalement ordonn\u00e9 est un arbre binaire tel que pour tout n\u0153ud interne, les \u00e9tiquettes apparaissant dans le sous-arbre gauche (resp.droit) sont strictement\u00b9 inf\u00e9rieures (resp. sup\u00e9rieures) \u00e0 celle la racine. 1. Selon la mise en \u0153uvre de l\u2019ABR, on pourra interdire ou non des cl\u00e9s de valeur \u00e9gale.</p> <p>Figure \u2013 Un ABR</p> <pre><code>graph TB; \n    A((8))--&gt;B((3))\n    A--&gt;C((10))\n    B--&gt;D((1))\n    B--&gt;E((6))\n    C--&gt;H(( ))\n    C--&gt;G((14))\n    E--&gt;J((4))\n    E--&gt;K((7))\n    G--&gt;O((13))\n    G--&gt;F(( ))\n    style H display:none\n    style F display:none</code></pre> <p>Les \u00e9tiquettes de gauche ont des valeurs plus petites que celle de la racine, celle de droite sont plus grandes</p>"},{"location":"Arbres/#dsf","title":"DSF","text":"<p>On peut facilement r\u00e9cup\u00e9rer les cl\u00e9s d\u2019un arbre binaire de recherche dans l\u2019ordre croissant en r\u00e9alisant un parcours en profondeur infixe. Contre exemple:</p> <p>Figure \u2013 Un arbre binaire qui n\u2019est pas un ABR <pre><code>graph TB; \n    A((6))--&gt;B((4))\n    A--&gt;C((5))</code></pre></p> <p>Figure \u2013 Un ABR pour repr\u00e9senter <code>[4,5,6]</code> <pre><code>graph TB; \n    A((6))--&gt;B((5))\n    A --&gt;Z(( ))\n    B--&gt;C((4))\n    B--&gt;W(( ))\n    style Z display:none\n    style W display:none</code></pre> Figure \u2013 Un ABR \u00e9quilibr\u00e9 pour repr\u00e9senter <code>[4,5,6]</code> <pre><code>graph TB; \n    A((5))--&gt;B((6))\n    A--&gt;C((4))</code></pre> Figure \u2013 Un ABR pour repr\u00e9senter <code>[4,5,6]</code></p> <pre><code>graph TB; \n    A --&gt;Z(( ))\n    A((4))--&gt;B((5))\n    B--&gt;W(( ))\n    B--&gt;C((6))\n    style Z display:none\n    style W display:none</code></pre> <p>Passage liste ordonn\u00e9e/ABR A une liste ordonn\u00e9e correspondent plusieurs ABR.</p>"},{"location":"Arbres/#type-de-donnees","title":"Type de donn\u00e9es","text":"<p>Nous utiliserons le type suivant:</p> Type Arbre<pre><code>type 'a tree =\n|Nil\n|N of 'a * 'a tree * 'a tree;;\n</code></pre> <ul> <li>Une feuille est impl\u00e9ment\u00e9e par <code>N(x, Nil, Nil)</code>,</li> <li>une n\u0153ud d\u2019arit\u00e9 1 par <code>N(x, t, Nil)</code> ou <code>N(x, Nil, t)</code> avec x et t de type convenable.</li> <li>Une telle structure mod\u00e9lise les arbres binaires, pas seulement les ABR. C\u2019est lors de la cr\u00e9ation d\u2019un arbre que nous ferons attention \u00e0 ce qu\u2019il respecte la contrainte d\u2019ordre.</li> </ul>"},{"location":"Arbres/#primitives","title":"Primitives","text":"<ul> <li>Une fonction de cr\u00e9ation d\u2019un ABR \u00e0 partir d\u2019une liste.</li> <li>Une fonction d\u2019insertion d\u2019une valeur dans un ABR.</li> <li>Une fonction de recherche d\u2019une valeur dans un arbre.</li> <li>Une fonction de suppression d\u2019une valeur dans un arbre.</li> </ul> Ins\u00e9rer sous une feuille<pre><code>let rec insert x t = match t with\n| Nil -&gt; N (x , Nil , Nil )\n| N (y ,g , d ) when x &lt; y -&gt; N (y , insert x g , d )\n| N (y , g , d ) when x &gt;y -&gt; N (y ,g , insert x d )\n| _ -&gt; t (* pas de doublon *) ;; (* le laisser sinon Warning 8. *)\n</code></pre> <ul> <li>Le choix qui est fait ici est celui d\u2019un ABR sans \u00e9tiquettes de m\u00eames valeurs (pas de doublon).</li> <li>On ins\u00e8re la nouvelle valeur sous une feuille.</li> <li>On pourrait aussi ins\u00e9rer x \u00e0 la racine:<ul> <li>\"Couper\" l\u2019arbre en deux sous-ABR g , d contenant respectivement les \u00e9l\u00e9ments plus petits et plus grands que x.</li> <li>construire l\u2019arbre <code>N(x, g, d)</code></li> </ul> </li> </ul>"},{"location":"Arbres/#complexite-de-linsertion-sous-une-feuille","title":"Complexit\u00e9 de l\u2019insertion sous une feuille","text":"<p>Description informelle pour un arbre de hauteur \\(h\\) \u00e0 \\(n\\) n\u0153uds.</p> <ul> <li>On descend le long d\u2019une branche jusqu\u2019\u00e0 la feuille.</li> <li>Il y a \\(O(h)\\) pour cette descente. Pour chaque n\u0153ud interne, les op\u00e9rations hors appel r\u00e9cursif sont \u00e0 co\u00fbt constant.</li> <li>Dans le cas d\u2019arr\u00eat, le co\u00fbt est \u00e9galement constant.</li> <li>Donc complexit\u00e9 en \\(O(h)\\).</li> <li>On comprend l\u2019int\u00e9r\u00eat de \"contr\u00f4ler\" \\(h\\). En pratique, on essaye de conserver \\(h \\leq C \\log(n)\\) pour une certaine constante. Si on arrive \u00e0 maintenir cette contrainte au fil des insertions, on obtient un arbre \u00e9quilibr\u00e9).</li> </ul>"},{"location":"Arbres/#creation","title":"Cr\u00e9ation","text":"Cr\u00e9er un ABR \u00e0 partir d\u2019une liste<pre><code>let rec create l = match l with\n| [] -&gt; Nil\n| e :: q -&gt; insert e ( create q ) ;;\n(*test*)\ncreate ([1;4;2;3]) ;;\n</code></pre> <p>Figure \u2013 ABR obtenu par <code>create([1;4;2;3]);;</code></p> <pre><code>graph TB; \n    A((3))--&gt;B((2))\n    A--&gt;C((4))\n    B--&gt;D((1))\n    B--&gt;E(( ))\n    style E display:none</code></pre>"},{"location":"Arbres/#liste-triee","title":"Liste tri\u00e9e","text":"<p>Si la liste est d\u00e9j\u00e0 tri\u00e9e, on obtient une liste cha\u00een\u00e9e.</p> <p>Figure \u2013 ABR obtenu par <code>create([1;4;2;3]);;</code></p> <pre><code>graph TB; \n    A((4))--&gt;B((3))\n    A --&gt;Z(( ))\n    B--&gt;C((2))\n    B--&gt;W(( ))\n    C--&gt;D((1))\n    C--&gt;R(( ))\n    style Z display:none\n    style W display:none\n    style R display:none</code></pre>"},{"location":"Arbres/#complexite-de-la-creation","title":"Complexit\u00e9 de la cr\u00e9ation","text":"<ul> <li>Si la liste est d\u00e9j\u00e0 tri\u00e9e, l\u2019ABR n\u2019a qu\u2019une branche.</li> <li>Pour une liste tri\u00e9e de longueur \\(n\\), la complexit\u00e9 v\u00e9rifie une relation de la forme</li> </ul> \\[ \\begin{align} c_n &amp;= c_{n\u22121} + \\underbrace{n}_{\\text{cpx insertion}} + \\underbrace{c}_{\\text{autres op\u00e9ration}}  \\\\ &amp;= c_{n\u22122} + 2c + n +  \\underbrace{n-1}_{\\text{cpx insertion}} = ... \\\\ &amp;= c_0 + nc + \\sum\\limits_{k=1}^{n}k \\\\ &amp;= \\theta(n\u00b2) \\end{align}\\] <ul> <li>On voit l\u2019int\u00e9r\u00eat de maintenir un certain \u00e9quilibre dans l\u2019arbre au moment des insertions.</li> </ul>"},{"location":"Arbres/#utilite-de-lequilibrage-des-arbres","title":"Utilit\u00e9 de l\u2019\u00e9quilibrage des arbres","text":"<ul> <li>A priori, cela ne semble pas si grave d\u2019avoir une liste cha\u00een\u00e9e et non un bel arbre binaire \"\u00e9quilibr\u00e9\".</li> <li>Mais les op\u00e9rations sur les ABR (insertion, suppression, recherche) ont une complexit\u00e9 au pire qui d\u00e9pend de la hauteur...</li> <li>... d\u2019o\u00f9 l\u2019id\u00e9e qu\u2019il faut limiter la hauteur des arbres lors de l\u2019insertion.</li> <li>C\u2019est le principe du r\u00e9\u00e9quilibrage des ABR.</li> </ul>"},{"location":"Arbres/#creation-dun-arbre-equilibre-a-partir-dune-liste","title":"Cr\u00e9ation d\u2019un arbre \u00e9quilibr\u00e9 \u00e0 partir d\u2019une liste","text":"<ul> <li>Un arbre A est dit \u00e9quilibr\u00e9 lorsque \\(h(A) = O(\\log_{}(|A|))\\)</li> <li>Exemple arbres AVL: pour chaque n\u0153ud, la diff\u00e9rence entre les hauteurs de ses fils (l\u2019un \u00e9ventuellement vide) est \\(0\\), \\(1\\) ou \\(\u22121\\).</li> <li>On peut \u00e9tablir que, dans un AVL de taille \\({|A| = n} \\implies {\\frac{3}{2}\\log_{2}(n+ 1) \\geq h(A)}\\) (cf TD).</li> <li>Autre exemple : arbres Rouge-Noir (cf TD).</li> <li>Dans un arbre \u00e9quilibr\u00e9, ins\u00e9rer x se fait en \\(O(\\log_{2}(n))\\) appels internes au pire plus un nombre born\u00e9 d\u2019autres op\u00e9rations en \\(\\theta(1)\\) .</li> <li>Si on maintient le caract\u00e8re \u00e9quilibr\u00e9 (le r\u00e9\u00e9quilibrage a un co\u00fbt logarithmique -admis-), le co\u00fbt de la cr\u00e9ation \u00e0 partir d\u2019une liste est donc de l\u2019ordre de \\(\\theta(\\sum\\limits_{k=1}^{n}\\log_{2}(k)) = \\theta(\\log_{2}(n!)) = \\theta(n\\log_{2}(n))\\)</li> </ul>"},{"location":"Arbres/#rechercher","title":"Rechercher","text":"<pre><code>let rec search x t = match t with\n(* cherche x dans t *)\n| Nil -&gt; false\n| N (y ,_ , _ ) when y = x - &gt; true\n| N (y ,g , _ ) when x &lt; y -&gt; search x g\n| N (y ,_ , d ) when x &gt; y -&gt; search x d\n| _ -&gt; false ;; (* le laisser sinon \u2019 this pattern - matching is not\nexhaustive . \u2019 *)\n</code></pre> <ul> <li>Si x est \u00e9gal \u00e0 la racine de t, c\u2019est bon. Sinon on cherche r\u00e9cursivementdans le sous arbre gauche lorsque x es plus petit que la racine, et \u00e0 droite sinon.</li> <li>Si x est \u00e0 la profondeur k, il y a k appels internes pour le trouver.</li> <li>Si x n\u2019est pas dans l\u2019arbre, il y a au pire \\(h(t)\\) appels internes.</li> </ul>"},{"location":"Arbres/#suppression","title":"Suppression","text":""},{"location":"Arbres/#operation-de-fusion","title":"Op\u00e9ration de fusion","text":"<p>On veut \"fusionner\" deux ABR G et D tels que les \u00e9tiquettes de G sont toutes plus petites que celles de D. Ceci afin d\u2019obtenir un ABR unique construit \u00e0 partir des n\u0153uds des deux arbres.</p> <p><pre><code>let rec merge a b = match a , b with\n(* fusion qui privil\u00e9gie l \u2019arbre gauche *)\n| Nil , t | t , Nil -&gt; t\n| N (x , ga , da ) , N (y , gb , db ) -&gt; (* on a max a &lt;= min b *)\nN (x , ga , N (y , merge da gb , db ) ) ;; \n</code></pre> Dans cette fusion, la racine de l\u2019arbre gauche devient syst\u00e9matiquement la racine de l\u2019arbre retourn\u00e9. On aurait pu privil\u00e9gier l\u2019arbre droit. <pre><code>let a1 = N (3 , N (2 , Nil , Nil ) ,N (4 , Nil , Nil ) ) in let a2 = N (30 , N\n(20 , Nil , Nil ) ,N (40 , Nil , Nil ) ) in merge a1 a2 ;;\n(* Et on obtient : *)\nN (3, N (2, Nil, Nil),\nN (30, N (4 , Nil, N (20, Nil, Nil)),\nN (40, Nil, Nil)))\n</code></pre></p> <p>Figure \u2013 En rouge, la fusion des deux arbres bleus</p>"},{"location":"Arbres/#correction-de-la-fusion","title":"Correction de la fusion","text":"<p>Preuve par induction</p> <p>On montre que si on fusionne deux ABR a, b tels que max a \u2264 min b, alors le nouvel arbre form\u00e9 est un ABR contenant toutes les \u00e9tiquettes de a, b.</p> <ul> <li>Cas de base : si un des deux arbres est vide, on renvoie l\u2019autre. C\u2019est un ABR par hyp. et il contient bien toutes les \u00e9tiquettes des deux arbres.</li> <li>H\u00e9r\u00e9dit\u00e9. Soient <code>a = N(x, ga, da)</code> et <code>b = N(y , gb, db)</code> non vides avec max a \\(\\leq\\) min b.<ul> <li>Notre hypoth\u00e8se d\u2019induction (HI) est que la fusion d\u2019un sous-terme imm\u00e9diats de a avec un sous-terme imm\u00e9diat de b est un ABR contenant toutes les \u00e9tiquettes de ses deux sous-termes.</li> <li>La racine du nouvel arbre est x et elle est plus grande que toutes les \u00e9tiquettes de son fils gauche ga (puisque a est un ABR).</li> <li>Le fils droit est <code>d = N(y , merge(da, gb), db)</code>. Par (HI) la fusion <code>merge(da, gb)</code> est un ABR avec toutes les \u00e9tiquettes de da, gb.</li> <li>Comme y est sup\u00e9rieur aux \u00e9tiquettes de gb, elles-m\u00eames plus grandes que celles de da, il vient que y est sup\u00e9rieur aux \u00e9tiquettes de l\u2019ABR r\u00e9sultant de la fusion.</li> <li>Or y est inf\u00e9rieur aux \u00e9tiquettes de db puisque b est un ABR. Donc <code>d = N(y , merge(da, gb), db)</code> est un ABR dont toutes les \u00e9tiquettes sont aumoins plus grandes que celles de la plus petite de da. De plus il contient y et toutes les \u00e9tiquettes de da, gb, db.</li> </ul> </li> <li>Donc x est plus petit que les \u00e9tiquettes de d (qui est un ABR) et plus grand que celles de ga (qui est un ABR) donc <code>N(x, ga, d)</code> est un ABR avec toutes les \u00e9tiquettes de a, b.</li> </ul>"},{"location":"Arbres/#complexite-de-la-fusion","title":"Complexit\u00e9 de la fusion","text":"<ul> <li>Soient deux ABR g , d :     Il y a au plus autant d\u2019appels internes que le minimum de hauteur des     sous arbres.</li> <li>La complexit\u00e9 est en \\(\\theta(\\min(h(g), h(d)))\\) </li> </ul> <pre><code>let rec remove x t = match t with (* on commence par chercher x dans t *)\n| Nil -&gt; failwith \" x not found \" (* on n\u2019a pas trouv\u00e9 x *)\n| N (y ,g , d ) when x &lt; y - &gt; N (y , remove x g , d )\n| N (y ,g , d ) when x &gt; y - &gt; N (y , g , remove x d ) (* A partir d \u2019 ici\n, on a trouv \u00e9 x *)\n| N (y ,g , d ) when y = x -&gt; merge g d (* fusion des deux sous - arbres\n*)\n| _ - &gt; failwith \" ne devrait pas arriver \" ;;\n</code></pre> <p>Remarques</p> <p>Lorsque le n\u0153ud A d\u2019\u00e9tiquette x n\u2019a qu\u2019un fils, celui-ci prend la place de son p\u00e8re (on le \"remonte\"). Si A est une feuille, on se contente de la supprimer (la fusion met Empty \u00e0 la place de A).</p>"},{"location":"Arbres/#dictionnaire","title":"Dictionnaire","text":"<p>D\u00e9finition</p> <p>Tableau associatif (aussi appel\u00e9 dictionnaire ou table d\u2019association) : type de donn\u00e9es associant \u00e0 un ensemble de clefs un ensemble correspondant de valeurs. Chaque clef est associ\u00e9e \u00e0 une valeur unique : un dictionnaire correspond donc \u00e0 une application en math\u00e9matiques. Il peut \u00eatre vu comme une g\u00e9n\u00e9ralisation du tableau dont les indices ne serait pas n\u00e9cessairement des entiers.</p> <p>Op\u00e9rations usuellement fournies:</p> <ul> <li>ajout : association d\u2019une nouvelle valeur \u00e0 une nouvelle clef ;</li> <li>modification : association d\u2019une nouvelle valeur \u00e0 une ancienne clef ;</li> <li>suppression : suppression d\u2019une clef ;</li> <li>recherche : d\u00e9termination de la valeur associ\u00e9e \u00e0 une clef, si elle existe.</li> </ul> <p>Les dictionnaires peuvent \u00eatre impl\u00e9ment\u00e9s concr\u00e8tement par des ABR. Ce sont alors des donn\u00e9es persistantes. L\u2019ensemble des cl\u00e9s doit \u00eatre totalement ordonn\u00e9. Les \u00e9tiquettes des n\u0153uds de l\u2019ABR sont des couples (cl\u00e9s, valeurs) et le placement d\u2019un n\u0153ud dans l\u2019arbre est fait selon sa cl\u00e9 et non sur sa valeur. En OCAML, explorons 3 fa\u00e7ons de d\u00e9finir les dictionnaires.</p>"},{"location":"Arbres/#dictionnaires-par-liste-de-paires","title":"Dictionnaires par liste de paires","text":"<p>M\u00e9thode la plus simple. Persistante.</p> <pre><code>(* dictionnaires par liste de paires *)\nlet m = [ \" Sally Smart \" , \" 555 -9999 \" ;\n\" John Doe \" , \" 555 -1212 \" ;\n\" J . Random Hacker \" , \" 553 -1337 \" ];;\nList . assoc \" John Doe \" m ;;\n(* # - : string = \"555 -1212\" *)\n</code></pre>"},{"location":"Arbres/#dictionnaires-par-avl","title":"Dictionnaires par AVL","text":"<ul> <li>Les arbres AVL ont \u00e9t\u00e9 historiquement les premiers arbres binaires de recherche automatiquement \u00e9quilibr\u00e9s.</li> <li>Dans un arbre AVL, les hauteurs des deux sous-arbres d\u2019un m\u00eame n\u0153ud diff\u00e8rent au plus de un.</li> <li>La recherche, l\u2019insertion et la suppression sont toutes en \\(O(\\log_{2}(n))\\) dans le pire des cas.</li> <li>L\u2019insertion et la suppression n\u00e9cessitent d\u2019effectuer des rotations (op\u00e9rations de r\u00e9\u00e9quilibrage). Le nom AVL vient des deux inventeurs Georgii Adelson-Velsky et Evguenii Landis (1962).</li> </ul> <p><pre><code>(* dictionnaire applicatif r\u00e9alis\u00e9 par arbres \u00e9quilibr\u00e9s *)\ninclude ( Map . Make ( String ) ) ;;\nlet m = empty\n| &gt; add \" Sally Smart \" \" 555 -9999 \"\n| &gt; add \" John Doe \" \" 555 -1212 \"\n| &gt; add \" J . Random Hacker \" \" 553 -1337 \" ;;\nfind \" John Doe \" m ;;\n(* # - : string = \"555 -1212\" *)\n</code></pre> Structure persistante bas\u00e9e sur les arbres \u00e9quilibr\u00e9s. Ajout/Suppression/Recherche en temps logarithmique.</p>"},{"location":"Arbres/#dictionnaires-par-table-de-hachage","title":"Dictionnaires par table de hachage","text":"<pre><code>(* dictionnaires par table de hachage polymorphe *)\nlet m = Hashtbl.create 3;; (* taille attendue 3 , \u00e7 a peut changer *)\nHashtbl.add m \" Sally Smart \" \" 555 -9999 \" ;\nHashtbl.add m \" John Doe \" \" 555 -1212 \" ;\nHashtbl.add m \" J . Random Hacker \" \" 553 -1337 \" ;;\nHashtbl.find m \" John Doe \" ;;\n(* # - : string = \"555 -1212\" *)\n</code></pre> <p>Structure imp\u00e9rative. Modifications en place. Ajout/Suppression/Recherche en temps constant (en moyenne pour ajout, et pour la recherche, \u00e7a d\u00e9pend en fait de la fonction de hash).</p>"},{"location":"Arbres/#tas","title":"Tas","text":"<p>D\u00e9finition</p> <p>Un tas de hauteur h est un arbre binaire v\u00e9rifiant :</p> <ul> <li>Condition d\u2019ordre : les fils d\u2019un n\u0153ud ont une \u00e9tiquette inf\u00e9rieure ou \u00e9gale \u00e0 celle du p\u00e8re.</li> <li>Condition de structure: Un tas est complet gauche :<ul> <li>Tous les niveaux sont remplis sauf \u00e9ventuellement le dernier.</li> <li>Le dernier niveau (\u00e9ventuellement incomplet) est rempli sans trou enpartant de la gauche.</li> </ul> </li> </ul>"},{"location":"Arbres/#precisions-et-consequences","title":"Pr\u00e9cisions et cons\u00e9quences","text":"<p>\u2022 Un arbre du type pr\u00e9c\u00e9dent est dit de type tas-max (racine=max). \u2022 tas-min : l\u2019\u00e9tiquette du p\u00e8re est plus petite que celle des fils. Les branches sont toutes de longueur h ou h \u2212 1, enlever les feuilles de profondeur h donne un arbre parfait, les n\u0153uds internes de profondeur h \u2212 1 d\u2019arit\u00e9 \u2265 1 sont \u00e0 gauche des feuilles de profondeur h \u2212 1, si il y a un n\u0153ud interne de profondeur h \u2212 1 avec un seul fils, son fils est une feuille et c\u2019est le dernier n\u0153ud dans le parcours en largeur. Exemple</p> <p>Figure \u2013 Un tas. Si on enl\u00e8ve les feuilles de profondeur 2, l\u2019arbre est parfait (cf. fig. [13] pour la repr\u00e9sentation en array) Tous les niveaux sont remplies, sauf le dernier, lequel est partiellement rempli en commen\u00e7ant par la gauche. Contre-exemples Les arbres suivants ne sont pas des tas : Figure \u2013 Un n\u0153ud de hauteur h \u2212 1 et d\u2019arit\u00e9 1 est \u00e0 gauche d\u2019un n\u0153ud de hauteur h \u2212 1 d\u2019arit\u00e9 2 Figure \u2013 Un p\u00e8re a un fils d\u2019\u00e9tiquette plus grande que la sienne Page 13/30 Scpr de nono le 03/03/23 \u00e0 17:46 AutoCours - Arbre binaire de recherche Hauteur d\u2019un arbre complet gauche Soit A un arbre complet gauche \u00e0 n n\u0153uds et de hauteur p \u2022 L\u2019avant dernier niveau (qui correspond \u00e0 un arbre parfait) est rempli. Et le dernier niveau contient au moins une feuille. 2 p \u22121&lt; n\u2264 2p+1 \u22121\u23df taille min. d\u2019un arbre parfait plus gros que A \u21d2 2 p \u2264 n&lt;2p+1 \u21d2 p \u2264 log2 n&lt; p+1 \u230alog2 n\u230b= p Exemple Figure \u2013 Un tableau repr\u00e9sentant un tas BFS Observer le lien entre le parcours en largeur et la repr\u00e9sentation en tableau. Contrexemples Les arbres suivants ne sont pas des tas :</p>"}]}